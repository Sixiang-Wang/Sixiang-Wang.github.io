{
    "version": "https://jsonfeed.org/version/1",
    "title": "机煲的小窝 • All posts by \"计组\" tag",
    "description": "",
    "home_page_url": "https://blog.unfinished.top",
    "items": [
        {
            "id": "https://blog.unfinished.top/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/",
            "url": "https://blog.unfinished.top/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/",
            "title": "计算机组成",
            "date_published": "2024-01-08T10:16:31.000Z",
            "content_html": "<h1>-1 蛤？</h1>\n<p>1个字节（byte）= 8位（bit）</p>\n<p>32位系统中，1 字 = 4 字节；64位，1 字 = 8 字节</p>\n<p>在 MIPS 指令集中可以用来实现跳转到 4GB 空间内任意地址的指令是 <strong>jr</strong></p>\n<p>j：可跳转226+2=228个地址单元，即228+3bits = 256 MB</p>\n<p>beq：256 KB</p>\n<h1>0 绪论</h1>\n<h3 id=\"冯诺依曼架构\">冯诺依曼架构</h3>\n<p>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。</p>\n<p>存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令；控制器应能自动取出指令来执行；运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；操作人员可以通过输入设备、输出设备和主机进行通信。</p>\n<h3 id=\"抽象\">抽象</h3>\n<p>文件是对 I/0 设备的抽象</p>\n<p>虚拟内存是对程序存储器的抽象</p>\n<p>进程是对一个正在运行的程序的抽象：是在给定数据集上的一次程序执行</p>\n<p><img src=\"1703731953839.png\" alt=\"1703731953839\"></p>\n<h3 id=\"并发并行\">并发并行</h3>\n<p>并发:  逻辑上的并行，物理上交替执行（使系统能够同时处理多个任务）</p>\n<p>并行:  物理上的并行（使系统真正地运行更快）</p>\n<h1>1 数制与运算</h1>\n<h2 id=\"进制\">进制</h2>\n<h3 id=\"进制转换\">进制转换</h3>\n<p><img src=\"1703732717527.png\" alt=\"1703732717527\"></p>\n<p><img src=\"1703732759516.png\" alt=\"1703732759516\"></p>\n<h3 id=\"补码\">补码</h3>\n<p>补码取反加一 0011 → 1101  (3 → -3)     取反加一和减一取反效果一样</p>\n<p>反码只取反，原码只改符号位</p>\n<h3 id=\"补码运算\">补码运算</h3>\n<p>[X+Y]补= [X]补+ [Y]补，[X-Y]补=[X]补+[-Y]补</p>\n<p>3+4 = 7  0011+0100 = 0111</p>\n<p>3-4 = -1  0011+1100 = 1111</p>\n<h3 id=\"浮点数表示\">浮点数表示</h3>\n<p>阶码：01000    尾数：0.10110010001</p>\n<p>178.125 =  10110010.001 = 0.10110010001 * （2^01000）</p>\n<h3 id=\"浮点数规格化\">浮点数规格化</h3>\n<p><img src=\"1704519002020.png\" alt=\"1704519002020\"></p>\n<p>数符 S： 1位，0表示正数，1表示负数</p>\n<p>阶码 E：用移码表示，n 位阶码偏移量为 2n-1-1</p>\n<p>如8位阶码偏移量为 7FH（即127）， 11位阶码偏移量3FFH（即1023）</p>\n<p>尾数 M： 尾数必须规格化成小数点左侧一定为1，并且小数点前面这个1作为隐含位被省略。这样单精度浮点数尾数实际上为24位</p>\n<p><strong><u>计算： 1.m * 2^(E-127)  如果是双精度，是E-1023</u></strong></p>\n<p><strong><u>E一定要先减</u></strong></p>\n<p><img src=\"image-20240106140221740.png\" alt=\"image-20240106140221740\" style=\"zoom: 50%;\" /><img src=\"image-20240106140645838.png\" alt=\"image-20240106140645838\" style=\"zoom: 50%;\" /></p>\n<p>2的-126 ~ 127次方</p>\n<h3 id=\"大端小端\">大端小端</h3>\n<p><strong>大端存储模式</strong>：数据的低位保存在内存中的高地址中，数据的高位保存在内存中的低地址中；<br>\n<strong>小端存储模式</strong>：数据的低位保存在内存中的低地址中，数据的高位保存在内存中的高地址中；</p>\n<img src=\"https://img-blog.csdnimg.cn/20200525162747150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NjU5Mg==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" style=\"zoom:67%;\" />\n<h3 id=\"各种编码表示10进制\">各种编码表示10进制</h3>\n<p>8421：正常，0＝0000 1＝0001 2＝0010 3＝0011 4＝0100 … 9＝1001</p>\n<p>5421：… 3＝0011 4＝0100 5＝1000 … 9＝1100 ; 而0101是禁止码</p>\n<p>2421：… 4＝0100  5＝1011  6＝1100  7＝1101  8＝1110  9＝1111</p>\n<p>余3：每个字符编码比相应的8421码多3，0＝0011 1＝0100 2＝0101 3＝0110 … 9＝1100</p>\n<p>不是重点，但是挺逆天的</p>\n<h2 id=\"逻辑代数\">逻辑代数</h2>\n<p>按位或：“|”</p>\n<p>按位与：“&amp;”</p>\n<p>按位取反：“~”（单目运算）</p>\n<p>按位异或：“^”</p>\n<p>左移：高位移出，低位补0。可能溢出！</p>\n<p>右移：低位移出，高位补符，可能发生有效数据丢失。</p>\n<p>与：F = A·B ，F=AB   或者    F = A∧B</p>\n<p>或：F = A + B    或者  F = A ∨ B</p>\n<p>异或F=A 圆中间一个十字B</p>\n<p>同或F = A⊙ B</p>\n<p><img src=\"1704522811761.png\" alt=\"1704522811761\" style=\"zoom: 50%;\" /><img src=\"1704524870583.png\" alt=\"1704524870583\"></p>\n<p>对偶定理：将原函数F中的全部 “•” 换成 “+”，“+” 换成 “•”，“0”换成 “1”，“1” 换成 “0”，所得的新函数就是原函数的对偶式，记作F’或F*</p>\n<p>由n个变量组成的 “与” 项中，每个变量以原变量或反变量的形式出现且仅出现一次，则这个与项称为最小项</p>\n<p>n个变量有2^n个最小项</p>\n<p>全部由最小项构成的与或式，也称标准与或式</p>\n<img src=\"1704523166223.png\" alt=\"1704523166223\" style=\"zoom:50%;\" />\n<img src=\"1704523282308.png\" alt=\"1704523282308\" style=\"zoom:50%;\" />\n<img src=\"1704523306716.png\" alt=\"1704523306716\" style=\"zoom:45%;\" />\n<h3 id=\"简化公式\">简化公式</h3>\n<img src=\"1704523501199.png\" alt=\"1704523501199\" style=\"zoom:50%;\" />\n<p><img src=\"1704523947036.png\" alt=\"1704523947036\" style=\"zoom:50%;\" />吸收率1</p>\n<p><img src=\"1704523908797.png\" alt=\"1704523908797\" style=\"zoom:50%;\" />吸收率2</p>\n<h1>2 数字逻辑</h1>\n<h2 id=\"组合逻辑\">组合逻辑</h2>\n<p>从结构看，组合逻辑电路由门电路构成，不含   反馈电路       ，也不含   存储电路      ，信号从输入开始单向传输到输出。对于组合逻辑电路，任何时刻电路的输出仅由当时的  输入信号       决定</p>\n<h3 id=\"半加器\">半加器</h3>\n<p><img src=\"image-20240106150537827.png\" alt=\"image-20240106150537827\" style=\"zoom:50%;\" /><img src=\"image-20240106150548415.png\" alt=\"image-20240106150548415\" style=\"zoom:50%;\" /></p>\n<h3 id=\"全加器\">全加器</h3>\n<p><img src=\"image-20240106150930863.png\" alt=\"image-20240106150930863\" style=\"zoom: 50%;\" /><img src=\"image-20240106151004002.png\" alt=\"image-20240106151004002\" style=\"zoom: 50%;\" /></p>\n<img src=\"image-20240106150945894.png\" alt=\"image-20240106150945894\" style=\"zoom: 80%;\" />\n<h4 id=\"溢出\">溢出</h4>\n<p>“00”表示正，“11”表示负，如果运算结果符号位出现“01”（正溢）或“10” （负溢）都表示出现溢出</p>\n<p>6 = 0110   7 = 0111   6+7 = 01101，正溢出</p>\n<p>-6=1010     -7=1001  -6-7 = 10011，负溢出</p>\n<p>-3 = 1101    -3-3 = 11010  负数不溢出</p>\n<h3 id=\"数值比较器\">数值比较器</h3>\n<p><img src=\"image-20240106155205001.png\" alt=\"image-20240106155205001\" style=\"zoom:50%;\" /><img src=\"image-20240106155231376.png\" alt=\"image-20240106155231376\" style=\"zoom:50%;\" /></p>\n<h3 id=\"ALU\">ALU</h3>\n<p>操作数，选择数</p>\n<h3 id=\"编码器\">编码器</h3>\n<p>某一个输入端的信号变换成相应的一组二进制代码输出的过程叫做   编码</p>\n<img src=\"image-20240106160236976.png\" alt=\"image-20240106160236976\" style=\"zoom:50%;\" />\n<p><img src=\"1704528511028.png\" alt=\"1704528511028\" style=\"zoom: 50%;\" />74147优先编码器（谁优先输出谁）</p>\n<h3 id=\"译码器\">译码器</h3>\n<p>将二进制代码所表示的信息翻译成对应高低电平信号输出的过程称为译码</p>\n<p>3线-8线译码器（74138）</p>\n<p>3个输入：A2，A1，A0；000~111共8种输入组合。</p>\n<p>8个输出：Y7~Y0，<strong>低电平</strong>输出有效；任何时刻最多只有一个输出有效。当输入为000时，Y0输出有效；当输入为001时，Y1输出有效。</p>\n<p>3个使能控制：S0，S1，S2 为使能输入，仅当它们分别为1、0、0时，译码器才正常译码；否则禁止工作。</p>\n<h3 id=\"多路选择器\">多路选择器</h3>\n<img src=\"image-20240106162146201.png\" alt=\"image-20240106162146201\" style=\"zoom:50%;\" />\n<p>若D7-D0  = 10100101</p>\n<p>Y = m7+m5+m2+m0</p>\n<h3 id=\"竞争冒险\">竞争冒险</h3>\n<h4 id=\"竞争\">竞争</h4>\n<p>某个输入变量通过两条或两条以上的途径传到输出端，由于每条途径延迟时间不同，到达输出门的时间就有先有后</p>\n<h4 id=\"冒险\">冒险</h4>\n<p>门电路因输入端的竞争而导致输出端产生不正常的尖峰干扰脉冲信号（毛刺）的现象</p>\n<p>A+ !A 存在0冒险          A ·!A存在1冒险</p>\n<h4 id=\"卡诺图法判断\">卡诺图法判断</h4>\n<p>在逻辑函数的卡诺图中，函数的每个与项对应卡诺图上的一个卡诺圈，若两个卡诺圈相切，相切处将存在冒险。</p>\n<p><img src=\"1704530434352.png\" alt=\"1704530434352\" style=\"zoom:50%;\" /><img src=\"1704530834543.png\" alt=\"1704530834543\" style=\"zoom: 67%;\" /></p>\n<p>增加冗余项。</p>\n<p>L=AC+ ̅AB，当B=C=1时， L=A+ ̅A，存在冒险。增加冗余项 L=AC+  ̅AB+BC，逻辑函数功能不变，冒险消除。</p>\n<h2 id=\"时序逻辑\">时序逻辑</h2>\n<h3 id=\"锁存器和触发器\">锁存器和触发器</h3>\n<p>锁存器是电位（电平）触发的，只有在时钟CP有效电平（高电平CP=1或者低电平CP＝0）期间，触发器的状态才有可能发生变化。</p>\n<p>触发器的状态变化只发生在时钟CP的有效沿（上升沿或者下降沿）期间，CP＝1、CP=0时触发器的状态不会发生变化</p>\n<p>D锁存：CP=0保持；CP=1置为D的值</p>\n<h4 id=\"D触发器\">D触发器</h4>\n<p>D触发由2个D锁存组成；CP从0到1触发</p>\n<p>加使能EN：EN=1正常，EN=0一直保持</p>\n<h4 id=\"JK触发器\">JK触发器</h4>\n<p>J0K0，输出不变； J0K1，输出为0； J1K0，输出为1；J1K1，输出反转</p>\n<h3 id=\"状态机\">状态机</h3>\n<h4 id=\"Moore\">Moore</h4>\n<p><img src=\"1704532315803.png\" alt=\"1704532315803\" style=\"zoom:50%;\" /><img src=\"1704535620164.png\" alt=\"1704535620164\" style=\"zoom:50%;\" /></p>\n<p>输出信号仅与当前状态有关</p>\n<h4 id=\"Mealy\">Mealy</h4>\n<p><img src=\"image-20240106171247758.png\" alt=\"image-20240106171247758\" style=\"zoom:50%;\" /><img src=\"1704535645537.png\" alt=\"1704535645537\" style=\"zoom:50%;\" /></p>\n<p>输出信号与当前状态及输入信号有关</p>\n<p><img src=\"1704535954265.png\" alt=\"1704535954265\" style=\"zoom:33%;\" /><strong>状态转移表长这样</strong></p>\n<h3 id=\"移位寄存器\">移位寄存器</h3>\n<p><img src=\"1704537187152.png\" alt=\"1704537187152\" style=\"zoom:50%;\" /><img src=\"image-20240106183331197.png\" alt=\"image-20240106183331197\" style=\"zoom:67%;\" /></p>\n<p>脉冲一次移位一次</p>\n<h3 id=\"计数器\">计数器</h3>\n<h4 id=\"同步\">同步</h4>\n<p><img src=\"image-20240106184440187.png\" alt=\"image-20240106184440187\" style=\"zoom:50%;\" />同步计数器</p>\n<img src=\"image-20240106184621964.png\" alt=\"image-20240106184621964\" style=\"zoom:50%;\" />\n<h4 id=\"异步\">异步</h4>\n<img src=\"image-20240106184719666.png\" alt=\"image-20240106184719666\" style=\"zoom:50%;\" />\n<img src=\"image-20240106184645318.png\" alt=\"image-20240106184645318\" style=\"zoom:50%;\" />\n<h3 id=\"时钟同步？\">时钟同步？</h3>\n<p><img src=\"1704538203568.png\" alt=\"1704538203568\"></p>\n<p>Tccq：触发器时钟到Q的最小延迟</p>\n<img src=\"1704539135847.png\" alt=\"1704539135847\" style=\"zoom: 50%;\" />\n<p>Tcd：组合逻辑的延迟</p>\n<h1>3 汇编</h1>\n<h2 id=\"寻址\">寻址</h2>\n<p><strong>立即寻址</strong></p>\n<p>操作数直接在指令代码中给出。addi $s1, $s2, 100</p>\n<p><strong>寄存器直接寻址</strong></p>\n<p>操作数在寄存器中，指令地址字段给出寄存器的地址  add <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mn>1</mn><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">s1,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span></span>s2,$s3</p>\n<p><strong>寄存器间接寻址</strong></p>\n<p>操作数在存储器中，指令地址字段中给出的寄存器的内容是操作数在存储器中的地址 lw  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mn>1</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">(</mo></mrow><annotation encoding=\"application/x-tex\">s1, 0(</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mopen\">(</span></span></span></span>s2)</p>\n<p><strong>基址寻址</strong></p>\n<p>操作数在存储器中，指令地址字段给出一基址寄存器和一形式地址，基址寄存器的内容与形式地址之和是操作数的内存地址 lw  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mn>1</mn><mo separator=\"true\">,</mo><mo>∗</mo><mo>∗</mo><mo>∗</mo><mn>100</mn><mo>∗</mo><mo>∗</mo><mo>∗</mo><mo stretchy=\"false\">(</mo></mrow><annotation encoding=\"application/x-tex\">s1,***100***(</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">∗</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span></span></span></span>s2)</p>\n<p><strong>变址寻址</strong></p>\n<p>操作数在存储器中，指令地址字段给出一变址寄存器和一形式地址，变址寄存器的内容与形式地址之和是操作数的内存地址 lb <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mn>1</mn><mo separator=\"true\">,</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy=\"false\">(</mo></mrow><annotation encoding=\"application/x-tex\">t1, string(</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span></span></span></span>t0)</p>\n<p><strong>相对寻址</strong></p>\n<p>基址寻址的特例，由程序计数器PC作为基址寄存器，指令中给出的形式地址作为位移量，二者之和是操作数的内存地址。beq  $s1, $s2,  100</p>\n<p><strong>堆栈寻址</strong></p>\n<p>压栈SP -= 4；出栈SP += 4；</p>\n<h2 id=\"指令\">指令</h2>\n<h3 id=\"指令类型-R-I-J\">指令类型 R/I/J</h3>\n<p>R：两个寄存器运算，结果存到第三个</p>\n<p>I：有1个符号立即数</p>\n<p>J：跳转，26位跳转地址</p>\n<img src=\"image-20240106192507043.png\" alt=\"image-20240106192507043\" style=\"zoom: 50%;\" />\n<h3 id=\"指令格式\">指令格式</h3>\n<h4 id=\"R-Type\">R-Type</h4>\n<p>OP永为000000</p>\n<p>add：</p>\n<img src=\"image-20240106192749894.png\" alt=\"image-20240106192749894\" style=\"zoom: 50%;\" />\n<p><strong>逻辑左移sll</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mn>1</mn><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">t1,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span></span>t2,10也是R型，10存在Shamt里；sllv $t1, $t2, $t3</p>\n<p>jr $t1  # PC = $t1</p>\n<img src=\"image-20240106193339782.png\" alt=\"image-20240106193339782\" style=\"zoom:50%;\" />\n<h4 id=\"I-Type\">I-Type</h4>\n<p>rt ← rs + immediate</p>\n<img src=\"image-20240106195235935.png\" alt=\"image-20240106195235935\" style=\"zoom:50%;\" />\n<p>rt ← memory[base + offest]</p>\n<img src=\"image-20240106195301150.png\" alt=\"image-20240106195301150\" style=\"zoom:50%;\" />\n<img src=\"image-20240106195442117.png\" alt=\"image-20240106195442117\" style=\"zoom:50%;\" />\n<p>if (rs = rt) then PC ← PC + sign_extend</p>\n<img src=\"image-20240106195502445.png\" alt=\"image-20240106195502445\" style=\"zoom:50%;\" />\n<h4 id=\"J-Type\">J-Type</h4>\n<p>j直接跳转</p>\n<img src=\"image-20240106195551348.png\" alt=\"image-20240106195551348\" style=\"zoom:50%;\" />\n<p>jal 指令的意思是跳转到对应标签的位置，并将当前执行的指令位置存储在 $ra 寄存器中。</p>\n<h3 id=\"各种指令\">各种指令</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">赋值 </span><br><span class=\"line\">li $t1, 100  ori $t1, 100</span><br><span class=\"line\"></span><br><span class=\"line\">传值</span><br><span class=\"line\">move $t1, $t2</span><br><span class=\"line\"></span><br><span class=\"line\">add $t1, $t2, $t3 加</span><br><span class=\"line\">mul $t1, $t2, $t3 乘</span><br><span class=\"line\">除法</span><br><span class=\"line\">div $t1, $t2 # 计算 5 / 2，其中商存放在 lo 寄存器，而余数存放在 hi 寄存器</span><br><span class=\"line\">mfhi $t3 # 将 hi 寄存器中的值取出放到 t3 寄存器（余数，值为 1）</span><br><span class=\"line\">mflo $t4 # 将 lo 寄存器中的值取出放到 t4 寄存器（商，值为 2）</span><br><span class=\"line\"></span><br><span class=\"line\">跳转</span><br><span class=\"line\">ble $t1, 5, label</span><br><span class=\"line\">j label</span><br><span class=\"line\"></span><br><span class=\"line\">跳转到函数</span><br><span class=\"line\">jal 指令的意思是跳转到对应标签的位置，并将当前执行的指令位置存储在 $ra 寄存器中。</span><br><span class=\"line\">jr $ra 函数结束后返回！很重要</span><br><span class=\"line\"></span><br><span class=\"line\">数组</span><br><span class=\"line\">.data</span><br><span class=\"line\">array: .space 400</span><br><span class=\"line\">la $t1, array</span><br><span class=\"line\">lw $t2, 0($t1)</span><br><span class=\"line\">sw $t2, array($t3)</span><br><span class=\"line\">字符串不用lw和sw</span><br><span class=\"line\">lb $a0, 0($t0)</span><br><span class=\"line\">sb $a0, 0($t0)</span><br></pre></td></tr></table></figure>\n<img src=\"image-20240106201044299.png\" alt=\"image-20240106201044299\" style=\"zoom: 45%;\" />\n<h1>4 MIPS处理器</h1>\n<h2 id=\"MIPS模型机\">MIPS模型机</h2>\n<p>寄存器，32位虚拟地址</p>\n<p>组合部件ALU（逻辑运算）、MUX（多路选择器）Signext（符号扩展）</p>\n<p>寄存器堆：两个32位数据输出端口，一个32位数据输入端口，三个5位寄存器地址输入端口</p>\n<p>边沿触发的时钟同步方法</p>\n<h2 id=\"单周期处理器\">单周期处理器</h2>\n<p>哈佛体系结构：使用指令存储区（IM）和数据存储区（DM）分别保存指令和数据</p>\n<p>取指令</p>\n<p>32位Instruction = IM[PC]，PC+4，</p>\n<img src=\"image-20240106210307704.png\" alt=\"image-20240106210307704\" style=\"zoom:50%;\" />\n<p>R型如add</p>\n<img src=\"image-20240106211146176.png\" alt=\"image-20240106211146176\" style=\"zoom:50%;\" />\n<p>lw</p>\n<p><img src=\"image-20240106211330560.png\" alt=\"image-20240106211330560\"></p>\n<p>sw</p>\n<p><img src=\"image-20240106211413808.png\" alt=\"image-20240106211413808\"></p>\n<p><img src=\"1704546944945.png\" alt=\"1704546944945\"></p>\n<p>寄存器堆写入端地址选择MUX，选择控制信号 RegDst</p>\n<p>ALU输入端B数据源选择MUX，选择控制信号 ALUSrc</p>\n<p>寄存器堆写入端数据源选择MUX，选择控制信号 MemtoReg</p>\n<p>beq</p>\n<img src=\"image-20240106212423830.png\" alt=\"image-20240106212423830\" style=\"zoom:50%;\" />\n<img src=\"1704547957248.png\" alt=\"1704547957248\" style=\"zoom:67%;\" />\n<p>PC输入端数据源选择MUX，选择控制信号 PCSrc</p>\n<h3 id=\"控制信号\">控制信号</h3>\n<p><img src=\"1704548014476.png\" alt=\"1704548014476\"></p>\n<p>Op：控制7个控制信号</p>\n<p>Func：仅用于R型，控制ALUop</p>\n<p><strong>RegDst</strong></p>\n<p>R型指令：RegDst=1，选择Rd</p>\n<p>Lw指令： RegDst=0，选择Rt</p>\n<p>其他指令：不关心</p>\n<p><strong>ALUScr</strong></p>\n<p>R型指令：ALUSrc=0，选择寄存器堆的 Read data2 输出</p>\n<p>Lw Sw指令： ALUSrc=1，选择Signext的输出</p>\n<p>Beq指令（减法运算）： ALUSrc=0，选择 Read data2 输出</p>\n<p><strong>MemtoReg</strong></p>\n<p>R型指令：MemtoReg=0，选择 ALU 输出</p>\n<p>Lw指令： MemtoReg=1，选择数据存储器DM输出</p>\n<p>其他指令： 不关心</p>\n<p><strong>Branch</strong></p>\n<p>Beq指令：Branch=1，此时若Zero=1，PC输入选择加法器Nadd输出（分支指令目的地址），否则选择加法器Add输出（PC+4）</p>\n<p>其他指令：Branch=0，PC输入选择加法器Add输出（PC+4）</p>\n<p><img src=\"image-20240106215650460.png\" alt=\"image-20240106215650460\"></p>\n<h4 id=\"ALU控制信号\">ALU控制信号</h4>\n<p>ALUOP：10,00,01,分3种情况，10再看FUNC字段，00做一个加法，01做一个减法</p>\n<p><img src=\"1704549610485.png\" alt=\"1704549610485\"></p>\n<h3 id=\"单周期过程\">单周期过程</h3>\n<p>R 取值-读寄存器-ALU运算-写寄存器</p>\n<p>lw 取值-读寄存器-ALU运算-读数据-写寄存器</p>\n<h2 id=\"多周期流水线\">多周期流水线</h2>\n<h3 id=\"五个阶段\">五个阶段</h3>\n<ol>\n<li>\n<p>取指-IF: 取指, PC自增</p>\n</li>\n<li>\n<p>译码和读寄存器-ID:译码, 读寄存器</p>\n</li>\n<li>\n<p>执行-EX: 执行(ALU)  Lw/Sw指令:  计算内存指针  其他指令:  执行其他算术和逻辑运算</p>\n</li>\n<li>\n<p>访存-Mem:   Lw:  从内存读数据到CPU寄存器  Sw:  把寄存器的值写到内存中</p>\n</li>\n<li>\n<p>回写-WB: 把数据写回到寄存器中</p>\n</li>\n</ol>\n<p>当时钟上升沿到来时，组合逻辑计算结果写入后级寄存器</p>\n<h3 id=\"线路\">线路</h3>\n<img src=\"image-20240106230648625.png\" alt=\"image-20240106230648625\" style=\"zoom:50%;\" />\n<p>增加新MUX</p>\n<p><img src=\"1704551192433.png\" alt=\"1704551192433\"></p>\n<h2 id=\"指令相关\">指令相关</h2>\n<p><strong>针对寄存器</strong></p>\n<p>读后写，写后读，写后写</p>\n<h3 id=\"指令冲突\">指令冲突</h3>\n<p>只有写后读会有指令冲突</p>\n<h2 id=\"流水线冒险\">流水线冒险</h2>\n<p>结构冒险：资源竞争，要使用的部件正在忙</p>\n<p>数据冒险：指令执行所需的数据暂时不可用而造成的指令执行的停顿</p>\n<p>控制冒险：也称为分支冒险，必须根据前一条指令的执行结果才能确定下一条真正要执行的指令地址</p>\n<h2 id=\"\"></h2>\n<h3 id=\"结构冒险\">结构冒险</h3>\n<p>内存：流水线的数据通路需要将指令和数据分别存储</p>\n<p>寄存器：将寄存器组的使用权限分为两部分，一个时钟周期内前半个时钟周期进行写操作，后半个时钟周期进行读操作</p>\n<p>在同一个时钟周期，可以同时进行读寄存器和写寄存器的操作</p>\n<h3 id=\"数据冒险\">数据冒险</h3>\n<h4 id=\"旁发\">旁发</h4>\n<img src=\"1704553400856.png\" alt=\"1704553400856\" style=\"zoom:50%;\" />\n<p><img src=\"image-20240106223518442.png\" alt=\"image-20240106223518442\"></p>\n<h4 id=\"阻塞\">阻塞</h4>\n<p><img src=\"image-20240106230913999.png\" alt=\"image-20240106230913999\" style=\"zoom:50%;\" />阻塞+旁发</p>\n<p>阻塞等同插入nop指令</p>\n<p>条件：IF/ID的前序是lw指令，并且lw的rt寄存器与IF/ID的rs或rt相同</p>\n<ul>\n<li>冻结IF/ID：sub继续被保存（用寄存器的使能）</li>\n<li>清除ID/EX：指令全为0，等价于插入NOP（用寄存器的CLR清除）</li>\n<li>冻结PC：防止PC继续计数，PC保持不变</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub $t2,$t1,$t3</span><br><span class=\"line\">add $t3,$t1,$t2</span><br><span class=\"line\">从EX/MEM转发到ID/EX后面</span><br></pre></td></tr></table></figure>\n<p>如果有转发电路，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lw $t2, 4($t0)</span><br><span class=\"line\">add $t3, $t1, $t2</span><br></pre></td></tr></table></figure>\n<p>需要插入几个NOP指令？<strong><u>1个</u></strong></p>\n<h4 id=\"有转发的完整流水线\">有转发的完整流水线</h4>\n<img src=\"image-20240106235643532.png\" alt=\"image-20240106235643532\" style=\"zoom:50%;\" />\n<h3 id=\"控制冒险\">控制冒险</h3>\n<p>阻塞或者赌博不跳转</p>\n<p>还可以在ID前放置比较器</p>\n<h3 id=\"计算机性能\">计算机性能</h3>\n<p>响应时间：从提交作业到完成作业所花费的时间</p>\n<p>吞吐量：一定时间间隔内完成的作业数</p>\n<h1>5 主存</h1>\n<h2 id=\"工作原理\">工作原理</h2>\n<h3 id=\"RAM\">RAM</h3>\n<p><strong>随机存取存储器</strong>（RAM）</p>\n<p><img src=\"1704595506938.png\" alt=\"1704595506938\">（T是MOS管)</p>\n<p>读出：D 线先预充电到 Vpre=2.5V，然后字选线高电平，T导通</p>\n<p>若电路保存 信息1，Vcs=3.5V，电流方向从单元电路内部向外</p>\n<p>若电路保存信息 0，Vcs=0.0V，电流方向从外向单元电路内部</p>\n<p>写入操作：D 线加高电平（1，3.5V）或低电平（0，0V），字选择线置高电平，T导通；</p>\n<p>写1时，D线高电平，对Cs充电；</p>\n<p>写0时，D线低电平，Cs放电；</p>\n<h3 id=\"ROM\">ROM</h3>\n<p><strong>只读存储器</strong>（ROM）</p>\n<p>PROM</p>\n<p><img src=\"image-20240107105109481.png\" alt=\"image-20240107105109481\" style=\"zoom:25%;\" />出场时为1，当写入0烧毁熔丝，不可恢复</p>\n<p>紫外线擦除可编程的EPROM、电擦除可编程的EEPROM单元电路可以恢复</p>\n<h2 id=\"内部结构\">内部结构</h2>\n<p>芯片容量：2^n * m</p>\n<p>地址线：n位</p>\n<p>数据线：m位</p>\n<p><strong><u><em>这里就是n个字单元，每个字单元m位，很重要</em></u></strong></p>\n<p><img src=\"1704596437871.png\" alt=\"1704596437871\" style=\"zoom:50%;\" />1024×2</p>\n<p><strong>二维地址结构</strong>：</p>\n<p>4096 × 4，4096×4 = 2^14</p>\n<p>存储：2^7 * （2^5*2^2）；一行4个单元一组为一个字，一行32个字</p>\n<p><img src=\"1704596831316.png\" alt=\"1704596831316\" style=\"zoom: 67%;\" />妙哇</p>\n<h2 id=\"存储器扩展\">存储器扩展</h2>\n<h3 id=\"位扩展\">位扩展</h3>\n<p><strong>1K * 4 扩展为 1K * 8</strong>：</p>\n<img src=\"image-20240107111224018.png\" alt=\"image-20240107111224018\" style=\"zoom: 50%;\" />\n<h3 id=\"字扩展\">字扩展</h3>\n<p><strong>1K * 8 扩展为 4K * 8</strong>：</p>\n<img src=\"image-20240107111347911.png\" alt=\"image-20240107111347911\" style=\"zoom:50%;\" />\n<h3 id=\"混合扩展\">混合扩展</h3>\n<p><img src=\"image-20240107111642531.png\" alt=\"image-20240107111642531\" style=\"zoom:50%;\" />4Kx4扩展16Kx8</p>\n<h3 id=\"ROM、RAM扩展\">ROM、RAM扩展</h3>\n<img src=\"1704598394078.png\" alt=\"1704598394078\" style=\"zoom: 67%;\" />\n<p><strong>符号表示</strong></p>\n<p><img src=\"image-20240107113056551.png\" alt=\"image-20240107113056551\" style=\"zoom:33%;\" />符号表示</p>\n<p>读单元地址：Address；读控制信号：MemRead；读出数据：Readdata</p>\n<p>写单元地址：Address；写控制信号：MemWrite；写入数据：Writedata</p>\n<h3 id=\"DRAM刷新方式\">DRAM刷新方式</h3>\n<p><img src=\"1704598538571.png\" alt=\"1704598538571\" style=\"zoom:50%;\" />D线上加感应放大器</p>\n<p><img src=\"image-20240107113613672.png\" alt=\"image-20240107113613672\" style=\"zoom: 33%;\" />读1时D线电压</p>\n<p><img src=\"image-20240107113638223.png\" alt=\"image-20240107113638223\" style=\"zoom:33%;\" />读0时D线电压</p>\n<p>传感放大器会刷新Cs，让Cs保持原来状态而不是被破坏</p>\n<p><strong>分散刷新</strong></p>\n<img src=\"image-20240107114121678.png\" alt=\"image-20240107114121678\" style=\"zoom: 50%;\" />\n<p>一个存储周期分为两段: 前一段用于正常读写，后一段用于刷新操作</p>\n<p>分散刷新间隔 = 刷新行数×存储周期 = 刷新周期</p>\n<p><strong>集中刷新</strong></p>\n<img src=\"image-20240107114139422.png\" alt=\"image-20240107114139422\" style=\"zoom:50%;\" />\n<p>集中刷新间隔 = 刷新周期</p>\n<p><strong>异步刷新（最常用）</strong></p>\n<p>一个刷新周期内将存储芯片内的所有行刷新一遍，且只刷新一遍</p>\n<p>以128行为例，在2ms时间内必须轮流对每一行刷新一次，即每隔2ms/128=15.5μs刷新一行。这时假定读/写与刷新操作时间都为0.5μs，则可用前15μs进行正常读/写操作，最后0.5μs完成刷新操作</p>\n<img src=\"image-20240107114026887.png\" alt=\"image-20240107114026887\" style=\"zoom: 50%;\" />\n<p>异步刷新间隔 = 刷新周期</p>\n<h1>6 高速缓存</h1>\n<p>数据块（block）：Cache与主存的基本划分单位，也是主存与Cache一次交换数据的最小单位，由多个字节（字）组成，取决与主存一次读写操作所能完成的数据字节数。也表明主存于Cache之间局部总线的宽度。</p>\n<p>标记（tag）：Cache每一数据块有一个标记字段，用来保存该数据块对应的主存数据块的地址信息。</p>\n<p>有效位（valid bit）：Cache中每一Block有一个有效位，用于指示相应数据块中是否包含有效数据。</p>\n<p>行（line )：Cache中 一个block及其 tag、valid bit构成1行。</p>\n<p>组（set）：若干块(Block)构成一个组，地址比较一般能在组内各块间同时进行。</p>\n<p>路（way）：Cache相关联的等级，每一路具有独立的地址比较机构，各路地址比较能同时进行（一般与组结合），路数即指一组内的块数。</p>\n<p>命中率（hit rate）：目标数据在Cache中的存储访问的比例。</p>\n<p>缺失率（miss rate）：目标数据不在Cache中的存储访问的比例。</p>\n<hr>\n<p>分S组，每组E行(Block, 数据块)，每数据块包含B个字节</p>\n<p>Cache的容量：N *（ B * 8+tag位+1(valid)）bits</p>\n<h2 id=\"映射\">映射</h2>\n<h3 id=\"全相联\">全相联</h3>\n<p>主存中的某一Block可以映射到Cache中的任意一Blcok</p>\n<img src=\"image-20240107125035390.png\" alt=\"image-20240107125035390\" style=\"zoom:50%;\" />\n<p>主存地址格式：</p>\n<img src=\"image-20240107125050698.png\" alt=\"image-20240107125050698\" style=\"zoom:50%;\" />\n<p>CPU找Cache中地址时，与所有Tag进行比较</p>\n<p>灵活，成本高</p>\n<h3 id=\"直接映射\">直接映射</h3>\n<p>主存中的某一块 J 映射到Cache中的固定块 K， K ＝ J Mod C， 其中C是Cache包含的块数</p>\n<p>相当于<strong>一路组相连</strong></p>\n<img src=\"image-20240107125655315.png\" alt=\"image-20240107125655315\" style=\"zoom:50%;\" />\n<p>主存地址格式</p>\n<img src=\"image-20240107125720669.png\" alt=\"image-20240107125720669\" style=\"zoom:50%;\" />\n<p>区内索引数量 = Cache行数</p>\n<p>Cache如果有16行 = Index有4位</p>\n<p>区数量为主存行数/一个区内数量</p>\n<p><strong>例：主存容量1M字节，Cache容量4k字节，Block大小256 Bytes</strong></p>\n<p>Cache: 2^12 ÷ 2^8 = 2^4 Blocks，Index应该为4位</p>\n<p>主存: 2^12 Blocks，每个区2^4Blocks , 分成2^8个区</p>\n<p>主存地址：20位，其中高 8 位区地址，中间4位为区内块地址，低8位为块内地址。</p>\n<h3 id=\"组相联\">组相联</h3>\n<p>主存和Cache 都分成 K 组，其中Cache每组包含 L 块数据（Nc= K * L），主存每组包含M块数据；主存的块 J 以下列原则映射到 Cache 的组 I 中的任何一块（Nm= K * M） 。             I =  J  mod K  （0 ≤ I ≤ K）</p>\n<img src=\"image-20240107133841909.png\" alt=\"image-20240107133841909\" style=\"zoom:50%;\" />\n<p>主存地址格式</p>\n<img src=\"image-20240107133833645.png\" alt=\"image-20240107133833645\" style=\"zoom:50%;\" />\n<p>Cache：valid，Tag，Data</p>\n<p>在组相连中，如果只有一组，则变成了全相联了。</p>\n<p>如果组相联中每组只有一个数据块，则组相联就变成直接相联了。</p>\n<h2 id=\"替换策略\">替换策略</h2>\n<p><strong>缺失处理方式</strong></p>\n<img src=\"image-20240107140809736.png\" alt=\"image-20240107140809736\" style=\"zoom:50%;\" />\n<h3 id=\"替换方式\">替换方式</h3>\n<p>FIFO：最先装入数据的块被替换</p>\n<p>LRU：最近最少使用法</p>\n<p>访问命中时，所有块的计数值与命中块的计数值进行比较：如果某块计数值小于命中块的计数值， 则该块的计数值加 1；如果该块的计数值大于命中块的计数值，则数值不变。最后将命中块的计数器清为0。</p>\n<p>访问未命中，需要替换时，则选择计数值最大的块被替换（若最大值并列，随机选择一个）。被替换块的计数器清0，而其它的计数器则加1</p>\n<h2 id=\"性能分析\">性能分析</h2>\n<p>一般情况增加路数提高命中率，降低时间；</p>\n<p>随着块大小增加，缺失率先降低后增加；</p>\n<p>Cache所需总存储容量=（tag位+有效位+（可能的脏位）+1个数据块容量）* 块数</p>\n<p>命中率 * Cache访问时间+（1-命中率）* （装入Cache+Cache访问时间）</p>\n<p>写回（Write Back）：写操作只更新Cache中的数据，直到Block替换时才将整个Block写回主存，一般使用“脏位”（dirty bit）来表示Block在替换回主存之前是否被修改过；</p>\n<h2 id=\"要点？\">要点？</h2>\n<p>内存地址格式：  组内块地址(多少b) + 组地址(多少b) + 块内偏移地址(多少b)1</p>\n<h1>7 虚拟存储</h1>\n<p>把主存当做辅助存储器的高速缓存技术，称为虚拟存储技术，程序中可以使用较大的存储空间称为虚拟存储器</p>\n<p>固定长（简单）分区，浪费空间</p>\n<p>可变长分区，开始好，后面会产生空块</p>\n<h2 id=\"页式虚拟存储器\">页式虚拟存储器</h2>\n<p>内存分成定长小块（页），进程也分成定长小块。</p>\n<p>虚存页称为虚页，主存页称为实页</p>\n<p>一个进程用很多小块，可以不连续</p>\n<p>操作系统为进程生成页表</p>\n<p>通过页表实现逻辑地址向物理地址的转换。</p>\n<p>页表基址寄存器：保存页表在内存中的首地址</p>\n<h3 id=\"虚实地址的转换\">虚实地址的转换</h3>\n<ol>\n<li>\n<p>根据虚地址，访问主存中的页表</p>\n</li>\n<li>\n<p>根据实地址，访问主存中的物理页</p>\n</li>\n</ol>\n<img src=\"image-20240107151029798.png\" alt=\"image-20240107151029798\" style=\"zoom:50%;\" />\n<img src=\"image-20240107151913428.png\" alt=\"image-20240107151913428\" style=\"zoom:50%;\" />\n<h2 id=\"多级页表\">多级页表</h2>\n<p>二级页表页面大小为4KB的2GB虚拟存储器，每个页表项占4个字节：2^19 * 2^2=2MB</p>\n<p>一级页表2^9项（每项占4个字节），二级页表2^10项（每项占4个字节），整个一级页表常驻内存，常用的两个活跃二级页表装载到内存：  512 * 4+2 * 1K * 4 = 10KB （假定2个活跃页表换入内存时，实际占用的内存）</p>\n<img src=\"image-20240107151055751.png\" alt=\"image-20240107151055751\" style=\"zoom:50%;\" />\n<h2 id=\"例题\">例题</h2>\n<img src=\"1704611716703.png\" alt=\"1704611716703\" style=\"zoom: 67%;\" />\n<h2 id=\"快表TLB\">快表TLB</h2>\n<p>使用Cache存储部分活跃的页表项，称为TLB（快表），它包含了最近使用的那些页表项。</p>\n<p>TLB内容：标记（虚页号）、数据块（实页号）、有效位、修改位。</p>\n<p>TLB一般采用全相联或者组相联</p>\n<p><img src=\"image-20240107151819430.png\" alt=\"image-20240107151819430\"></p>\n<img src=\"image-20240107152739212.png\" alt=\"image-20240107152739212\" style=\"zoom:50%;\" />\n<p><img src=\"image-20240107153422198.png\" alt=\"image-20240107153422198\" style=\"zoom:50%;\" />TLB命中与否 与Cache是否命中 <strong>无关</strong></p>\n<img src=\"1704613616027.png\" alt=\"1704613616027\" style=\"zoom:50%;\" />\n<h1>8 链接</h1>\n<h2 id=\"目标文件的三种格式\">目标文件的三种格式</h2>\n<ul>\n<li><strong>可重定位目标文件（relocatable object file:  .o ）</strong></li>\n</ul>\n<p>包含二进制代码和数据</p>\n<p>其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件</p>\n<p>每一个 .c 源文件产生一个对应的 .o 文件</p>\n<ul>\n<li><strong>可执行目标文件（executable object file）</strong></li>\n</ul>\n<p>可以没有扩展名（Linux）或者 a.out ;    .exe(Windows)</p>\n<p>包含二进制代码和数据</p>\n<p>其形式可以被直接复制到内存并执行</p>\n<ul>\n<li><strong>共享目标文件（shared object file）</strong></li>\n</ul>\n<p>一种特殊类型的可重定位目标文件</p>\n<p>可以在加载或者运行时被动态地加载进内存并链接</p>\n<p>windows：.lib (静态链接库)  .dll （动态链接库）；Linux：.a(静态链接) .so(动态链接)</p>\n<h2 id=\"Elf格式\">Elf格式</h2>\n<p>.text: 已编译程序的机器代码（Code）</p>\n<p>.rodata: 只读数据</p>\n<p>.data: 已初始化的全局和静态 C 变量</p>\n<p>.bss:  Block Started by Symbol</p>\n<p>.symtab:   符号表</p>\n<p>.rel.text:  .text 节的重定位信息</p>\n<p>.rel.data（.rel.data.rel）:   .data节的重定位信息</p>\n<h2 id=\"链接器符号\">链接器符号</h2>\n<ul>\n<li><strong>全局符号</strong></li>\n</ul>\n<p>由模块 m 定义并能被其他模块引用的符号：非静态的 C 函数和全局变量</p>\n<ul>\n<li><strong>外部符号</strong></li>\n</ul>\n<p>由其他模块定义并被模块 m 引用的全局符号：在其他模块中定义的非静态 C 函数和全局变量</p>\n<ul>\n<li><strong>局部符号</strong></li>\n</ul>\n<p>只被模块 m 定义和引用的符号：带 static 属性的 C 函数和全局变量</p>\n<p>**局部链接器符号和局部变量不同 **连接器不知道局部变量</p>\n<p>局部非静态C变量：保存在栈上或寄存器中</p>\n<p>局部静态C变量：保存在 .data 或 .bss</p>\n<h2 id=\"符号解析\">符号解析</h2>\n<h3 id=\"局部符号\">局部符号</h3>\n<p>在相同模块中定义和引用</p>\n<p>编译器只允许每个模块中每个局部符号有一个定义</p>\n<p>其解析简单明了</p>\n<h3 id=\"全局符号\">全局符号</h3>\n<p>符号在当前模块中无定义：编译器会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理</p>\n<p>如果链接器在它的任何输入模块中都找不到这个被引用符号的定义：输出一条错误信息并终止</p>\n<p>还有一种情况：多个目标文件可能会定义相同名字的全局符号</p>\n<ul>\n<li><strong>全局符号分为强符号和弱符号</strong></li>\n</ul>\n<p>强符号：函数和已初始化的全局变量</p>\n<p>弱符号：未初始化的全局变量和外部符号</p>\n<ul>\n<li>\n<p>不允许有多个同名的强符号：每个强符号只能定义一次，否则链接错误</p>\n</li>\n<li>\n<p>如果有一个强符号和多个弱符号同名，那么选择强符号</p>\n</li>\n<li>\n<p>如果有多个弱符号同名，那么从这些弱符号中任意选择一个</p>\n</li>\n</ul>\n<h2 id=\"静态库\">静态库</h2>\n<p>ar rcs name.a name1.o name2.o ：创建静态库</p>\n<p>gcc -static -o test test.o ./name.a ：链接静态库</p>\n<img src=\"1704617901075.png\" alt=\"1704617901075\" style=\"zoom:50%;\" />\n<img src=\"1704617936261.png\" alt=\"1704617936261\" style=\"zoom:50%;\" />\n<h2 id=\"链接去年好像没考😅\">链接去年好像没考😅</h2>\n<h1>9 总线和IO</h1>\n<h2 id=\"总线仲裁\">总线仲裁</h2>\n<h3 id=\"链式查询方式\">链式查询方式</h3>\n<p>总线控制器（仲裁器）收到总线申请BR，BG（总线同意信号）逐个往下传；</p>\n<p>到某接口有总线申请（BR：总线申请信号），BG停止往下传；</p>\n<p>该接口获得总线使用权，并建立总线忙信号BS。</p>\n<h3 id=\"计数器定时查询方式\">计数器定时查询方式</h3>\n<p>总线控制器（仲裁器）收到总线申请BR，仲裁器上的计数器开始计数；</p>\n<p>当某个有总线申请的设备地址与计数器一致，便获得总线使用权，并建立总线忙信号BS</p>\n<h3 id=\"独立请求方式\">独立请求方式</h3>\n<p>每个设备有独立的请求信号和总线同意信号；</p>\n<p>总线控制器根据设备的优先级决定将总线的使用权交给哪个设备。</p>\n<h2 id=\"IO\">IO</h2>\n<p>I/O地址（I/O接口地址, I/O端口地址）：实际上是I/O接口电路中寄存器的地址（外设寄存器）</p>\n<p>？？</p>\n<h2 id=\"程序查询IO\">程序查询IO</h2>\n<p>编程式I/O</p>\n<p>控制命令：激活外设完成动作。如指示磁带机快进或快退，控制命令与设备类型相关；</p>\n<p>测试命令：测试与I/O接口及其外部设备的各种状态条件；</p>\n<p>读命令：使I/O接口从外设获得一个数据项，存入内部缓冲区；</p>\n<p>写命令：使I/O接口从数据总线获得一个数据项，然后传送到外设。</p>\n<ul>\n<li>I/O操作由CPU直接完成（通过执行I/O指令完成）</li>\n<li>外设速度慢，CPU速度快，在外设准备过程中，CPU处在不断的查询之中，CPU的效率浪费严重</li>\n<li>外设与CPU完全串行工作</li>\n</ul>\n<h2 id=\"中断IO\">中断IO</h2>\n<p>顾名思义</p>\n<h2 id=\"DMA\">DMA</h2>\n<p>DMA控制器接到DMA应答信号后，通过控制逻辑向系统总线发送存储器地址信号、存储器读写控制信号、I/O接口读写控制信号等，完成一次数据传送。</p>\n<p>若是单字传输，一般仅需要一个总线周期，所以这种方式称为周期窃取（cycle-stealing，或者叫周期挪用）方式。若是成组传输，需要多个总线周期来完成。所有数据传送结束后，通过中断方式告知CPU进行善后处理。</p>\n<p>CPU仅在开始DMA操作之前和完成DMA操作之后参与I/O处理，在DMA过程中，CPU可以运行原来的程序</p>\n<p><strong>停止CPU访问内存（成组传送方式）</strong></p>\n<p>一次DMA请求得到响应后，DMA控制器完全占用总线，进行块数据（多字）传送，直到所有数据传送完毕才释放总线，这段时间完全停止CPU访问内存。</p>\n<p>适应高速外设与存储器交换数据的情况。</p>\n<p><strong>周期窃取方式（单字传送方式，DMA和CPU交替使用总线）</strong></p>\n<p>每次DMA请求得到响应后，DMA控制器窃取一个总线周期完成一次数据传送，然后释放总线，CPU接着使用一个总线周期，然后DMA再窃取一个周期，这样持续循环下去，直到数据传输结束。</p>\n<p>一般情况下，CPU 不访问存储器时释放总线</p>\n<p>一般适应存储器速度远高于I/O设备速度的情况。</p>\n",
            "tags": [
                "大学",
                "总结",
                "计组"
            ]
        }
    ]
}