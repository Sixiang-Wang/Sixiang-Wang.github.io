{
    "version": "https://jsonfeed.org/version/1",
    "title": "机煲的小窝 • All posts by \"大学\" tag",
    "description": "",
    "home_page_url": "https://blog.unfinished.top",
    "items": [
        {
            "id": "https://blog.unfinished.top/2025/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/",
            "url": "https://blog.unfinished.top/2025/01/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0/",
            "title": "计算机网络复习",
            "date_published": "2025-01-03T09:57:49.000Z",
            "content_html": "<img src=\"我要成为高手.png\" alt=\"我要成为高手\"  /> \n<h1>计算机网络概述</h1>\n<h3 id=\"层次划分\">层次划分</h3>\n<table>\n<thead>\n<tr>\n<th>OSI参考模型</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用层</td>\n<td>为用户或应用程序服务的接口</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>负责数据的表示、翻译和格式化</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>会话和对话控制</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>端到端的可靠数据传输服务</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>解决异构网络的问题</td>\n</tr>\n<tr>\n<td>数据链路层</td>\n<td>解决可靠性、解决共享信道</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>解决比特流在信道上传输的可行性</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>TCP/IP概念层次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用层</td>\n</tr>\n<tr>\n<td>传输层</td>\n</tr>\n<tr>\n<td>网际层</td>\n</tr>\n<tr>\n<td>网络接口</td>\n</tr>\n</tbody>\n</table>\n<p>传输层：数据段</p>\n<p>网络层：分组</p>\n<p>数据链路层：数据帧</p>\n<p>物理层：比特</p>\n<blockquote>\n<p>[!TIP]</p>\n<blockquote>\n<p>玛德莫名其妙</p>\n</blockquote>\n<p>因特网采用TCP/IP体系结构</p>\n</blockquote>\n<h3 id=\"协议\">协议</h3>\n<p>网络协议的三要素</p>\n<ul>\n<li>语法：数据或控制信息的数据结构</li>\n<li>语义：协议元素的含义</li>\n<li>时序：信息的<strong>每一个单元或事件的传送或执行顺序</strong></li>\n</ul>\n<h3 id=\"性能指标\">性能指标</h3>\n<p>速率：b/s bps</p>\n<p>带宽：单位Hz，和bps本质一样</p>\n<p>吞吐量：单位时间通过网络的实际数据量</p>\n<p>信道利用率：有数据通过时间/总时间</p>\n<h1>物理层</h1>\n<h3 id=\"基本概念\">基本概念</h3>\n<p>信道：向某个方向传输信息的媒体</p>\n<p>信号：数据的电气或电磁表现</p>\n<p>码元：时间轴上的一个信号编码单元</p>\n<p>波特：码元传输速率单位</p>\n<p>比特率：数据传输速率</p>\n<h3 id=\"编码方式\">编码方式</h3>\n<img src=\"image-20241228202933127.png\" alt=\"image-20241228202933127\" style=\"zoom: 67%;\" /> \n<p>曼彻斯特：先低后高为0，先高后低为1</p>\n<p>差分曼彻斯特：前半个码元电平与前一个码元后半个相同为1，反之为0。（保持为1，取反为0）</p>\n<h3 id=\"尼奎斯特和香农公式\">尼奎斯特和香农公式</h3>\n<p>尼奎斯特：理想低通信道，无噪声</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>C</mi><mo>=</mo><mn>2</mn><mi>W</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>M</mi><mspace linebreak=\"newline\"></mspace><mi>C</mi><mo>:</mo><mtext>传输率</mtext><mi>b</mi><mi mathvariant=\"normal\">/</mi><mi>s</mi><mspace linebreak=\"newline\"></mspace><mi>W</mi><mo>:</mo><mtext>带宽</mtext><mi>H</mi><mi>z</mi><mspace linebreak=\"newline\"></mspace><mi>M</mi><mo>:</mo><mtext>信号电平级数</mtext><mspace linebreak=\"newline\"></mspace><mn>2</mn><mi>W</mi><mtext>是码元最高传输速率</mtext><mi>M</mi><mtext>是码元能代表几种数据</mtext></mrow><annotation encoding=\"application/x-tex\">C = 2Wlog_2M\\\\\nC:传输率 b/s\\\\\nW:带宽Hz\\\\\nM:信号电平级数\\\\\n2W是码元最高传输速率\nM是码元能代表几种数据\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">传</span><span class=\"mord cjk_fallback\">输</span><span class=\"mord cjk_fallback\">率</span><span class=\"mord mathnormal\">b</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">s</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">带</span><span class=\"mord cjk_fallback\">宽</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">信</span><span class=\"mord cjk_fallback\">号</span><span class=\"mord cjk_fallback\">电</span><span class=\"mord cjk_fallback\">平</span><span class=\"mord cjk_fallback\">级</span><span class=\"mord cjk_fallback\">数</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">码</span><span class=\"mord cjk_fallback\">元</span><span class=\"mord cjk_fallback\">最</span><span class=\"mord cjk_fallback\">高</span><span class=\"mord cjk_fallback\">传</span><span class=\"mord cjk_fallback\">输</span><span class=\"mord cjk_fallback\">速</span><span class=\"mord cjk_fallback\">率</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">M</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">码</span><span class=\"mord cjk_fallback\">元</span><span class=\"mord cjk_fallback\">能</span><span class=\"mord cjk_fallback\">代</span><span class=\"mord cjk_fallback\">表</span><span class=\"mord cjk_fallback\">几</span><span class=\"mord cjk_fallback\">种</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">据</span></span></span></span></span></p>\n<p>香农公式：非理想信道计算</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>C</mi><mo>=</mo><mi>W</mi><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mfrac><mi>S</mi><mi>N</mi></mfrac><mo stretchy=\"false\">)</mo><mspace linebreak=\"newline\"></mspace><mi>C</mi><mo>:</mo><mtext>传输率，</mtext><mi>b</mi><mi mathvariant=\"normal\">/</mi><mi>s</mi><mspace linebreak=\"newline\"></mspace><mi>W</mi><mo>:</mo><mtext>带宽，</mtext><mi>H</mi><mi>z</mi><mspace linebreak=\"newline\"></mspace><mfrac><mi>S</mi><mrow><msub><mi>N</mi><mi>d</mi></msub><mi>b</mi></mrow></mfrac><mo>:</mo><mtext>信噪比，</mtext><mi>d</mi><mi>B</mi><mspace linebreak=\"newline\"></mspace><mfrac><mi>S</mi><mi>N</mi></mfrac><mo>=</mo><mn>1</mn><msup><mn>0</mn><mrow><mfrac><mi>S</mi><msub><mi>N</mi><mrow><mi>d</mi><mi>b</mi></mrow></msub></mfrac><mi mathvariant=\"normal\">/</mi><mn>10</mn></mrow></msup><mspace linebreak=\"newline\"></mspace><mtext>若带宽</mtext><mi>W</mi><mo>=</mo><mn>3</mn><mi>K</mi><mi>H</mi><mi>z</mi><mtext>，信噪比</mtext><mn>30</mn><mi>d</mi><mi>B</mi><mi>C</mi><mo>=</mo><mn>3000</mn><mo>∗</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mn>1</mn><msup><mn>0</mn><mn>3</mn></msup><mo stretchy=\"false\">)</mo><mo>=</mo><mn>30000</mn><mi>b</mi><mi mathvariant=\"normal\">/</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">C=Wlog_2(1+\\frac{S}{N})\\\\\nC:传输率，b/s\\\\\nW:带宽，Hz\\\\\n\\frac{S}{N_db}:信噪比，dB\\\\\n\\frac{S}{N}=10^{\\frac{S}{N_{db}}/10}\\\\\n若带宽W=3KHz，信噪比30dB\nC=3000*log_2(1+10^3)=30000b/s\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.04633em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">传</span><span class=\"mord cjk_fallback\">输</span><span class=\"mord cjk_fallback\">率</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\">b</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">s</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">带</span><span class=\"mord cjk_fallback\">宽</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:2.19633em;vertical-align:-0.8360000000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.3139999999999996em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.33610799999999996em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">d</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathnormal\">b</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8360000000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">信</span><span class=\"mord cjk_fallback\">噪</span><span class=\"mord cjk_fallback\">比</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:2.04633em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1338350000000001em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.1338350000000001em;\"><span style=\"top:-3.5233700000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8720928571428572em;\"><span style=\"top:-2.656em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3448em;\"><span style=\"top:-2.3448em;margin-left:-0.10903em;margin-right:0.1em;\"><span class=\"pstrut\" style=\"height:2.69444em;\"></span><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">d</span><span class=\"mord mathnormal mtight\">b</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.34963999999999995em;\"><span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.384em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.5937428571428571em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span><span class=\"mord mtight\">/</span><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">若</span><span class=\"mord cjk_fallback\">带</span><span class=\"mord cjk_fallback\">宽</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\" style=\"margin-right:0.08125em;\">H</span><span class=\"mord mathnormal\" style=\"margin-right:0.04398em;\">z</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">信</span><span class=\"mord cjk_fallback\">噪</span><span class=\"mord cjk_fallback\">比</span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord mathnormal\">d</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">3</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord mathnormal\">b</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">s</span></span></span></span></span></p>\n<h1>数据链路层</h1>\n<p>如何在有差错的线路上，进行无差错传输</p>\n<p>组帧，以7E开头（01111110）</p>\n<p><strong>基本功能：</strong></p>\n<ul>\n<li>链路管理：数据链路的建立、维护和释放</li>\n<li>定界与同步：能够从接受到的比特流当中准确的区分出一帧的开始和结束</li>\n<li>差错控制：纠错和差错检测</li>\n<li>流量控制：调节通讯双方通讯速度</li>\n<li>寻址：确保每一帧能够到达正确的目的端</li>\n</ul>\n<h2 id=\"差错检测和纠正\">差错检测和纠正</h2>\n<h3 id=\"奇偶校验\">奇偶校验</h3>\n<p>原始数据最后增加一个比特位，让结果中1的个数为奇数（奇校验）或者偶数（偶校验）</p>\n<p>原始数据11010采用偶校验 👉新数据为110101</p>\n<h3 id=\"循环冗余校验（CRC）\">循环冗余校验（CRC）</h3>\n<p>约定一个多项式G(x)假设为x^4+x+1，即10011</p>\n<p>在带校验数据后补上4个0（因为Gx最高阶为4）</p>\n<p>带校验数据1101011011→11010110110000</p>\n<p>用<strong>模2除法</strong>把带校验数据除以G（x）</p>\n<blockquote>\n<p>[!WARNING]</p>\n<p><u><em><strong>不是除法！</strong></em></u></p>\n</blockquote>\n<p><img src=\"image-20241229143856682.png\" alt=\"image-20241229143856682\"></p>\n<p>最后结果为1101,0110,1111,10</p>\n<h2 id=\"数据链路层协议\">数据链路层协议</h2>\n<p>假设没有出错可以使用：</p>\n<p><strong>具有最简单流量控制的协议</strong></p>\n<p>发送方：</p>\n<ol>\n<li>取数据帧</li>\n<li>送到数据链路层发送缓存</li>\n<li>发送</li>\n<li>等待</li>\n<li>接受到接收节点的确认信息，转到1</li>\n</ol>\n<p>接收方</p>\n<ol>\n<li>等待</li>\n<li>收到数据帧，存到缓存</li>\n<li>缓存上交到主机</li>\n<li>发送确认信息到发送方</li>\n<li>转到1</li>\n</ol>\n<p><img src=\"image-20241229144818995.png\" alt=\"image-20241229144818995\"></p>\n<h3 id=\"停止等待协议\">停止等待协议</h3>\n<p><img src=\"image-20241229144955608.png\" alt=\"image-20241229144955608\"></p>\n<p><strong>一个比特可表示</strong> <strong>0</strong> <strong>和</strong> <strong>1</strong> <strong>两种不同的序号</strong></p>\n<p>确认帧带有序号，ACKn表示n-1号帧已经收到，<strong>期望接收</strong>第 n号帧</p>\n<p>ACK1表示收到0号帧；ACK0表示收到1号帧</p>\n<p><strong>发送方</strong></p>\n<img src=\"image-20241229152149769.png\" alt=\"image-20241229152149769\" style=\"zoom: 45%;\" /> \n<p><strong>接收方</strong></p>\n<img src=\"image-20241229152209500.png\" alt=\"image-20241229152209500\" style=\"zoom:45%;\" />  \n<p><strong>停止等待协议流图</strong></p>\n<p><img src=\"image-20241229152854873.png\" alt=\"image-20241229152854873\"></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>R</mi><mi>T</mi><mi>T</mi><mtext>：往返时延</mtext><mspace linebreak=\"newline\"></mspace><msub><mi>T</mi><mi>D</mi></msub><mtext>：分组的发送时延</mtext><mspace linebreak=\"newline\"></mspace><msub><mi>T</mi><mi>A</mi></msub><mtext>：确认的发送时延</mtext></mrow><annotation encoding=\"application/x-tex\">RTT：往返时延\\\\\nT_D：分组的发送时延\\\\\nT_A：确认的发送时延\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">往</span><span class=\"mord cjk_fallback\">返</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">延</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">分</span><span class=\"mord cjk_fallback\">组</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">发</span><span class=\"mord cjk_fallback\">送</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">延</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">确</span><span class=\"mord cjk_fallback\">认</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">发</span><span class=\"mord cjk_fallback\">送</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">延</span></span></span></span></span></p>\n<h3 id=\"连续ARQ：后退N帧协议GBN\">连续ARQ：后退N帧协议GBN</h3>\n<p><img src=\"image-20241229161544583.png\" alt=\"image-20241229161544583\"></p>\n<p><strong>接收端只按序接收数据帧</strong>：收到出错的DATA2后，虽然收到了Data3-5但是要丢弃，并且重传ACK2（因为DATA2出错，希望得到DATA2）</p>\n<p><strong>发送端计时器超时重传</strong>：等不到ACK3，超时后从DATA2开始全部重传</p>\n<h3 id=\"选择重传协议\">选择重传协议</h3>\n<p>接收端的滑动窗口大于1，</p>\n<p>发送端超时没有收到ACK(n)  就重发 Data(n)，<strong>不会全部重发</strong></p>\n<h3 id=\"滑动窗口\">滑动窗口</h3>\n<p><strong>连续</strong> <strong>ARQ</strong>协议中，<strong>接收窗口</strong>大小为1</p>\n<ul>\n<li><strong>只有当收到的帧的序号与接收窗口一致时才能接收该帧</strong></li>\n<li>收到一个序号正确的帧，<strong>接收窗口就向前滑动</strong>，同时发送ACK</li>\n</ul>\n<p>接收窗口向前滑动→发送确认→发送窗口可能向前滑动</p>\n<p><strong>当用</strong> <strong>n</strong> <strong>个比特进行编号</strong>：滑动窗口最大  <u>2^n <strong>- 1</strong></u></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>发送窗口</th>\n<th>接收窗口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>停止等待协议</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>连续ARQ（后退N帧协议）</td>\n<td>&gt;1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>选择重传协议</td>\n<td>&gt;1</td>\n<td>&gt;1</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"信道利用率\">信道利用率</h3>\n<p><strong>T（发送周期）：从开始发送数据到收到第一个确认帧为止</strong></p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>信道利用率</mtext><mo>=</mo><mfrac><mi>L</mi><mi>C</mi></mfrac><mo>×</mo><mfrac><mn>1</mn><mi>T</mi></mfrac><mspace linebreak=\"newline\"></mspace><mfrac><mi>L</mi><mi>C</mi></mfrac><mo>:</mo><mtext>发送数据所用时长</mtext><mspace linebreak=\"newline\"></mspace><mi>L</mi><mo>:</mo><mi>T</mi><mtext>时间内发送的数据数量</mtext><mspace linebreak=\"newline\"></mspace><mi>C</mi><mo>:</mo><mtext>发送传输率</mtext></mrow><annotation encoding=\"application/x-tex\">信道利用率=\\frac{L}{C}\\times\\frac{1}{T}\\\\\n\\frac{L}{C}:发送数据所用时长\\\\\nL:T时间内发送的数据数量\\\\\nC:发送传输率\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">信</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">利</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">率</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.04633em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.00744em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:2.04633em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">L</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">发</span><span class=\"mord cjk_fallback\">送</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">据</span><span class=\"mord cjk_fallback\">所</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">长</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">间</span><span class=\"mord cjk_fallback\">内</span><span class=\"mord cjk_fallback\">发</span><span class=\"mord cjk_fallback\">送</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">据</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">量</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">发</span><span class=\"mord cjk_fallback\">送</span><span class=\"mord cjk_fallback\">传</span><span class=\"mord cjk_fallback\">输</span><span class=\"mord cjk_fallback\">率</span></span></span></span></span></p>\n<h3 id=\"HDLC和PPP\">HDLC和PPP</h3>\n<p>主站：<strong>负责控制整个链路的操作</strong>，<strong>由主站发出的帧为命令</strong></p>\n<p>从站：<strong>在主站的控制下进行操作</strong>，<strong>由从站发出的帧为响应</strong></p>\n<p><strong>链路结构</strong></p>\n<p>非平衡：一个主站多个从站</p>\n<p>平衡：两个组合站</p>\n<p><strong>HDLC</strong></p>\n<p>真的。。。会考？吗？</p>\n<p>考研不考。</p>\n<p><img src=\"image-20241229192411603.png\" alt=\"image-20241229192411603\"></p>\n<p><strong>PPP：点对点</strong></p>\n<p>不是总线型，不适用CSMA/CD</p>\n<p>用于<strong>广域网</strong></p>\n<p><img src=\"image-20241229192309151.png\" alt=\"image-20241229192309151\"></p>\n<p>异步传输采用转义法，填入转义字符0x7D</p>\n<p>同步传输采用零比特填充法，连续5个1后填入1个0</p>\n<h2 id=\"局域网的数据链路层\">局域网的数据链路层</h2>\n<p><strong>信道共享技术</strong></p>\n<p>随缘看看？</p>\n<p>静态划分：</p>\n<ul>\n<li>频分复用：不同频率上传输</li>\n<li>时分复用：带宽一样，变成多个时间片依次发送</li>\n<li>波分复用：<strong>光</strong>的频分复用</li>\n<li>码分复用：每个端都有个自己的码，互相正交。发1则把码发出去，发0则发取反码。</li>\n</ul>\n<p>动态媒体介入控制：</p>\n<ul>\n<li>随机接入：ALOHA（接收方判断冲突，发送方超时重传）、CSMA</li>\n<li>轮询：<strong>令牌环网传递令牌，有空令牌的才发，收到令牌看是不是给自己的，不是接着传，是的话复制一份接着传，转一圈发现没出错就变成空令牌</strong>（负载严重时能较好的工作）</li>\n</ul>\n<h3 id=\"CSMA-CD\">CSMA/CD</h3>\n<h4 id=\"CMSA\">CMSA</h4>\n<p>CS：载波监听，发送前会先检测总线上是否有人发数据</p>\n<p>MA：多点接入，多个计算机接在一个总线</p>\n<p>1-坚持CSMA：空闲就发，忙则一直监听，冲突则等待一个随机时间再监听</p>\n<p>非坚持CSMA：空闲就发，忙则等待一个随机时间再监听</p>\n<p>p-坚持CSMA：空闲则以p概率发，1-p概率等下一个时间单位再发；忙则一直监听；冲突则等待一个时间单位再监听</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>这是重点</p>\n</blockquote>\n<h4 id=\"CD\">CD</h4>\n<p>CD：碰撞检测</p>\n<p><img src=\"image-20241229202154923.png\" alt=\"image-20241229202154923\"></p>\n<p>为了检测冲突，最小帧长为 2 * Prop * 传输速率（确保传完之前能检测到碰撞）</p>\n<p>Prop = 线路长度/电磁波在传播速度</p>\n<p><strong>2Prop</strong>为争用期，也称碰撞窗口</p>\n<p>以太网取51.2μs为争用期，对于10Mb/s的以太网，成勇气可以发送512bit也就是64字节。若前64字节没有冲突，那么后续也不会冲突。</p>\n<p>以太网取64字节为最短有效帧长</p>\n<p>发生碰撞后，推迟一段时间才能发送，基本退避时间一般取争用期2T</p>\n<p>k = min[重传次数, 10]，从[0,2^k   -1]随机取一个r，重传等待的时间为<strong>r倍的2T</strong></p>\n<p>当重传达到16次还是不成功，说明网络拥挤，直接抛弃此帧报告出错。</p>\n<h3 id=\"MAC地址\">MAC地址</h3>\n<p>48位Mac地址，每一台主机都有独立标识符，通常是12个十六进制数来表示</p>\n<p>mac地址举例（01:23:45:67:89:AB）</p>\n<p>目的地址和源地址都是6字节（48位）</p>\n<p>类型指明<strong>网络层</strong>使用的协议，因为<strong>64字节为最短有效帧长</strong>（上面说了），所以数据段最短为<strong>46字节</strong></p>\n<p>FCS：采用CRC校验</p>\n<img src=\"image-20241229220712926.png\" alt=\"image-20241229220712926\" style=\"zoom:100%;\" /> \n<p>为什么没有结束的“后导”码：采用曼彻斯特编码，发送的时候1为前高后低，0为前低后高；发完了直接就没信号了，电平不变</p>\n<h3 id=\"局域网和VLAN\">局域网和VLAN</h3>\n<p>VLAN是虚拟局域网</p>\n<p>创建VLAN后交换机转发表形如：</p>\n<table>\n<thead>\n<tr>\n<th>MAC地址</th>\n<th>端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A的地址</td>\n<td>1</td>\n</tr>\n<tr>\n<td>B的地址</td>\n<td>2</td>\n</tr>\n<tr>\n<td>C的地址</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>VLAN ID</th>\n<th>端口</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>交换机之间建立VLAN发送数据会在数据帧插入VLAN标记</p>\n<p><img src=\"image-20241230141150645.png\" alt=\"image-20241230141150645\"></p>\n<h4 id=\"网桥\">网桥</h4>\n<p>网桥会通过数据 学习 不同地址对应的接口。</p>\n<p><img src=\"image-20241230143307475.png\" alt=\"image-20241230143307475\"></p>\n<ul>\n<li>使用网桥能够隔开各个网段的碰撞域</li>\n<li>扩大物理范围</li>\n<li>提高可靠性</li>\n<li>过滤通信量，增大吞吐量</li>\n</ul>\n<p>但是只能用于用户不太多的局域网，</p>\n<ul>\n<li>广播信息过多会产生广播风暴</li>\n</ul>\n<h4 id=\"其他概念\">其他概念</h4>\n<p>交换机：学习、转发、过滤</p>\n<p>冲突域：任意时刻，<strong>一个碰撞域中，只能有一个站在发送数据</strong></p>\n<p>广播域：<strong>同一广播包能到达的所有设备集合</strong></p>\n<h3 id=\"交换机和路由器\">交换机和路由器</h3>\n<p>交换机能划分冲突域，<strong>不划分广播域</strong></p>\n<p>路由器可以划分广播域</p>\n<h1>网络层</h1>\n<p>网络层功能：</p>\n<ul>\n<li>路由选择和分组转发，找到最佳路径</li>\n<li>异构网络的互联</li>\n<li>拥塞控制</li>\n<li>尽最大可能交付</li>\n<li><strong>不可靠传输！</strong></li>\n</ul>\n<img src=\"image-20241230173853910.png\" alt=\"image-20241230173853910\" style=\"zoom:80%;\" /> \n<p><strong>因特网采用数据报形式</strong></p>\n<p><strong>为什么要有IP地址和MAC地址两种地址：</strong></p>\n<p><strong>IP 地址</strong>解决了设备在大规模网络中的定位和路由问题，适用于网络间通信。</p>\n<p><strong>MAC 地址</strong>解决了局域网中设备的物理标识和直接通信问题。</p>\n<p>MAC地址是固定的，无法适应网络位置变化，难以支持跨网络分组转发</p>\n<h2 id=\"IP数据报\">IP数据报</h2>\n <img src=\"image-20241230174447326.png\" alt=\"image-20241230174447326\" style=\"zoom: 30%;\" /> \n<ul>\n<li>首部长度：记录数据报头部长度。<strong>单位是4Byte</strong>也就是32bit。因为报文头部固定部分长度为<strong>20B</strong>，所以首部长度最少是5（0101），最大为15（1111）</li>\n<li>区分服务：服务的类型</li>\n<li>总长度：整个IP数据报文长度。<strong>单位是1Byte</strong>，所以IP报文理论最大上限长度是2^16-1 = 65535 Byte</li>\n<li>生存时间：TTL，没经过一个路由器-1</li>\n<li>协议：<img src=\"image-20241230175457883.png\" alt=\"image-20241230175457883\" style=\"zoom: 67%;\" /></li>\n</ul>\n<h3 id=\"数据报分片\">数据报分片</h3>\n<p><strong>数据链路层有最大长度限制，所以需要把IP数据报文分片。</strong></p>\n<img src=\"image-20241230192714482.png\" alt=\"image-20241230192714482\" style=\"zoom:50%;\" /> \n<p>假如数据长度2200字节，MTU现在设定最大820字节，IP头部20字节，那么需要分成（820，820，620）三个片</p>\n<img src=\"image-20241230193107372.png\" alt=\"image-20241230193107372\" style=\"zoom: 67%;\" />  \n<ul>\n<li>\n<p>标识：确定不同分片对应的的数据报文，为了后续拼接</p>\n</li>\n<li>\n<p>标志：占三个位：空位 DF MF；</p>\n<ul>\n<li>DF=1禁止分片，DF=0允许分片；</li>\n<li>MF=1表示后面还有分片，MF=0代表是最后一个分片</li>\n</ul>\n</li>\n<li>\n<p>片偏移以 <strong>8Byte</strong> 为单位<img src=\"image-20241230215535927.png\" alt=\"image-20241230215535927\" style=\"zoom: 67%;\" /></p>\n</li>\n</ul>\n<blockquote>\n<p>[!IMPORTANT]</p>\n<p><strong><u>奇奇怪怪的单位</u></strong></p>\n<p>首部长度：以4Byte为单位</p>\n<p>总长度：以1Byte为单位</p>\n<p>片偏移：以8Byte为单位</p>\n</blockquote>\n<h3 id=\"IP地址划分\">IP地址划分</h3>\n<p><img src=\"image-20241230222944661.png\" alt=\"image-20241230222944661\"></p>\n<p><img src=\"image-20241231143140233.png\" alt=\"image-20241231143140233\"></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0.0.0.0</td>\n<td>缺省路由</td>\n<td>可作为源地址，不可以作为目的地址</td>\n</tr>\n<tr>\n<td>255.255.255.255</td>\n<td>广播地址</td>\n<td>不可作为源地址，可以作为目的地址</td>\n</tr>\n<tr>\n<td>网络位全0</td>\n<td>网络内，本机IP地址的主机部份</td>\n<td>可作为源地址，不可以作为目的地址</td>\n</tr>\n<tr>\n<td>主机号全0</td>\n<td>代表网络的地址</td>\n<td>不可作为源地址，不可以作为目的地址</td>\n</tr>\n<tr>\n<td>主机号全1</td>\n<td>网络内广播</td>\n<td>可作为源地址，不可以作为目的地址</td>\n</tr>\n<tr>\n<td>127.x.x.x</td>\n<td>本地软件Loopback测试</td>\n<td>可作为源地址，可以作为目的地址</td>\n</tr>\n</tbody>\n</table>\n<p>不同网段的<strong>私有IP地址</strong>：仅能内部使用</p>\n<table>\n<thead>\n<tr>\n<th>地址类别</th>\n<th>地址范围</th>\n<th>网段个数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>10.0.0.0 - 10.255.255.255</td>\n<td>1</td>\n</tr>\n<tr>\n<td>B</td>\n<td>172.16.0.0 - 172.31.255.255</td>\n<td>16</td>\n</tr>\n<tr>\n<td>C</td>\n<td>192.168.0.0 - 192.168.255.255</td>\n<td>256</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"IP子网掩码\">IP子网掩码</h3>\n<img src=\"image-20241231150034788.png\" alt=\"image-20241231150034788\" style=\"zoom:67%;\" /> \n<p><strong>子网掩码与IP地址相与，即可获得网络地址</strong></p>\n<p>例：</p>\n<p>子网掩码255.255.192.0；IP地址141.14.72.24</p>\n<p>网络地址为：141.14.64.0</p>\n<blockquote>\n<p>[!WARNING]</p>\n<p><strong>易错例题</strong></p>\n<p>主机ip为180.80.77.55；掩码255.255.252.0，发送广播分组的目的地址为</p>\n<p>1111 1100</p>\n<p>0100 1101</p>\n<p>0100 1100=76   但是广播地址要给主机号全变成1，所以是：</p>\n<p>0100 11<u><strong>11</strong></u> . 11111111</p>\n<p>结果：180.80.79.255</p>\n</blockquote>\n<h3 id=\"无分类编址CIDR\">无分类编址CIDR</h3>\n<p>消除了传统A、B、C类地址和划分子网的概念</p>\n<img src=\"image-20241231155327072.png\" alt=\"image-20241231155327072\" style=\"zoom:67%;\" />  \n<p><strong>全0：本网络；全1：广播</strong></p>\n<img src=\"image-20241231155457787.png\" alt=\"image-20241231155457787\" style=\"zoom: 67%;\" /> \n<p><strong>构成超网</strong></p>\n<img src=\"image-20241231155943052.png\" alt=\"image-20241231155943052\" style=\"zoom:67%;\" /> \n<ul>\n<li>.00100000.</li>\n<li>.00101000.</li>\n<li>.00110000.</li>\n<li>.00111000.</li>\n<li>最后构成35.230.32.0/19</li>\n</ul>\n<p><strong>最长前缀匹配</strong></p>\n<p>查路由表若有多个匹配结果，则<strong>发给有最长网络前缀</strong>的路由</p>\n<h3 id=\"ARP和ICMP协议\">ARP和ICMP协议</h3>\n<img src=\"image-20241231172034292.png\" alt=\"image-20241231172034292\" style=\"zoom: 50%;\" />  \n<h4 id=\"ARP\">ARP</h4>\n<p>在网络层，发送方只知道对方的IP地址，所以：</p>\n<p><strong>首先检查ARP缓存看有没有已经存好的地址</strong>，没有就用FF-FF-FF-FF-FF-FF发送广播ARP请求分组，收到请求的主机响应，返回MAC地址，随后发送方得到MAC地址。</p>\n<p>如果是跨交换机，发送方得到的是交换机的MAC地址。交换机会再接着发</p>\n<img src=\"image-20241231170051028.png\" alt=\"image-20241231170051028\" style=\"zoom:67%;\" />  \n<p><strong>四种典型情况：</strong></p>\n<ol>\n<li>主机A发送到本网络主机B：用ARP找到B的硬件地址</li>\n<li>主机A发送给另一网络的主机B：用ARP找到本网络的一个路由器硬件地址</li>\n<li>路由器发给本网络主机A：用ARP找到A的硬件地址</li>\n<li>路由器发送给另一网络的主机B：用ARP找到本网络的另一个路由器硬件地址</li>\n</ol>\n<p>**RARP：**很神奇喔，自己不知道自己IP地址，要通过自己的MAC地址询问服务器自己的IP是多少</p>\n<h4 id=\"DHCP\">DHCP</h4>\n<p>给主机动态分配IP，是应用层协议，用UDP</p>\n<h4 id=\"ICMP\">ICMP</h4>\n<p><strong>ICMP报文装填在IP报文数据部分</strong>，但是是<strong>网络层协议</strong></p>\n<p>为了报告差错和异常，可以用来ping、traceroute</p>\n<img src=\"image-20241231172532499.png\" alt=\"image-20241231172532499\" style=\"zoom: 67%;\" />  \n<ul>\n<li>类型</li>\n<li>代码：拓展</li>\n<li>检验和：检验首部</li>\n</ul>\n<h5 id=\"ICMP差错报文\"><strong>ICMP差错报文</strong></h5>\n<ol>\n<li>终点不可达：路由器或主机<strong>无法交付</strong>报文</li>\n<li>源点抑制：<strong>拥塞</strong>而丢弃</li>\n<li>时间超过：当路由器收到生存时间<strong>TTL=0</strong>的数据报文时，先丢弃该报文，再向远点发送时间超过报文</li>\n<li>参数问题：路由器或目的主机收到的<strong>首部字段有误</strong>，发送参数问题报文</li>\n<li>改变路由（重定向）：路由器发送该报文到主机，让主机知道下次的数据包应该发送给另外的路由器（可能是更好的路由）</li>\n</ol>\n<p><strong>差错报文的ICMP数据字段</strong></p>\n<img src=\"image-20241231173246830.png\" alt=\"image-20241231173246830\" style=\"zoom: 67%;\" />  \n<blockquote>\n<p>[!NOTE]</p>\n<p>对<strong>差错报文</strong>不再发送差错报文</p>\n<p>对第一个数据分片后的<strong>后续分片</strong>不发送ICMP差错报文</p>\n<p>对具有<strong>组播</strong>地址的数据报不发送ICMP差错报文</p>\n<p>对<strong>特殊地址</strong>（127.0.0.0或0.0.0.0）不发送ICMP差错报文</p>\n</blockquote>\n<h5 id=\"ICMP询问报文\">ICMP询问报文</h5>\n<ol>\n<li>回送请求和回答报文</li>\n<li>时间戳请求和回答报文</li>\n</ol>\n<h4 id=\"IGMP\">IGMP</h4>\n<p>提供带<u><strong>多播组</strong></u>标识的路由，让整个网络都支持多播</p>\n<p>用于管理主机与多播组的关系</p>\n<h2 id=\"路由选择协议\">路由选择协议</h2>\n<p>内部网关西医：RIP、OSPF</p>\n<p>外部网关协议：BGP</p>\n<h3 id=\"RIP协议\">RIP协议</h3>\n<p>距离：跳数。从路由器到直接相连的网络距离为1，经过一个路由器+1</p>\n<p>距离最大为16，一条路由最多只能包含15个路由器。RIP只适用于小型网络</p>\n<img src=\"image-20241231195543964.png\" alt=\"image-20241231195543964\" style=\"zoom:67%;\" /> \n<p><strong>格式</strong></p>\n<table>\n<thead>\n<tr>\n<th>网络</th>\n<th>距离</th>\n<th>下一跳</th>\n</tr>\n</thead>\n</table>\n<p>每30s和邻居交换一次路由信息，交换的信息是本路由器的全部信息。</p>\n<ol>\n<li>把地址为X的路由器中发来的RIP报文中所有项目，地址改为X，距离为报文中距离+1</li>\n<li>对修改后的RIP报文中每一个项目进行：\n<ul>\n<li>路由表没有对应Net，填入</li>\n<li>路由表有对应Net，\n<ul>\n<li>若原有下一跳是X，直接替换</li>\n<li>若原有下一跳不是X，比较距离，保留短的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>若180s没收到X发来的更新路由表信息，把X对应表项距离设置为16，意思是不可达</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>IP首部</th>\n<th>UDP首部</th>\n<th>RIP报文</th>\n</tr>\n</thead>\n</table>\n<p><strong>RIP报文在UDP的数据报中</strong>，所以RIP是应用层协议</p>\n<p><strong>一个RIP报文最多传送25个路由表项</strong>，如果表项太多需要发多个RIP报文</p>\n<p><strong>RIP中好消息传的快、坏消息传的慢</strong>，解决方案：</p>\n<ul>\n<li>水平分割：禁止把一条路由信息从收到这条路由信息的接口广播出去</li>\n<li>保持：当一个网络不可达后，一段时间内忽略其他路由发来的该网络信息</li>\n<li>触发更新：一旦网络不可达，直接广播，不等待下一个广周期到</li>\n</ul>\n<h3 id=\"OSPF协议\">OSPF协议</h3>\n<p>用了Dijkstra的最短路径SPF算法</p>\n<p>OSPF使用洪泛法，向所有服务器发送</p>\n<p>直接使用IP报文发，没有UDP包装，是网络层协议</p>\n<p>只有链路状态变化，才会发送信息</p>\n<p>OSPF不使用RIP的距离，使用“度量”metric</p>\n<p>存储全网拓扑结构图</p>\n<p>OSPF还会划分区域</p>\n<img src=\"image-20241231233656203.png\" alt=\"image-20241231233656203\" style=\"zoom:67%;\" />  \n<h3 id=\"BGP\">BGP</h3>\n<p>外部通讯协议</p>\n<p>用TCP</p>\n<p>PPT里没有</p>\n<h1>传输层</h1>\n<p>传输层功能：</p>\n<ul>\n<li>应用进程之间的逻辑通信</li>\n<li>复用和分用（复用：不同进程可用同一个协议；分用：接收方传输层剥去首部课正确交付）</li>\n<li>检错检测</li>\n<li>提供面向连接和无连接的传输协议</li>\n</ul>\n<h3 id=\"端口号\">端口号</h3>\n<p>1-65535其中：</p>\n<p>1-1024：熟知端口，用于常用应用程序，如ftp 21，smtp 25等</p>\n<p>1024-49151：注册端口</p>\n<p>49152-65535：客户端进程动态生成</p>\n<p>嵌套字Socket格式 = IP地址：端口号</p>\n<h2 id=\"UDP\">UDP</h2>\n<p><strong>无连接</strong>，<strong>不可靠</strong>（只会尽最大努力交付），简单，包头小</p>\n<p>首部简单：</p>\n<img src=\"1735711096881.png\" alt=\"1735711096881\" style=\"zoom: 67%;\" />  \n<p>UDP报文长度：头部加上数据</p>\n<p>校验部分添加伪首部校验</p>\n<p>UDP常见应用：</p>\n<ul>\n<li>DNS域名服务</li>\n<li>SNMP简单网络协议</li>\n<li>RIP路由信息协议</li>\n<li>P2P点对点通信</li>\n</ul>\n<h2 id=\"TCP\">TCP</h2>\n<p><strong>面向连接，可靠</strong>有序，不丢失不重复</p>\n<p>全双工通信，面向字节流</p>\n<h3 id=\"TCP报文头部\">TCP报文头部</h3>\n<img src=\"image-20250101144607767.png\" alt=\"image-20250101144607767\" style=\"zoom: 67%;\" />  \n<ul>\n<li>每个<strong>端口</strong>占16位（1-65535）</li>\n<li><strong>序号</strong>：表示本报文发送的数据第一个<strong>字节</strong>的序号，注意是字节的序号</li>\n<li><strong>确认号</strong>：期望收到的下一个报文的第一个数据<strong>字节</strong>的序号。若为N，则说明N-1位置的数据都已经收到</li>\n<li>数据偏移：就是首部长度，<strong>单位是4字节</strong></li>\n<li>保留字段：全为0</li>\n<li><strong>6个控制位</strong>：\n<ul>\n<li><strong>URG紧急位</strong>：置为1时，说明是紧急文件，要尽快发送【发送方紧急】</li>\n<li><strong>ACK确认位</strong>：=1确认号有效，建立连接后应该一直为1</li>\n<li>PSH推送位：=1时接收方应尽快接受并交付【接收方紧急】（不考）</li>\n<li>RST复位：=1表明连接严重差错，要释放连接（不考）</li>\n<li><strong>SYN同步位</strong>：=1时表明这是一个连接请求/接受报文</li>\n<li><strong>FIN终止位</strong>：=1时表明发送方数据已经发完，要求释放连接</li>\n</ul>\n</li>\n<li><strong>窗口</strong>：<strong>发送方的接收窗口</strong>，即发送放现在允许对方发送的数据量，单位1字节</li>\n<li>校验和：检验首部+数据，要加上12B伪首部（其中伪首部第四个字段为6）<img src=\"image-20250101202339846.png\" alt=\"image-20250101202339846\" style=\"zoom:67%;\" /> <strong>伪首部长这样</strong></li>\n<li>紧急指针：URG=1时有意义，本报文段紧急数据的字节数</li>\n<li>选项：长度可变，可以有最大报文长度、窗口扩大、时间戳等</li>\n<li>填充：使得首部是4字节（32位）的整数倍</li>\n</ul>\n<h3 id=\"TCP连接管理\">TCP连接管理</h3>\n<p>连接建立→数据传送→连接释放</p>\n<h4 id=\"TCP连接建立（三次握手协议）\">TCP连接建立（三次握手协议）</h4>\n<img src=\"image-20250101151837970.png\" alt=\"image-20250101151837970\" style=\"zoom:67%;\" /> \n<ol>\n<li>客户端发送连接请求【<strong>同步位</strong>SYN=1，初始<strong>序号</strong>seq=x（随机）】，无应用层数据，客户端进入SYN-SENT（同步已发送）状态</li>\n<li>服务器若同意，返回确认报文段【<strong>同步位</strong>SYN=1，<strong>确认位</strong>ACK=1，<strong>序号</strong>seq=y（随机），<strong>确认号</strong>ack=x+1】，无应用层数据，服务器进入SYN-RCVD（同步收到）状态</li>\n<li>客户端返回确认的确认【<strong>同步位</strong>SYN=0，<strong>确认位</strong>ACK=1，<strong>序号</strong>seq=x+1，<strong>确认号</strong>ack=y+1】，客户端为TCP分配缓存和变量，<strong>可携带应用层数据</strong></li>\n</ol>\n<h4 id=\"TCP连接释放（四次握手）\">TCP连接释放（四次握手）</h4>\n<img src=\"image-20250101152842674.png\" alt=\"image-20250101152842674\" style=\"zoom:67%;\" /> \n<ol>\n<li><strong>客户端</strong>发送连接释放报文【<strong>终止位</strong>FIN=1，<strong>序号</strong>seq=u（等于前面的序号+1）】，进入FIN-WAIT-1状态</li>\n<li><strong>服务器</strong>返回确认报文段【<strong>确认位</strong>ACK=1，序号seq=v，<strong>确认号</strong>ack=u+1】，服务器进入<strong>CLOSE-WAIT（半关闭状态）</strong>，这个时候<strong>服务器还能向客户端发送数据</strong></li>\n<li><strong>服务器</strong>发完数据，发出连接释放报文【<strong>终止位</strong>FIN=1，<strong>确认位</strong>ACK=1，<strong>序号</strong>seq=w，<strong>确认号</strong>ack=u+1】，进入LAST-ACK（最后确认）状态</li>\n<li><strong>客户端</strong>返回确认报文段【<strong>确认位</strong>ACK=1，<strong>序号</strong>seq=u+1，<strong>确认号</strong>ack=w+1】，客户端等待2 * MSL（最长报文段寿命）的时间后，彻底关闭</li>\n</ol>\n<h3 id=\"TCP可靠传输\">TCP可靠传输</h3>\n<p>网络层不可靠</p>\n<p>传输层TCP实现可靠传输</p>\n<p><strong>序号</strong></p>\n<p>每个字节都有一个序号</p>\n<p>序号字段是第一个字节的序号</p>\n<p><strong>确认</strong></p>\n<p>发送方发完了数据先放进缓存，直到确认了再删</p>\n<p><strong>重传</strong></p>\n<ul>\n<li>**超时重传：**TCP采用一种自适应算法，记录一个报文段发出的时间和确认的时间，时间差为RTT（往返时间），TCP会维护一个加权平均往返时间RTTS，随着样本值变化而变化。超时重传时间略大于RTTs</li>\n<li>**冗余ACK：**每当比期望序号打的失序报文段到达，发送一个冗余ACK，指明期待收到的下一个序号，发送方收到了这个ACK后立刻重传不用等超时</li>\n</ul>\n<h3 id=\"TCP流量控制\">TCP流量控制</h3>\n<p>哦又是<u>熟悉</u>的协议！</p>\n<p><strong>停止等待协议</strong></p>\n<img src=\"image-20241229152854873.png\" alt=\"image-20241229152854873\" style=\"zoom:67%;\" /> \n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>信道利用率</mtext><mi>U</mi><mo>=</mo><mfrac><msub><mi>T</mi><mi>D</mi></msub><mrow><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">信道利用率U=\\frac{T_D}{T_D+RTT+T_A}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">信</span><span class=\"mord cjk_fallback\">道</span><span class=\"mord cjk_fallback\">利</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">率</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.19633em;vertical-align:-0.8360000000000001em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.3139999999999996em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">A</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.02778em;\">D</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8360000000000001em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></p>\n<p><strong>流水线传输</strong></p>\n<p>这不是我们滑动窗口吗</p>\n<img src=\"image-20250101171246593.png\" alt=\"image-20250101171246593\" style=\"zoom: 50%;\" /> \n<p>以<strong>字节为单位</strong>的滑动窗口</p>\n<ol>\n<li>根据接收方给出的窗口值，构造自己的发送窗口</li>\n<li>发送数据</li>\n<li>收到确认前移</li>\n</ol>\n<p>发送窗口并不总是和接收窗口一样大（因为时间滞后）</p>\n<p><u><strong>发送窗口取接受窗口和拥塞窗口的最小值</strong></u></p>\n<p><strong>发送缓存</strong>用于暂时存放准备发的发送数据和TCP发出但没确认的数据</p>\n<p><strong>接收缓存</strong>用于存没按序到达的数据和被接受但没被应用读取的数据</p>\n<img src=\"image-20250101173640333.png\" alt=\"image-20250101173640333\" style=\"zoom:67%;\" /> \n<p>报文中窗口参数 rwnd 单位字节</p>\n<p>TCP有一个计时器，如果收到rwnd=0后，会启动计时器，一段时间后发送零窗口探测报文段，对方会再次给出当前窗口值</p>\n<h3 id=\"TCP拥塞控制\">TCP拥塞控制</h3>\n<blockquote>\n<p>[!NOTE]</p>\n<p>重要喔</p>\n</blockquote>\n<p>未按时收到确认就判定为拥塞</p>\n<p>拥塞控制控制多个发送方，流量控制控制单个发送方</p>\n<p><strong>发送窗口</strong>取接收窗口rwnd和拥塞窗口cwnd<strong>较小</strong>的一个</p>\n<h4 id=\"慢开始和拥塞避免\">慢开始和拥塞避免</h4>\n<p><strong>慢开始：</strong></p>\n<p>先预设一个ssthresh值</p>\n<p>发送方A先令cwnd=1，发一个，收到B的确认后cwnd乘以2变成2；再收到变成4</p>\n<p>cwnd<strong>指数增长</strong>，直到cwnd &gt;= ssthresh 即慢开始门限改为使用 阻塞避免算法</p>\n<p>*<u>注意：</u>*如果乘以2大于ssthresh，那么只能取ssthresh，不能指数增大超过门限</p>\n<p><strong>阻塞避免算法：</strong></p>\n<p>每收到1条确认，cwnd只+1，线性增长</p>\n<p><strong>遇到网络拥塞：</strong></p>\n<p>把ssthresh设置为拥塞时cwnd值的<strong>一半</strong>，然后让cwnd=1重新慢开始</p>\n<img src=\"image-20250101200956320.png\" alt=\"image-20250101200956320\" style=\"zoom: 67%;\" />  \n<h4 id=\"快重传和快恢复\">快重传和快恢复</h4>\n<img src=\"image-20250101201343117.png\" alt=\"image-20250101201343117\" style=\"zoom:67%;\" /> \n<p>为了尽早重传：</p>\n<p>如果连续收到三个重复的冗余ACK确认，立即重传相应的报文段</p>\n<p>ssthresh调整为当前cwnd的一半，这个时候<strong>不会慢开始</strong>，采用快恢复</p>\n<p><strong>快恢复：</strong></p>\n<p>直接把cwnd设置为当前cwnd的一半，跳过慢开始阶段，直接开始拥塞避免加法增大</p>\n<h1>应用层</h1>\n<h2 id=\"应用模型\">应用模型</h2>\n<p><strong>C/S模型</strong></p>\n<p>服务器永久提供服务，永久性访问地址/域名</p>\n<p>服务器处于接受请求状态，收到客户机请求后处理，发送结果</p>\n<p>客户机之间不通信</p>\n<p>可扩展性不佳</p>\n<p><strong>P2P模型</strong></p>\n<p>莫得服务器，全是客户机，都可以请求服务，都可以提供服务</p>\n<p>任意两点都可以直接通讯，节点可能改变IP地址</p>\n<p>可扩展性好</p>\n<p>网络健壮性强，失去一个节点也不会网络失效</p>\n<h2 id=\"域名解析DNS系统\">域名解析DNS系统</h2>\n<p>使用UDP</p>\n<p><a href=\"http://www.baidu.com\">www.baidu.com</a></p>\n<p><strong>顶级域名：</strong></p>\n<p>国家顶级域名：cn、us、jp</p>\n<p>通用顶级域名：com、net、org…</p>\n<p><strong>二级域名：</strong></p>\n<p>上述例子中的baidu</p>\n<img src=\"image-20250101211437736.png\" alt=\"image-20250101211437736\" style=\"zoom: 67%;\" /> \n<p>根域名服务器：知道所有顶级域名服务器的IP地址</p>\n<p>顶级域名服务器：一个顶级域名有很多顶级域名服务器，可以获取顶级域名下属二级域名</p>\n<p>权限域名服务器：负责一个区的域名服务器</p>\n<p>本地域名服务器：发送DNS请求的时候会先查询本地域名服务器</p>\n<ol>\n<li>主机向本地域名服务器查询</li>\n<li>本地域名服务器向根域名服务器查询，得到顶级域名服务器地址</li>\n<li>本地域名服务器向顶级域名服务器查询，得到权限域名服务器地址</li>\n<li>本地域名服务器向权限域名服务器查询，得到最终要访问的IP地址</li>\n<li>本地域名保存IP地址，返回给主机</li>\n</ol>\n<h2 id=\"FTP文件传送协议\">FTP文件传送协议</h2>\n<p>适用于不同操作系统中传输</p>\n<p>使用C/S协议模式</p>\n<p><strong>使用TCP</strong>实现可靠传输</p>\n<ol>\n<li>ftp服务器启动</li>\n<li>客户端登录ftp服务器，输入用户名密码或者匿名登陆</li>\n<li>服务器启动一个新的从属进程【包含控制进程和数据传输进程】\n<ul>\n<li>21号端口控制连接：控制发不发、终止等</li>\n<li>20号端口数据连接：传文件的\n<ul>\n<li>主动模式：连接后客户端随机开一个端口，服务器通过端口20连接客户端【默认主动】</li>\n<li>被动模式：连接后服务器随机开一个端口，客户端连接到服务器端口</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>开始传输</li>\n</ol>\n<h2 id=\"电子邮件\">电子邮件</h2>\n<img src=\"image-20250101221119568.png\" alt=\"image-20250101221119568\" style=\"zoom:67%;\" /> \n<p><strong>使用TCP</strong></p>\n<p>STMP推送邮件到服务器</p>\n<p>POP3或IMAP从服务器拉取邮件</p>\n<p><strong>STMP步骤：</strong></p>\n<ol>\n<li>发送方发到发邮件服务器</li>\n<li>发邮件服务器与接收方建立TCP连接</li>\n<li>发邮件服务器问STMP服务器是否有收件人</li>\n<li>传输邮件</li>\n<li>释放连接</li>\n</ol>\n<p>SMTP只能发ASCII码，所以要使用MIME来把非ASCII码转化为7位ASCII码</p>\n<p>**POP3或者IMAP协议：**收取邮件</p>\n<h2 id=\"HTTP协议和www\">HTTP协议和www.</h2>\n<p><strong>URL形式</strong></p>\n<p>协议://主机:端口/路径</p>\n<p>http协议是超文本传输协议，语言HTML</p>\n<p>HTTP采用 <strong><u>TCP</u></strong> 为传输层协议，但<strong>HTTP协议本身是无连接的</strong></p>\n<p><strong>非持久连接：</strong></p>\n<img src=\"image-20250101225428059.png\" alt=\"image-20250101225428059\" style=\"zoom:67%;\" />  \n<p><strong>持久连接：</strong></p>\n<img src=\"image-20250101225402193.png\" alt=\"image-20250101225402193\" style=\"zoom:67%;\" /> \n<p>HTTP请求报文面向文本，所以报文中每一个字段都是ASCII码串</p>\n<ol>\n<li>浏览器分析URL</li>\n<li>浏览器向DNS请求解析IP地址</li>\n<li>获得IP地址</li>\n<li>浏览器与服务器建立TCP连接</li>\n<li>浏览器发出取文件命令GET /index.htm</li>\n<li>服务器给出响应发文件</li>\n<li>TCP连接释放</li>\n<li>浏览器显示</li>\n</ol>\n<p><strong>请求报文</strong></p>\n<img src=\"image-20250101225839920.png\" alt=\"image-20250101225839920\" style=\"zoom: 67%;\" /> \n<p><strong>响应报文</strong></p>\n<img src=\"image-20250101225853337.png\" alt=\"image-20250101225853337\" style=\"zoom:67%;\" /> \n<p>1xx表示通知信息</p>\n<p>2xx表示成功（如200、202）</p>\n<p>3xx表示重定向（如301）</p>\n<p>4xx表示客户差错（如404）</p>\n<p>5xx表示服务器差错</p>\n<h1>完结撒花</h1>\n<img src=\"我要成为高手.png\" alt=\"我要成为高手\"  />",
            "tags": [
                "大学",
                "总结",
                "计网"
            ]
        },
        {
            "id": "https://blog.unfinished.top/2024/12/19/Compiler/",
            "url": "https://blog.unfinished.top/2024/12/19/Compiler/",
            "title": "【2024北航编译器】使用Java实现的C语言子集SysY-MIPS编译器",
            "date_published": "2024-12-19T10:21:31.000Z",
            "content_html": "<h1>编译器设计文档</h1>\n<img src=\"Compiler.png\" alt=\"我要成为编译高手\" style=\"zoom: 25%;\" />  \n<h2 id=\"编译器总体设计\">编译器总体设计</h2>\n<h3 id=\"结构\">结构</h3>\n<p>Block模块：创建语法模块，模块作为语法树节点</p>\n<p>Token模块：创建token</p>\n<p>Symbol模块：为语义分析创建符号和符号表</p>\n<p>Error模块：负责处理错误，打印错误</p>\n<p>Frontend模块：负责词法分析和语法分析，包含<code>Lexer</code>、<code>Parser</code>和<code>Visitor</code></p>\n<p>Middle模块：负责生成中间代码LLVM，存储了LLVM的数据结构</p>\n<p>Backend模块：负责将LLVM结构翻译成mips并最终输出。</p>\n<p>Tool模块：负责文件输入输出等杂项</p>\n<p>Compiler：作为主程序入口，启动后自动调用前后端接口等进行词法分析、语法分析、语义分析、LLVM代码生成。</p>\n<h3 id=\"接口设计\">接口设计</h3>\n<h4 id=\"前端接口\">前端接口</h4>\n<ul>\n<li>\n<p>预处理：</p>\n<ul>\n<li>输入文件</li>\n<li>读取后将所有换行（如\\r\\n）统一换成\\n</li>\n<li>输出字符串</li>\n</ul>\n</li>\n<li>\n<p><code>Lexer</code></p>\n<ul>\n<li>输入字符串</li>\n<li>读取字符串，经过判断和操作，生成token，判断是否有词法错误</li>\n<li>输出token串、若出错输出错误</li>\n</ul>\n</li>\n<li>\n<p>Parser：</p>\n<ul>\n<li>输入token串</li>\n<li>把token串分析后，经过一系列判断生成语法树，判断是否有语法错误</li>\n<li>输出语法树、若出错输出错误</li>\n</ul>\n</li>\n<li>\n<p>Visitor：</p>\n<ul>\n<li>输入语法树根节点CompUnitBlock</li>\n<li>从CompUnitBlock开始分析整个语法树，并建立符号表，判断是否有语义错误</li>\n<li>输出符号表、若出错输出错误</li>\n</ul>\n</li>\n<li>\n<p>IrBuilder:</p>\n<ul>\n<li>输入语法树根节点CompUnitBlock</li>\n<li>从CompUnitBlock开始分析整个语法树，将语法树转换为LLVM，并存储在IrModule中。其中为了分析也会建立符号表。将语法翻译为LLVMValue</li>\n<li>输出IrModule，并打印到文件</li>\n</ul>\n</li>\n<li>\n<p>MipsBuilder：</p>\n<ul>\n<li>输入LLVM根节点IrModule</li>\n<li>将LLVM语言翻译成mips语言，其中利用Reg记录寄存器</li>\n<li>输出String，内容为mips代码，并将mips打印到文件</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"错误接口\">错误接口</h4>\n<ul>\n<li><code>ErrorHandler</code>\n<ul>\n<li>输入错误的位置和类型</li>\n<li>输出到错误文件中</li>\n<li>错误处理在后面词法、语法和语义分析中详细说明</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文件组织\">文件组织</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiler</span><br><span class=\"line\">│</span><br><span class=\"line\">└── src</span><br><span class=\"line\">\t├── Block</span><br><span class=\"line\">\t│\t├── AddExpBlock.java</span><br><span class=\"line\">\t│\t├── ...</span><br><span class=\"line\">\t│\t├── ...</span><br><span class=\"line\">\t│\t├── VarDeclBlock.java</span><br><span class=\"line\">\t│\t└── VarDefBlock.java</span><br><span class=\"line\">\t│</span><br><span class=\"line\">\t├── Backend</span><br><span class=\"line\">\t│\t├── MipsBuilder.java</span><br><span class=\"line\">\t│\t├── Reg.java</span><br><span class=\"line\">\t│\t└── Translator.java</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\t├── Error</span><br><span class=\"line\">\t│\t├── Err.java</span><br><span class=\"line\">\t│\t├── ErrType.java</span><br><span class=\"line\">\t│\t└── ErrorHandler.java</span><br><span class=\"line\">\t│</span><br><span class=\"line\">\t├── Frontend</span><br><span class=\"line\">\t│\t├── Lexer.java</span><br><span class=\"line\">\t│\t├── Parser.java</span><br><span class=\"line\">\t│\t└── Visitor.java</span><br><span class=\"line\">\t│</span><br><span class=\"line\">\t├── Middle</span><br><span class=\"line\">\t│\t├── Types</span><br><span class=\"line\">\t|\t|\t├── ArrayType.java</span><br><span class=\"line\">\t|\t|\t├── FunctionType.java</span><br><span class=\"line\">\t|\t|\t├── IntegerType.java</span><br><span class=\"line\">\t|\t|\t├── LabelType.java</span><br><span class=\"line\">\t|\t|\t├── PointerType.java</span><br><span class=\"line\">\t|\t|\t├── VoidType.java</span><br><span class=\"line\">\t|\t|\t└── Type.java</span><br><span class=\"line\">\t|\t|</span><br><span class=\"line\">\t│\t├── Values</span><br><span class=\"line\">\t|\t|\t├── Instructions</span><br><span class=\"line\">\t|\t|\t|\t├──\tMem</span><br><span class=\"line\">\t|\t|\t|\t|\t├──\tAllovaInst</span><br><span class=\"line\">\t|\t|\t|\t|\t├──\tGEPInst</span><br><span class=\"line\">\t|\t|\t|\t|\t├──\tLoadInst</span><br><span class=\"line\">\t|\t|\t|\t|\t├──\tMemInst</span><br><span class=\"line\">\t|\t|\t|\t|\t└──\tStoreInst</span><br><span class=\"line\">\t|\t|\t|\t|</span><br><span class=\"line\">\t|\t|\t|\t├──\tTerminator</span><br><span class=\"line\">\t|\t|\t|\t|\t├──\tBrInst</span><br><span class=\"line\">\t|\t|\t|\t|\t├──\tCallInst</span><br><span class=\"line\">\t|\t|\t|\t|\t├──\tRetInst</span><br><span class=\"line\">\t|\t|\t|\t|\t└──\tTerminatorInst</span><br><span class=\"line\">\t|\t|\t|\t|</span><br><span class=\"line\">\t|\t|\t|\t├──\tBinaryInst</span><br><span class=\"line\">\t|\t|\t|\t├──\tConvInst</span><br><span class=\"line\">\t|\t|\t|\t├──\tInstruction</span><br><span class=\"line\">\t|\t|\t|\t└── Operator</span><br><span class=\"line\">\t|\t|\t|</span><br><span class=\"line\">\t|\t|\t├── BuildFactory.java</span><br><span class=\"line\">\t|\t|\t├── BasicBlock.java</span><br><span class=\"line\">\t|\t|\t├── Const.java</span><br><span class=\"line\">\t|\t|\t├── ConstArray.java</span><br><span class=\"line\">\t|\t|\t├── ConstInt.java</span><br><span class=\"line\">\t|\t|\t├── Function.java</span><br><span class=\"line\">\t|\t|\t├── GlobalVar.java</span><br><span class=\"line\">\t|\t|\t├── IdBuilder.java</span><br><span class=\"line\">\t|\t|\t├── NullValue.java</span><br><span class=\"line\">\t|\t|\t├── Use.java</span><br><span class=\"line\">\t|\t|\t├── User.java</span><br><span class=\"line\">\t|\t|\t└── Value.java</span><br><span class=\"line\">\t|\t|</span><br><span class=\"line\">\t|\t├── IrModule</span><br><span class=\"line\">\t│\t└── IrBuilder</span><br><span class=\"line\">\t|</span><br><span class=\"line\">\t├── Symbol</span><br><span class=\"line\">\t│\t├── BTpye.java</span><br><span class=\"line\">\t│\t├── Symbol.java</span><br><span class=\"line\">\t|\t├── SymbolTable.java</span><br><span class=\"line\">\t│\t└── SymbolTableList.java</span><br><span class=\"line\">\t│</span><br><span class=\"line\">\t├── Token</span><br><span class=\"line\">\t│\t├── Token.java</span><br><span class=\"line\">\t│\t└── TokenType.java</span><br><span class=\"line\">\t│</span><br><span class=\"line\">\t├── Tool</span><br><span class=\"line\">\t│\t└── FileControler.java</span><br><span class=\"line\">\t│</span><br><span class=\"line\">\t└── Compiler.java</span><br></pre></td></tr></table></figure>\n<h2 id=\"词法分析设计\">词法分析设计</h2>\n<h3 id=\"Token设计\">Token设计</h3>\n<p>Token单元将会记录下面内容：</p>\n<ul>\n<li>类型：<code>TokenType</code></li>\n<li>具体内容：String</li>\n<li>所在文件行数：Integer</li>\n</ul>\n<p><code>TokenType</code>是一个枚举类，包含了所有类型的Token名称，如IDENFR、INTCON、STRCON等</p>\n<h3 id=\"分析程序设计\">分析程序设计</h3>\n<p>使用now记录当前所在字符串位置，<code>lineNum</code>记录行号。</p>\n<p>每当读取到\\n，行数+1</p>\n<p>自动机会判断读取的字符，分别进入</p>\n<ul>\n<li>单词分析：读取一个完整的以字母开头可包含数字的词汇，并判断是否是保留字，输出Token</li>\n<li>数字分析：读取一个整数。</li>\n<li>注释分析：综合判断是注释还是乘除法，如果是注释则中间内容全部不记录，乘除法会输出Token</li>\n<li>符号分析：综合分析各种单双符号，输出Token</li>\n</ul>\n<h3 id=\"错误处理\">错误处理</h3>\n<p>如果遇到<code>&amp;</code>或者<code>|</code>以单字符形式出现，则调用错误处理器，输出所在行号，错误类型为：<strong>a</strong></p>\n<h2 id=\"语法分析设计\">语法分析设计</h2>\n<h3 id=\"Block设计\">Block设计</h3>\n<p>Block是语法树的基本组成单元。</p>\n<p>Block根据编译文法所撰写，包含从<code>AddExp</code>到<code>VarDefBlock</code> 总共35个语法单元</p>\n<p>每个Block中记录的数据各不相同，</p>\n<p>都拥有构造方法用于记录数据，</p>\n<p>还拥有一个print方法，用于根据记录的数据，打印语法树到文件，并递归调用子模块。</p>\n<h3 id=\"分析程序设计-2\">分析程序设计</h3>\n<p>分析程序会接受到词法分析中产生的<code>tokenList</code>进行语法分析。</p>\n<p>语法分析根据文法总共有从 <code>ComplieUnit</code> 到 <code>ConstExp</code> 34个分析单元，</p>\n<p>语法分析将会从<code>CompUnit</code>开始分析，每个分析单元都会根据自身文法，递归调用子分析单元。</p>\n<p>当出现需要分析的单元为<code>Token</code>时候，调用<code>getToken</code>方法。</p>\n<p><code>getToken</code>会根据文法对应位置的token类型，判断是否有误，有误则输出错误，没有则输出Token。</p>\n<p>分析完毕后，会得到一颗以<code>CompileUnitBlock</code>为根的语法树，Parser会输出这个语法树给Compiler主程序，打印到对应文件，并给后续进一步操作。</p>\n<h3 id=\"错误处理-2\">错误处理</h3>\n<p><code>public Token getToken(TokenType tokenType)</code>：</p>\n<p>在该方法中，会自动处理错误，如果<code>tokenType</code>是语法期望的token类型，如果与当前对应token的类型相同则没有问题，正常输出；如果不同，说明缺失了对应符号，根据缺失的符号类型，返回对应错误：</p>\n<ul>\n<li>缺失<code>;</code>错误类型为 <strong>i</strong></li>\n<li>缺失<code>)</code>错误类型为 <strong>j</strong></li>\n<li>缺失<code>]</code>错误类型为 <strong>k</strong></li>\n</ul>\n<h2 id=\"语义分析设计\">语义分析设计</h2>\n<h3 id=\"符号表结构\">符号表结构</h3>\n<p>为了放置符号，设计了符号表SymbolTable</p>\n<p>其中Symbol作为符号，记录单个符号，可以通过</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"variable\">tableId</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//记录符号位置</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> isFunc;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> dimension;</span><br><span class=\"line\"><span class=\"keyword\">public</span> BType bType;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> isConst;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//为了记录函数中的参数，还需要</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> List&lt;Symbol&gt; funcParams = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<p>四个值来定义符号类型。</p>\n<p>SymbolTable类作为一层的符号表，用以存储当前层下的所有符号。符号表将会按照顺序存储在LinkedHashMap中，其中键是Token，值是Symbol。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> id; <span class=\"comment\">//符号表id</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> fatherId;  <span class=\"comment\">//符号表父层id</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> LinkedHashMap&lt;String,Symbol&gt; directory = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;(); <span class=\"comment\">//存储符号</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">boolean</span> isFunc;<span class=\"comment\">//是否是因为函数声明而建立的一层符号表</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> BType bType;<span class=\"comment\">//如果是因为函数声明而建立的一层符号表，记录函数返回类型</span></span><br><span class=\"line\"><span class=\"comment\">//虽然函数声明的符号也会被上一层符号表记录，但是这样重复记录在此处可以方便后续分析程序调用。</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"语义分析程序\">语义分析程序</h3>\n<p>语义分析程序使用<code>List&lt;SymbolTable&gt;</code>用于存储符号表，其中程序的每一层都是一张符号表。</p>\n<p>变量tableId用于记录当前位于的符号表。</p>\n<p>当分析程序运行到新的一层时，会调用addSymbolTable，新建一层符号表，并将刚才的符号表Id作为父层记录，随后更新Id为当前List总表数量+1。</p>\n<p>当分析程序退出一层时，调用removeSymbolTable，此方法并不会删除符号表，而是将tableId改为当前符号表的父层Id。</p>\n<p>这样经过分析后，可以按照顺序输出符号表的内容。</p>\n<p>分析会从语义分析中得到的compUnit开始按照树状分析，当运行至需要修改符号表内容时，修改符号表。</p>\n<h3 id=\"错误处理-3\">错误处理</h3>\n<p>错误处理是语义分析的关键。</p>\n<ul>\n<li>\n<p>b-名字重定义</p>\n<ul>\n<li>在所有def处进行判断，从当前符号表向父级递归查询是否有重复定义</li>\n</ul>\n</li>\n<li>\n<p>c-未定义的名字</p>\n<ul>\n<li>在非定义语句出现Ident时，需要从当前符号表向父级递归查询是否有定义</li>\n</ul>\n</li>\n<li>\n<p>d-函数参数个数不匹配</p>\n<ul>\n<li><code>Ident '(' [FuncRParams] ')'</code>文法中，查询ident对应函数的变量个数，与<code>FuncRParams</code>中变量个数对比</li>\n</ul>\n</li>\n<li>\n<p>e-函数参数类型不匹配</p>\n<ul>\n<li><code>Ident '(' [FuncRParams] ')'</code>文法中，查询ident对应函数的变量类型，与<code>FuncRParams</code>中变量类型对比</li>\n</ul>\n</li>\n<li>\n<p>f-无返回值的函数存在不匹配的return语句</p>\n<ul>\n<li>在Stmt语句的return类型中，从当前符号表向父级递归查询距离自身最近的一层函数位置，判断该函数类型。如果是void且return语句后跟了exp，则报错</li>\n</ul>\n</li>\n<li>\n<p>g-有返回值的函数缺少return语句</p>\n<ul>\n<li>在Block文法中，判断Block末尾最后一个BlockItem是否是Stmt中的return类型</li>\n</ul>\n</li>\n<li>\n<p>h-不能改变常量的值</p>\n<ul>\n<li>出现形如<code>LVal '=' Exp</code>的语句时，判断<code>Lval</code>是否时常量，如果是常量则有误</li>\n</ul>\n</li>\n<li>\n<p>l-printf中格式字符与表达式个数不匹配</p>\n<ul>\n<li>根据%d、%c来判断格式字符与<code>expBlockList</code>表达式个数是否相等</li>\n</ul>\n</li>\n<li>\n<p>m-在非循环块中使用break和continue语句</p>\n<ul>\n<li>为语义分析程序设置一个全局变量int类型的forLoop，用于记录当前在几层循环之下。当进入for语句，将forLoop+1，当运行完For语句中Stmt的分析后将forLoop-1。在Stmt语句出现Continue或Break后，如果forLoop==0，则说明有误。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"语义分析难点\">语义分析难点</h3>\n<p>在语义分析的错误处理中<code>d-函数参数个数不匹配</code>和<code>e-函数参数类型不匹配</code>两种类型的错误分析最为复杂。</p>\n<p>当函数运行到<code>Ident '(' [FuncRParams] ')'</code>文法时，先从符号表里获取ident对应的符号，如果不是函数，则报错，类型为e。</p>\n<p>随后判断<code>symbol.funcParams</code>与<code>FuncRParams</code>中变量个数是否都为空或者相同，否则报错，类型为d。</p>\n<p>分析程序通过<code>getFuncParamInExp</code>方法，寻找<code>FuncRParams.ExpBlock</code>中的变量，并记录其在符号表中的对应Symbol。</p>\n<p>最后依次对比 函数符号Ident中的变量类型与 <code>FuncRParams</code>中对应的变量类型是否一致，判断是否有e类型错误。</p>\n<h2 id=\"中间代码生成设计\">中间代码生成设计</h2>\n<h3 id=\"数据结构\">数据结构</h3>\n<p>LLVM中，一切皆为Value，数据结构中的各种组件都继承自Value。</p>\n<p>其中Const继承自Value，继承了Const的ConstArray和ConstInt负责存储变量的值</p>\n<p>GlobalVar负责存储全局变量，局部变量只会通过AllocaInst表示</p>\n<p>Type负责记录变量的类型，</p>\n<p>Function负责记录函数，每一个Function中含有若干BasicBlock，每一BasicBlock含有若干Instruction。</p>\n<p>BasicBlock是函数中的基本块，记录了自己的父块和自己包含的指令集合</p>\n<p>Instruction记录基本块中的一条指令，Instruction继承自User。User包含了变量operandList，用于存储指令中使用的Value。Instruction则记录自己位于的基本块以及此指令的操作符。</p>\n<h3 id=\"Type设计\">Type设计</h3>\n<p>IntergerType包含i1、i8和i32，表明自身是bool型、char型还是32位int型。</p>\n<p>ArrayType作为数组类型，会记录自身的IntergerType，以及数组长度。</p>\n<p>FunctionType是函数类型，记录返回值的类型、每个参数的类型。</p>\n<p>PointerType是指针类型，记录该指针指向的类型targetType。</p>\n<p>LabelType是给BasicBlock使用的，用于标识基本块跳转的标签。</p>\n<p>VoidType是空值，仅标明自身是void类型</p>\n<h3 id=\"Value设计\">Value设计</h3>\n<p>Value作为LLVM数据结构的根基，包含了下面变量：</p>\n<p>name：记录value的名字，部分value比如instruction是没有名字的</p>\n<p>type：记录变量的类型</p>\n<p>REG_NUM：记录在当前函数中这条Value的寄存器编号</p>\n<p>id： Value对应的编号，每个Value的编号都不相同。作为Value的标识</p>\n<p>Value含有方法GetNameId，用于获取唯一编号，可以作为标识记录。</p>\n<h4 id=\"Const设计\">Const设计</h4>\n<p>Const继承自Value，并作为ConstInt和ConstArray的主类。其中ConstInt负责记录变量中的数值，比如在非数组型的GlobalVar中，会有一个ConstInt记录数值。ConstInt只记录数值，不会记录类型，所以char型的会转化成对应ascii编码。比如’a’会被以97记录。</p>\n<p>ConstArray记录一个数组变量的值。ConstArray中包含了一个记录ConstInt的List，并记录了该Array的类型。在声明变量时，初始值若全为0，ConstArray会调用zeroinitializer，当该Array是i8类型，则会以字符串的形式声明。</p>\n<h4 id=\"GlobalVar设计\">GlobalVar设计</h4>\n<p>GlobalVar是全局变量。包含了一个布尔值用于记录自身是否是常量，并含有一个value，记录自身的数值。GlobalVar本身的Type是一个指针类型，指向对应的Integer或者Array。GlobalVar只会在Function外声明。</p>\n<h4 id=\"Function设计\">Function设计</h4>\n<p>function将会记录自身的所有basicBlock，自身的所有参数、以及记录自己是否是库函数。function在创建时，会自动将REG_NUMBER清零，重新在函数中记录新的reg。</p>\n<h4 id=\"BasicBlock设计\">BasicBlock设计</h4>\n<p>basicBlock作为函数中的基本块，包含一个变量，记录自身的parentFunction，还包含一个LinkedList记录instruction列表。</p>\n<h3 id=\"Instruction设计\">Instruction设计</h3>\n<p>instruction时基本块中的一条指令。Instruction继承自User，所以会包含一个列表，用于记录自身使用的所有Value。作为指令，将会记录指令自身的类型Operator，还会记录自己位于的基本块parentBlock。</p>\n<p>指令包含如下</p>\n<ul>\n<li>Alloca，用于在函数内建立局部变量</li>\n<li>GetElementPointer，用于获取数组中某个值</li>\n<li>LoadInst，用于获取全局变量对应的指针</li>\n<li>StoreInst，用于将临时寄存器存入全局变量</li>\n<li>BrInst，用于跳转到对应BasicBlock</li>\n<li>CallInst，用于调用函数，向函数传参。</li>\n<li>RetInst，作为函数的返回语句，返回空值void或一个IntergerType。</li>\n<li>BinaryInst，包含如加减乘除等运算的三元式，也包含icmp三元式用于关系运算。</li>\n<li>ConvInst，包含Zext和Trunc，其中Zext用于数位扩展，将会把i1和i8扩展为i32，Trunc用于数位截断，将会把i32截断为i8</li>\n</ul>\n<h3 id=\"工厂模式设计\">工厂模式设计</h3>\n<p>由于此次任务中Value的种类非常多，如果将Value的建立不做封装，将会让代码变得非常冗余，所欲使用一个BuildFactory用于构造不同种类的Value，并进行一些基本的处理</p>\n<h3 id=\"中间代码生成程序\">中间代码生成程序</h3>\n<p>在中间代码生成程序中，将会根据语法树进行进行遍历。IrBuilder中含有一个新的SymbolTableList，用于记录Value的符号表，在建立全局变量和局部变量时，将Value作为符号加入符号表中，方便后续使用。</p>\n<p>每当创建一个新的BasicBlock，符号表数组都会新建一个符号表，用于记录当前基本块中定义的符号。需要使用某个符号的时候，将会从当前符号表递归向父级符号表分析直到根节点。由于已经有过先前语义分析的错误处理的保证，所以一定能在符号表中找到相应符号。</p>\n<p>中间代码生成程序中，为了防止函数传参或需要返回的值过多，使用全局变量用于传递部分参数和记录返回值，比如tmpValue、tmpType等。</p>\n<p>对于全局变量的定义，定义时重点关注初始化部分，若有初始化需要将初始化的值计算出来，直接赋值给全局变量。</p>\n<p>而在函数内部的变量定义，只需要使用AllocaInst进行定义，初始化的过程使用普通的运算进行初始化。</p>\n<p>中间代码生成中，循环的设计比较容易出错，我这里采用这种放肆进行设计</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x27;for&#x27; &#x27;(&#x27; [ForStmt] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt] &#x27;)&#x27; Stmt </span><br><span class=\"line\"></span><br><span class=\"line\">    forStmt1;     </span><br><span class=\"line\">    br forBlock</span><br><span class=\"line\">    condBlock1:                                       </span><br><span class=\"line\">        cond ? br forBlock, br finalBlock;                </span><br><span class=\"line\">    forBlock:</span><br><span class=\"line\">    \tStmt</span><br><span class=\"line\">    \tbr condBlock2;                                    </span><br><span class=\"line\">    condBlock2:                                       </span><br><span class=\"line\">        forStmt2;                                     </span><br><span class=\"line\">        cond ? br forBlock, br finalBlock;                </span><br><span class=\"line\">    finalBlock;                                       </span><br></pre></td></tr></table></figure>\n<p>需要注意，如果在Stmt中遇到continue语句，要跳转到condBlock2，如果遇到Break则跳转到finalBlock。</p>\n<p>类型转换相对较为容易，只需要在Store、向函数传参、函数返回值的时候判断类型并判断是否进行Trunc和Zext。Zext还有在BinaryInst中当条件判断左右类型不一致时使用，将条件两边都扩展为i32进行计算。</p>\n<p>函数内使用数组和数组定义也比较麻烦，因为需要使用GetElementPointer指令来调用数组，所以需要tmpOffset进行记录现在位于数组的位置，还需要注意到该条指令调用诸如a[n]时格式如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%<span class=\"number\">1</span> = getelementptr [<span class=\"number\">5</span> x i32], [<span class=\"number\">5</span> x i32]* @a, i32 <span class=\"number\">0</span>, i32 n</span><br></pre></td></tr></table></figure>\n<p>中间代码的程序会在程序中逐步建立以IrModule作为根节点，Value作为分支的中间代码树，方便后续目标代码的翻译。</p>\n<h2 id=\"目标代码生成设计\">目标代码生成设计</h2>\n<h3 id=\"Reg设计\">Reg设计</h3>\n<p>Reg作为mips的寄存器，包含一个String值记录是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mi>p</mi><mtext>寄存器还是</mtext></mrow><annotation encoding=\"application/x-tex\">gp寄存器还是</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">p</span><span class=\"mord cjk_fallback\">寄</span><span class=\"mord cjk_fallback\">存</span><span class=\"mord cjk_fallback\">器</span><span class=\"mord cjk_fallback\">还</span><span class=\"mord cjk_fallback\">是</span></span></span></span>sp寄存器。offset用于记录当前位于的sp寄存器偏移量。其中<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>g</mi><mi>p</mi><mtext>用于调用全局变量，</mtext></mrow><annotation encoding=\"application/x-tex\">gp用于调用全局变量，</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">p</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">于</span><span class=\"mord cjk_fallback\">调</span><span class=\"mord cjk_fallback\">用</span><span class=\"mord cjk_fallback\">全</span><span class=\"mord cjk_fallback\">局</span><span class=\"mord cjk_fallback\">变</span><span class=\"mord cjk_fallback\">量</span><span class=\"mord cjk_fallback\">，</span></span></span></span>sp寄存器用于记录局部变量。$sp可以通过不同偏移量记录不同的数据。</p>\n<h3 id=\"目标代码翻译程序\">目标代码翻译程序</h3>\n<p>在目标代码翻译开始后，先开始进行Data部分的翻译，Data部分包含全局变量和库函数定义。随后进入.text部分，在text最开头&quot;jal main&quot;指令，最后再进行函数定义。</p>\n<p>在data部分，我将i32和i8全都定义为.word进行记录，这样子比较方便后续调用（虽然会占用很多空间就是了）。如果是非数组变量仅需使用.word加上数值，如果是数组变量，需要计算数组的大小然后定义存储的空间，如果数组未初始化，可以直接使用.space，如果初始化了，则需要使用.word给每一个变量赋初始值。</p>\n<p>定义了全局变量后，下一步需要定义库函数。库函数仅包含GETINT()、GETCHAR()、PUTINT()、PUTCH()、PUTSTR()，其实只需要使用li给$v0赋上系统调用的值后，再进行syscall即可。</p>\n<p>接下来进如BuildFunction函数中。在这个函数中，会先读取参数，随后进行参数存入对应的sp寄存器偏移量位置处。在每次jal进入函数前，程序会将sp减去当前偏移量，这样在函数中就会从偏移量0开始使用sp寄存器，在出函数后，恢复寄存器偏移量。函数里调用产生的临时变量确实会消失不过也不需要那些，仅仅需要从$ra 中得到返回值即可。</p>\n<h3 id=\"Translator设计\">Translator设计</h3>\n<p>translator包含了将中间代码翻译为mips的基本函数。</p>\n<p>其中含有一个Map mem用于记录一个变量（变量名可以通过中间代码中Value获取唯一的编号）以及变量对应的Reg。</p>\n<p>在translator中，为每一条中间代码的instruction撰写对应的翻译文法</p>\n<p>translator中包含几个基本函数：</p>\n<ul>\n<li>addGlobal，用于向mem中添加全局变量的记录，仅记录符号名字。</li>\n<li>addSp和addSpArray，负责像mem中添加符号栈sp的记录，记录对应符号的偏移量。其中是Array型的时候，需要要计算数组的偏移量。</li>\n<li>load，负责处理将变量或sp栈内内容临时存储在t0、t1寄存器中。</li>\n<li>store，负责将t0、t1等寄存器中的值，存入sp栈内或全局变量内。</li>\n<li>translate函数，负责根据当前所翻译的指令，调用不同的翻译方法。</li>\n</ul>\n<h2 id=\"总结感想\">总结感想</h2>\n<p>经过了一学期的编译撰写，也是终于将编译器完成了。</p>\n<p>从最开始的不敢想象该怎么写，到一步步将编译器完成，也是收获颇丰。最开始的词法分析部分算是比较简单，只需要写一个简单的词法分析自动机就可以快速完成。</p>\n<p>从语法分析开始就逐步变得困难了…当时听说要建立四五十个类我还在想为什么要这么麻烦，只到在理论课上学习了如何使用递归下降子程序法建立语法树，才意识到语法树的确需要给每个语法模块都建立一个单独的类。经过理论课的学习，建立语法分析树变得比较简单，仅仅需要理解如何使用递归下降分析即可完成。</p>\n<p>语义分析中，我根据语法树建立了一个简单的符号表，也进行了错误的分析。通过错误分析，我逐步认识到了符号表的建立方式，同时还修复了在词法分析和语法分析中的部分小错误（当时没有发现但是居然能过测试点）</p>\n<p>中间代码生成乃是编译大作业的一大高山，写了我足足三周才写完。中间代码生成光是第一步理解LLVM的结构就耗时一星期才初步了解完全部结构，光是复杂的Value、User、Instruction继承关系让我汗流浃背了。经过一周的初步理解，我才发现真正的难点在于如何将语法树转化成中间代码。从全局变量的定义到函数内部的生成，每一步都不简单。尤其是使用数组时候的GEP还有for循环、if等条件判断中块与块间的跳转，搞得我晕头转向。不过经过不懈努力，也是在结束之前将LLVM成果拿下。LLVM生成出来，终于能在Linux虚拟机上配置的环境中成功运行了</p>\n<p>MIPS相对于LLVM的生成还是较为简单的。LLVM的结构与MIPS已经比较相近。在MIPS中，最大的困难是理解对$sp的使用。在经过一周的奋战后，MIPS也是拉下帷幕。生成出来的MIPS的确能在MARS上正确运行，让我感到十分有成就感。</p>\n<p>通过这次编译器的撰写，对编译原理课大大加深了理解，感觉这是大学最有成就感的一次迭代作业，感觉比上学期的操作系统实验有意思多了（主要是上学期操作系统太难了看不太懂），总的来说，编译原理是一门顶尖好课: )</p>\n",
            "tags": [
                "大学",
                "总结",
                "编译"
            ]
        },
        {
            "id": "https://blog.unfinished.top/2024/12/17/%E6%88%91%E8%A6%81%E6%88%90%E4%B8%BA%E7%BC%96%E8%AF%91%E9%AB%98%E6%89%8B/",
            "url": "https://blog.unfinished.top/2024/12/17/%E6%88%91%E8%A6%81%E6%88%90%E4%B8%BA%E7%BC%96%E8%AF%91%E9%AB%98%E6%89%8B/",
            "title": "我要成为编译高手",
            "date_published": "2024-12-17T15:17:09.000Z",
            "content_html": "<p><img src=\"%E6%88%91%E8%A6%81%E6%88%90%E4%B8%BA%E9%AB%98%E6%89%8B.jpg\" alt=\"我要成为高手\"></p>\n<h1>文法</h1>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mtext>符号串乘积</mtext><mo stretchy=\"false\">{</mo><mi>a</mi><mo separator=\"true\">,</mo><mi>b</mi><mo stretchy=\"false\">}</mo><mo>∗</mo><mo stretchy=\"false\">{</mo><mi>c</mi><mo separator=\"true\">,</mo><mi>d</mi><mo stretchy=\"false\">}</mo><mo>=</mo><mo stretchy=\"false\">{</mo><mi>a</mi><mi>c</mi><mtext>，</mtext><mi>a</mi><mi>d</mi><mtext>，</mtext><mi>b</mi><mi>c</mi><mtext>，</mtext><mi>b</mi><mi>d</mi><mo stretchy=\"false\">}</mo><mspace linebreak=\"newline\"></mspace><mtext>幂运算</mtext><mspace linebreak=\"newline\"></mspace><msup><mi>A</mi><mn>0</mn></msup><mo>=</mo><mi>ε</mi><mo separator=\"true\">,</mo><msup><mi>A</mi><mn>1</mn></msup><mo>=</mo><mi>A</mi><mo separator=\"true\">,</mo><msup><mi>A</mi><mn>2</mn></msup><mo>=</mo><mi>A</mi><mi>A</mi><mspace linebreak=\"newline\"></mspace><mtext>正闭包</mtext><mo>:</mo><msup><mi>A</mi><mo>+</mo></msup><mo>=</mo><msup><mi>A</mi><mn>1</mn></msup><mo>∪</mo><msup><mi>A</mi><mn>2</mn></msup><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>∪</mo><msup><mi>A</mi><mi>n</mi></msup><mspace linebreak=\"newline\"></mspace><mtext>闭包</mtext><mo>:</mo><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><msup><mi>A</mi><mn>0</mn></msup><mo>∪</mo><msup><mi>A</mi><mn>1</mn></msup><mo>∪</mo><msup><mi>A</mi><mn>2</mn></msup><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mi mathvariant=\"normal\">.</mi><mo>∪</mo><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">符号串乘积\\{a,b\\} * \\{c,d\\} = \\{ac，ad，bc，bd\\}\\\\\n幂运算\\\\\nA^0={ε},A^1 = A ,A^2 = AA\\\\\n正闭包:\nA^+=A^1∪A^2...∪A^n\\\\\n闭包:\nA^*=A^0∪A^1∪A^2...∪A^n\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord cjk_fallback\">符</span><span class=\"mord cjk_fallback\">号</span><span class=\"mord cjk_fallback\">串</span><span class=\"mord cjk_fallback\">乘</span><span class=\"mord cjk_fallback\">积</span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">b</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">c</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">}</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">c</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">d</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">c</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">}</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">幂</span><span class=\"mord cjk_fallback\">运</span><span class=\"mord cjk_fallback\">算</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0585479999999998em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">ε</span></span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.0585479999999998em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\">A</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">正</span><span class=\"mord cjk_fallback\">闭</span><span class=\"mord cjk_fallback\">包</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.821331em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.821331em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">+</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7143919999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">闭</span><span class=\"mord cjk_fallback\">包</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">:</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.738696em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.738696em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8641079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mord\">.</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∪</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7143919999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">A</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span></span></p>\n<p>Vn：非终结符号集</p>\n<p>Vt：终结符号集</p>\n<p>P：产生式或规则的集合</p>\n<p>Z：开始符号（识别符号） Z∈Vn</p>\n<h3 id=\"基本概念\">基本概念</h3>\n<h4 id=\"推导\">推导</h4>\n<p><img src=\"image-20241210135553750.png\" alt=\"image-20241210135553750\" style=\"zoom:67%;\" /> 一步或多步</p>\n<p><img src=\"1733810193966(1).png\" alt=\"1733810193966(1)\" style=\"zoom: 67%;\" /> 零步一步或多步</p>\n<p><strong>最右推导</strong>：规范</p>\n<h4 id=\"句子句型\">句子句型</h4>\n<p>句型：Z零步一步或多步推导到x</p>\n<p>句子：Z一步或多步推导到x，且x内符号都是终结符</p>\n<p>语言：所有句子的集合 L(G[Z])</p>\n<p>若两个文法语言相同，则文法等价。</p>\n<h4 id=\"短语、句柄\">短语、句柄</h4>\n<p>短语是相对于一个<strong>句型</strong>的</p>\n<p>简单短语要求只有一步推导</p>\n<p>句柄是最左简单短语</p>\n<h4 id=\"规约\">规约</h4>\n<p>按照最左简单短语进行规约为规范规约。</p>\n<p>规范：<strong>最左规约</strong>，<strong>最右推导</strong></p>\n<h3 id=\"递归文法\">递归文法</h3>\n<p>U::= Uy，左递归</p>\n<p>U::= xU，右递归</p>\n<p><strong>左递归不能用自顶向下</strong></p>\n<h3 id=\"二义性\">二义性</h3>\n<ol>\n<li>一个文法的某一句子存在两棵不同的语法树，则该文法是二义性的</li>\n<li>若一个文法的某句子存在两个不同的规范推导，则该文法是二义性的</li>\n<li>若一个文法的某规范句型的句柄不唯一，则该文法是二义性的</li>\n</ol>\n<h3 id=\"压缩文法\">压缩文法</h3>\n<p><strong>U::=U</strong>的文法是有害的</p>\n<p><strong>规则的左部非终结符不出现在任何句型中</strong>的文法是无用的</p>\n<p><strong>无有害规则或多余规则</strong>的文法是<strong>压缩过的</strong></p>\n<h3 id=\"文法类型\">文法类型</h3>\n<p>0型：左部和右部都可以是符号串；一个短语可以产生另一个短语；可以被<strong>图灵机</strong>接受</p>\n<p>1型：上下文有关文法，<strong>xUy::= xuy</strong> ; 可以被<strong>线性界限自动机接受</strong></p>\n<p>2型：上下文无关文法，<strong>U::= u</strong>，U∈Vn ,  n∈V* ； 可以被<strong>下推自动机</strong>接受</p>\n<p>3型：正则文法，<strong>U::=t</strong>，U::=Wt（左线性）或U::=tW（右线性） <strong>其中U、W∈Vn，t∈Vt</strong>，可以被<strong>有穷自动机</strong>接受</p>\n<h1>词法分析</h1>\n<h3 id=\"状态图\">状态图</h3>\n<p><strong>左线性文法</strong>状态图：</p>\n<p>设置开始状态S，若Q::=t, <img src=\"1733812726285.png\" alt=\"1733812726285\" style=\"zoom: 50%;\" /></p>\n<p>若Q::=Rt，<img src=\"1733812771271.png\" alt=\"1733812771271\" style=\"zoom:50%;\" /></p>\n<img src=\"1733813469367.png\" alt=\"1733813469367\" style=\"zoom:50%;\" /> \n<h3 id=\"正则表达式\">正则表达式</h3>\n<p>运算符</p>\n<p>|：或</p>\n<p>*或{ }：重复</p>\n<h3 id=\"DFA\">DFA</h3>\n<img src=\"1733814606183.png\" alt=\"1733814606183\" style=\"zoom:50%;\" /> \n<h3 id=\"NFA（非确定）\">NFA（非确定）</h3>\n<p>一个状态经过一个终结符可以到多个状态，可以输入空值</p>\n<img src=\"1733814412975.png\" alt=\"1733814412975\" style=\"zoom: 67%;\" /> \n<h3 id=\"生成NFA（和状态图不一样）\">生成NFA（和状态图不一样）</h3>\n<p>用右线性文法，因为左线性会死循环</p>\n<p><strong>A→tB</strong>：<img src=\"1733815716718.png\" alt=\"1733815716718\" style=\"zoom:50%;\" /></p>\n<p>A→t：则A经过t到终结状态</p>\n<img src=\"1733816009576.png\" alt=\"1733816009576\" style=\"zoom:50%;\" /> \n<img src=\"1733816058396.png\" alt=\"1733816058396\" style=\"zoom:50%;\" /> \n<p>或</p>\n<img src=\"1733816105599.png\" alt=\"1733816105599\" style=\"zoom:50%;\" /> \n<h3 id=\"NFA的确定化\">NFA的确定化</h3>\n<p>1.确定集合I的<strong>ε-闭包</strong>：I以及从I经过ε弧能到的所有状态集合</p>\n<p>2.确定闭包的Ia、Ib、…</p>\n<img src=\"1733815278257.png\" alt=\"1733815278257\" style=\"zoom:50%;\" /> \n<p>3.得到新的状态图</p>\n<img src=\"1733815410213.png\" alt=\"1733815410213\" style=\"zoom:50%;\" /> \n<h3 id=\"最小化\">最小化</h3>\n<p>消除多余状态：肉眼看，删除不会到达的状态</p>\n<p>划分等价状态：</p>\n<ol>\n<li>将状态先分为终结状态和非终结状态</li>\n<li>在每个区域中看哪些状态经过符号后到达的状态等价</li>\n</ol>\n<h1>语法分析</h1>\n<h2 id=\"自顶向下分析\">自顶向下分析</h2>\n<p>不能有左递归！</p>\n<p>要消除左递归：</p>\n<ul>\n<li>使用BNF改写：\n<ol>\n<li>U::= xy|xw → U::=x(y|w)</li>\n<li>T∷= T * F | T / F | F  → T∷= F { * F | / F }</li>\n</ol>\n</li>\n<li>左递归改成右递归：\n<ol>\n<li>P::= Pa|b  →  P ::= bP’     P’ ::=aP’ | ε</li>\n</ol>\n</li>\n</ul>\n<p>消除一般左递归：</p>\n<img src=\"1733819340540.png\" alt=\"1733819340540\" style=\"zoom: 67%;\" /> \n<img src=\"1733819367290(1).png\" alt=\"1733819367290(1)\" style=\"zoom: 67%;\" /> \n<p>消除回溯问题，将xV|xU改成 x(V|U)，并尽力保证FIRST(V)和FIRST(U)不相交。</p>\n<p>无法消除回溯的话，可以超前扫描几个符号</p>\n<h3 id=\"递归下降子程序\">递归下降子程序</h3>\n<p>简单</p>\n<img src=\"1733819654619.png\" alt=\"1733819654619\" style=\"zoom:50%;\" /> \n<h3 id=\"LL-1-分析法\">LL(1)分析法</h3>\n<p><strong>自左向右扫描</strong>符号串</p>\n<h4 id=\"First、Follow集\">First、Follow集</h4>\n<p><strong>First</strong></p>\n<p>若Xi∈Vt，则First(Xi)={Xi}</p>\n<p>若Xi∈Vn，Xi::= a…| ε, First(Xi) = {a, ε}</p>\n<p>若Xi∈Vn ，</p>\n<ul>\n<li>Xi::= y1y2…yk，将FIRST(y1 ) – {ε} 加入First（Xi）</li>\n<li>若ε ∈ FIRST( y1 ) ，则将FIRST(y2 ) – {ε} 加入</li>\n<li>…</li>\n<li>若全都有ε，First集加入ε</li>\n</ul>\n<p><strong>Follow</strong></p>\n<p>若S为识别符号，则 # 加入Follow（S）</p>\n<p>若 A ::= αBβ 则把 <strong>FIRST(β)-{ε}</strong> 加入到 Follow（B）</p>\n<p>若 A ::= αBβ β能推出ε  或 A::= αB ，则把**Follow(A)**加入到Follow(B)</p>\n<h4 id=\"构造分析表\">构造分析表</h4>\n<ul>\n<li>S ::= A是某规则，a为终结符或#,  把所有 a∈ FIRST( A ) ，M[S, a] 放入该条规则</li>\n<li>若A=ε或 A能推出ε，则把所有 a∈ FOLLOW( S )的 M[S,a]放 S::=ε</li>\n<li>剩下的全是error</li>\n</ul>\n<img src=\"image-20241214144657328.png\" alt=\"image-20241214144657328\" style=\"zoom:67%;\" /> \n<p>如果没有<strong>多重定义</strong>入口，则是LL(1)文法</p>\n<p><strong>LL(1)判断方法</strong></p>\n<p>如果是LL（1），那么当 S::= A1|A2</p>\n<ul>\n<li>\n<p>First(A1) <strong>∩</strong> First(A2) = Ф</p>\n</li>\n<li>\n<p>若A2 是 <strong>ε</strong>或可推出 <strong>ε</strong>，那么 First(A1) <strong>∩</strong> First(S) = Ф</p>\n</li>\n</ul>\n<h4 id=\"执行过程\">执行过程</h4>\n<p>假设E是识别符号</p>\n<p>符号栈开始状态 #E，读入输入串第一个符号</p>\n<p>根据栈顶符号X和输入符号a</p>\n<ul>\n<li>若 X ∈ Vt，X=a=#，停止</li>\n<li>若 X ∈ Vt，X=a不等于#，将X退出栈</li>\n<li>若 X ∈ Vt，X不等于a，出错</li>\n<li>若 X ∈ Vn，查表\n<ol>\n<li>若M[X,a] 为   X∷= U V W，则X弹出，先后将W、V、U入栈（注意顺序，U在栈顶）</li>\n<li>若M[X,a] 为 <strong>X::=ε</strong> 则把X弹出栈</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"自底向上分析\">自底向上分析</h2>\n<h3 id=\"算符优先分析\">算符优先分析</h3>\n<p><strong>算符文法不允许两个非终结符相邻</strong>！</p>\n<img src=\"image-20241214161251107.png\" alt=\"image-20241214161251107\" style=\"zoom:50%;\" /> \n<h4 id=\"FirstVT、LastVT\">FirstVT、LastVT</h4>\n<p>… 可以代表任意或为空</p>\n<p>FirstVT( U ) = {b | U→b… 或 U→Vb… ,  b ∈ Vt,  V ∈ Vn}</p>\n<p>LastVT( U ) = {a | U→…a 或 U→…aV ,  a ∈ Vt,  V ∈ Vn}</p>\n<p>构造FirstVT：</p>\n<ul>\n<li>如果有U::= b… 或 U::= Vb… 则 b∈FIRSTVT( U )</li>\n<li>如果有U::= V…，则所有 b∈FIRSTVT( V )，都有b∈FIRSTVT( U )</li>\n</ul>\n<p>构造LastVT：</p>\n<ul>\n<li>如果有U::= …a 或 U::= …aV 则 a∈LASTVT( U )</li>\n<li>如果有U::= …V，则所有 a∈LASTVT( V )，都有a∈LASTVT( U )</li>\n</ul>\n<h4 id=\"构造优先关系矩阵\">构造优先关系矩阵</h4>\n<p>打不出来，所以下面</p>\n<p>= 代表<img src=\"image-20241214164544651.png\" alt=\"image-20241214164544651\" style=\"zoom:50%;\" /></p>\n<p>&lt; 代表 <img src=\"image-20241214164608414.png\" alt=\"image-20241214164608414\" style=\"zoom:50%;\" /></p>\n<p>&gt; 代表<img src=\"image-20241214164640513.png\" alt=\"image-20241214164640513\" style=\"zoom:50%;\" /></p>\n<p>对于每条规则进行处理，</p>\n<p>假设规则为U::=X1 X2 … Xn</p>\n<p>for（i = 1；i&lt;=n-1 ;  i++）</p>\n<ul>\n<li>如果Xi 和 Xi+1都是Vt，则 Xi = Xi+1</li>\n<li>如果i&lt;=n-2 且 Xi 和 Xi+2都是Vt，但Xi+1是Vn，则Xi = Xi+2</li>\n<li>如果 Xi 是Vt     Xi+1是Vn ，则 Xi&lt; FIRSTVT(Xi+1)中每个符号</li>\n<li>如果 Xi 是Vn     Xi+1是Vt ，则  LASTVT(Xi)中每个符号 &gt; Xi+1</li>\n</ul>\n<h4 id=\"素短语\">素短语</h4>\n<p>素短语是一个 至少包含一个终结符号，且除了它自身不含更小的素短语的 短语</p>\n<p><strong>句柄是最左短语</strong></p>\n<p><strong>最左素短语不一定是句柄！</strong></p>\n<img src=\"image-20241214171149086.png\" alt=\"image-20241214171149086\" style=\"zoom:50%;\" /> \n<h4 id=\"执行过程-2\">执行过程</h4>\n<p>算符优先文法对最左素短语规约</p>\n<ul>\n<li><strong>&lt;：移进</strong></li>\n<li><strong>=：移进</strong></li>\n<li><strong>&gt;：规约</strong></li>\n</ul>\n<p><img src=\"image-20241214155739805.png\" alt=\"image-20241214155739805\"></p>\n<img src=\"image-20241214160049496.png\" alt=\"image-20241214160049496\" style=\"zoom:67%;\" /> \n<h3 id=\"LR分析法\">LR分析法</h3>\n<p>哦我的老天</p>\n<p>LR分析法规约的是句柄，算符优先归约的是最左素短语</p>\n<h4 id=\"活前缀\">活前缀</h4>\n<p>规范句型是通过规范规约（最左）得到的句型</p>\n<p>对于 αβt ，β表示句柄 ，若αβ = u1u2…ur，那么符号串u1…ui（1&lt;=i&lt;=r）是活前缀</p>\n<h4 id=\"构造LR-0\">构造LR(0)</h4>\n<p>1.让文法开始符号的规则只有一条</p>\n<p>2.构造闭包项目集</p>\n<p>3.构造goto</p>\n<p>action构造：</p>\n<p>A→a. 规约</p>\n<p>E’→a. 接受</p>\n<p>A→a.b （b∈ Vt）移进</p>\n<p>A→a.b （b∈ Vn）待约（无动作）</p>\n<p>会有 移进-规约 冲突</p>\n<h4 id=\"SLR（0）\">SLR（0）</h4>\n<p>改为看Follow集</p>\n<p>当A→α.     B→α.    X→α.b</p>\n<p>读入符号当 a = b，移进</p>\n<p>a∈Follow（A），A→α</p>\n<p>a∈Follow（B），B→α</p>\n<h1>符号表管理</h1>\n<p>符号表结构：</p>\n<p>名字、特性（类型、值、种类等）</p>\n<p>组织方式：</p>\n<p>统一符号表（不管什么都填入到一个格式的符号表），结构简单</p>\n<p>不同种类建立不同的，节省空间但是不方便</p>\n<p>折中办法：共有信息总结成统一格式，特殊信息用指针连接到附表</p>\n<h3 id=\"非分程序结构和符号表\">非分程序结构和符号表</h3>\n<p>可独立进行编译的程序单元是不包含有子模块的单一模块</p>\n<p>作用域：</p>\n<p>子程序名、函数名、公共区域名 —— 全局</p>\n<p>程序单元内变量 —— 局部</p>\n<p>组织方式：</p>\n<table>\n<thead>\n<tr>\n<th>全局符号表</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>局部符号表</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"分程序结构语言和符号表\">分程序结构语言和符号表</h3>\n<p><strong>模块内可嵌入子模块</strong></p>\n<p>作用域：标识符定义时所处于的模块</p>\n<p><strong>过程或函数说明中定义的标识符（包括形参）其作用域为本过程体。</strong></p>\n<p><strong>循环语句中定义的标识符，其作用域为该循环语句</strong></p>\n<img src=\"image-20241210170904106.png\" alt=\"image-20241210170904106\" style=\"zoom:50%;\" /> \n<h4 id=\"分程序符号表结构\">分程序符号表结构</h4>\n<table>\n<thead>\n<tr>\n<th>Outern</th>\n<th>Ecount</th>\n<th>Pointer</th>\n</tr>\n</thead>\n</table>\n<p>Outern：直接外层编号</p>\n<p>Ecount：符号表项个数</p>\n<p>Pointer：该符号表起始位置</p>\n<img src=\"image-20241210171349194.png\" alt=\"image-20241210171349194\" style=\"zoom:50%;\" />\n<p>出块后删除块符号表</p>\n<p><strong><u>红框内删了</u></strong></p>\n<img src=\"image-20241210171359418.png\" alt=\"image-20241210171359418\" style=\"zoom:50%;\" /> \n<h1>运行时存储管理</h1>\n<p>栈地址寄存器，该空间位于<strong>高地址</strong></p>\n<h3 id=\"静态存储分配\">静态存储分配</h3>\n<p><strong>每个变量所需空间的大小在编译时已知</strong></p>\n<p>在<strong>编译阶段</strong>由编译程序实现对<strong>存储空间的管理</strong>，为源程序中的变量分配存储</p>\n<p><strong>条件：<strong>在</strong>编译时</strong>能够确定源程序中变量在运行时的数据空间大小</p>\n<ul>\n<li><strong>不允许指针或动态分配</strong></li>\n<li><strong>不允许递归调用过程</strong></li>\n</ul>\n<p>开辟一数据区，目标地址填入变量的符号表中</p>\n<p>没鸟用，我觉得不考🤓👆</p>\n<h3 id=\"动态存储分配\">动态存储分配</h3>\n<p>这个必考🤓👆</p>\n<table>\n<thead>\n<tr>\n<th>局部数据区</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>参数区</td>\n</tr>\n<tr>\n<td>display区</td>\n</tr>\n</tbody>\n</table>\n<p><strong>局部数据区</strong>：存放局部变量</p>\n<p><strong>参数区</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>形参数据区：<strong>显式参数区</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>prev adb：<strong>存放调用模块记录基地址</strong></td>\n</tr>\n<tr>\n<td>ret addr：<strong>返回地址</strong></td>\n</tr>\n<tr>\n<td>ret value：<strong>函数返回值</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>display</strong>区：存放<strong>各外层模块活动记录的基地址</strong></p>\n<p>1{    2{  }      3{      4{  }    }    } 中，4应当存放AR1和AR3的基地址</p>\n<h4 id=\"例题\">例题</h4>\n<p><strong>重点：看call 了谁再加入活动记录</strong></p>\n <img src=\"image-20241210175114576.png\" alt=\"image-20241210175114576\" style=\"zoom:67%;\" /> \n<img src=\"image-20241210175135976.png\" alt=\"image-20241210175135976\" style=\"zoom:50%;\" /> \n<p>易错点：<strong>局部变量在参数上面</strong>，因为其实是从下往上构建的</p>\n<p><img src=\"image-20241210175147431.png\" alt=\"image-20241210175147431\" style=\"zoom: 40%;\" /> <img src=\"image-20241210175347035.png\" alt=\"image-20241210175347035\" style=\"zoom:40%;\" /></p>\n<p>数组需要加一个“数组的模块”</p>\n<img src=\"image-20241210175451927.png\" alt=\"image-20241210175451927\" style=\"zoom:50%;\" /> \n<img src=\"1733825146873.png\" alt=\"1733825146873\" style=\"zoom:50%;\" /> \n<img src=\"1733825169171.png\" alt=\"1733825169171\" style=\"zoom:50%;\" /> \n<p><strong>运行时地址计算</strong>：考鸡毛，PPT就一页</p>\n<h1>错误处理？</h1>\n<p>就几页PPT，肯定只考小题</p>\n<p>语法错误：不符合语法、词法的错误</p>\n<p>语义错误：不符合语义规则或超越具体计算机系统限制（数据溢出、常数太大；符号表、静态存储溢出；动态存储溢出）</p>\n<p><strong>分析以后再报告</strong>：保存错误，全分析完了再打印</p>\n<p><strong>边分析边报告</strong>：顾名思义</p>\n<ul>\n<li>一般原则：诊断到错误并记录后，跳过当前语法成分继续分析</li>\n</ul>\n<p>运行时错误：下标变量、下标值越界；计算结果溢出；动态存储分配数据区溢出</p>\n<p><strong>错误局部化处理</strong>:   发现错误后，尽可能将把错误的影响限制在一个局部的范围避免错误扩散和影响程序其它部分的分析</p>\n<h1>翻译文法</h1>\n<h3 id=\"翻译文法概念-、-活动序列\">翻译文法概念 、 活动序列</h3>\n<p><strong>输入文法：</strong></p>\n<ul>\n<li>没插入动作符号的文法。</li>\n<li>推导产生<strong>输入序列</strong></li>\n</ul>\n<p><strong>翻译文法：</strong></p>\n<ul>\n<li>插入了动作符号的文法</li>\n<li>推导产生<strong>活动序列</strong></li>\n</ul>\n<p>**活动序列：**包含 <em>输入序列</em>、<em>动作序列</em></p>\n<ul>\n<li>输入序列：由终结符组成</li>\n<li>动作序列：由动作符号组成</li>\n</ul>\n<p>翻译文法是<strong>上下文无关文法</strong></p>\n<p>**符号串翻译文法：**输出@后的字符串的文法</p>\n<p>中缀表达式文法→逆波兰表示</p>\n<p>加入动作<img src=\"image-20241212201947561.png\" alt=\"image-20241212201947561\" style=\"zoom:50%;\" /></p>\n<h3 id=\"属性翻译文法\">属性翻译文法</h3>\n<img src=\"image-20241214212518649.png\" alt=\"image-20241214212518649\" style=\"zoom:50%;\" /> \n<p>L-属性翻译：</p>\n<ul>\n<li>继承属性\n<ol>\n<li>产生式左部非终结符号的继承属性，取前面表达式的右部该符号 的继承属性值</li>\n<li>产生式右侧符号的继承属性，使用当前式左侧符号的<strong>继承属性</strong>或在该符号左边的符号<strong>属性</strong>计算</li>\n</ol>\n</li>\n<li>综合属性\n<ol>\n<li>产生式右部非终结符号的综合属性值，取其<strong>推导产生式</strong>左部同名非终结符号的综合属性值</li>\n<li>产生式左侧非终结符号的综合属性值，使用当前产生式左侧<strong>继承属性</strong>或右侧符号的<strong>属性</strong>计算</li>\n<li>动作符号的综合属性，使用该符号的继承属性或右侧符号的属性计算</li>\n</ol>\n</li>\n</ul>\n<p>简单赋值L-属性翻译要求：</p>\n<p>产生式右侧符号继承属性<strong>等于左部符号的继承属性值</strong>，或等于出现在所给符号左部某个符号的<strong>综合属性值</strong></p>\n<p>产生式左部非终结符号的<strong>综合属性</strong>，等于<strong>自身的继承属性</strong>，或<strong>右部</strong>某个符号的<strong>综合属性</strong></p>\n<p>变换：</p>\n<img src=\"image-20241213140210680.png\" alt=\"image-20241213140210680\" style=\"zoom:50%;\" /> \n<p>不符合规则，因为需要对f求值，修改为</p>\n<img src=\"image-20241213140250766.png\" alt=\"image-20241213140250766\" style=\"zoom:50%;\" /> \n<h1>数组变量的声明处理</h1>\n<p>n维数组元素地址的计算</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>i</mi><mtext>维的下界</mtext><mi>L</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mtext>，</mtext><mi>i</mi><mtext>维的上界</mtext><mi>U</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mspace linebreak=\"newline\"></mspace><mi>i</mi><mtext>维元素当前数组的下标</mtext><mi>V</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mspace linebreak=\"newline\"></mspace><mi>E</mi><mtext>：数组元素大小</mtext><mspace linebreak=\"newline\"></mspace><mi>A</mi><mi>D</mi><mi>R</mi><mo>=</mo><mi>L</mi><mi>O</mi><mi>C</mi><mo>+</mo><msubsup><mi mathvariant=\"normal\">Σ</mi><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy=\"false\">[</mo><mi>V</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mi>L</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">]</mo><mo>×</mo><mi>P</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mi>E</mi><mspace linebreak=\"newline\"></mspace><mtext>当</mtext><mi>i</mi><mo>=</mo><mi>n</mi><mtext>时，</mtext><mi>P</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mspace linebreak=\"newline\"></mspace><mtext>当</mtext><mn>1</mn><mo>&lt;</mo><mo>=</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi><mtext>时，</mtext><mi>P</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msubsup><mi mathvariant=\"normal\">Π</mi><mrow><mi>j</mi><mo>=</mo><mi>i</mi><mo>+</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy=\"false\">[</mo><mi>U</mi><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>−</mo><mi>L</mi><mo stretchy=\"false\">(</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mn>1</mn><mo stretchy=\"false\">]</mo><mspace linebreak=\"newline\"></mspace></mrow><annotation encoding=\"application/x-tex\">i维的下界L(i)，i维的上界U(i)\\\\\ni维元素当前数组的 下标V(i) \\\\\nE：数组元素大小\\\\\nADR=LOC+\\Sigma_{i=1}^{n}[V(i)-L(i)]\\times P(i) \\times E \\\\\n当i=n时，P(i) = 1\\\\\n当1&lt;=i&lt;n时，P(i) = \\Pi_{j=i+1}^n [U(j)-L(j)+1] \\\\\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord cjk_fallback\">维</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">下</span><span class=\"mord cjk_fallback\">界</span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\">i</span><span class=\"mord cjk_fallback\">维</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">上</span><span class=\"mord cjk_fallback\">界</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord cjk_fallback\">维</span><span class=\"mord cjk_fallback\">元</span><span class=\"mord cjk_fallback\">素</span><span class=\"mord cjk_fallback\">当</span><span class=\"mord cjk_fallback\">前</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">组</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">下</span><span class=\"mord cjk_fallback\">标</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord cjk_fallback\">数</span><span class=\"mord cjk_fallback\">组</span><span class=\"mord cjk_fallback\">元</span><span class=\"mord cjk_fallback\">素</span><span class=\"mord cjk_fallback\">大</span><span class=\"mord cjk_fallback\">小</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">C</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">Σ</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7143919999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">i</span><span class=\"mrel mtight\">=</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.22222em;\">V</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">E</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord cjk_fallback\">当</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72243em;vertical-align:-0.0391em;\"></span><span class=\"mord cjk_fallback\">当</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69862em;vertical-align:-0.0391em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">n</span><span class=\"mord cjk_fallback\">时</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.133108em;vertical-align:-0.383108em;\"></span><span class=\"mord\"><span class=\"mord\">Π</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.714392em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05724em;\">j</span><span class=\"mrel mtight\">=</span><span class=\"mord mathnormal mtight\">i</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.1130000000000004em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.383108em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">U</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">L</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span><span class=\"mspace newline\"></span></span></span></span></p>\n<h3 id=\"其他内容\">其他内容</h3>\n<p>常量：识别类型，识别名字，赋值</p>\n<p>简单变量：要alloc</p>\n<p>记录变量：是用来引用几个不同名字所组成的实体</p>\n<p>过程声明：调用前需要确定参数、返回值</p>\n<p>马勒戈壁看不懂</p>\n<h1>中间代码</h1>\n<h3 id=\"波兰表示\">波兰表示</h3>\n<p><strong>算术表达式：</strong> F * 3.1416 * R * ( H + R )</p>\n<p><strong>波兰表示：</strong> * F 3.1416 * R * + H R</p>\n<p>**逆波兰表达式：**F 3.1416 * R * H R + *</p>\n<p>赋值语句 <strong>:=</strong> 符号优先级最低</p>\n<p>if语句：if &lt; expr &gt; then &lt; stmt1 &gt; else &lt; stmt2 &gt;</p>\n<p>&lt; expr &gt;  &lt; label1 &gt; BZ &lt; stmt1 &gt; &lt; label2 &gt; BR &lt; stmt2 &gt;</p>\n<p>BZ:如果&lt; expr &gt;结果为0，则跳转到label1，</p>\n<p>BR：跳转到label2</p>\n<p>label1再BR头，label2在BR尾</p>\n<h3 id=\"N元表示\">N元表示</h3>\n<p><strong>三元式</strong>：</p>\n<p>直接三元式</p>\n<img src=\"image-20241212190228341.png\" alt=\"image-20241212190228341\" style=\"zoom:50%;\" /> \n<p>间接三元式：</p>\n<img src=\"image-20241212190358243.png\" alt=\"image-20241212190358243\" style=\"zoom:50%;\" /> \n<p>四元式：</p>\n<p>(op, 操作数1, 操作数2, 结果)</p>\n<h3 id=\"Pcode？\">Pcode？</h3>\n<img src=\"image-20241212190619099.png\" alt=\"image-20241212190619099\" style=\"zoom:50%;\" /> \n<h3 id=\"DAG图\">DAG图</h3>\n<img src=\"image-20241212190646297.png\" alt=\"image-20241212190646297\" style=\"zoom:50%;\" /> \n<h1>代码优化</h1>\n<h3 id=\"优化分类\">优化分类</h3>\n<ul>\n<li>局部优化：指在<strong>基本块内</strong>进行的优化</li>\n<li>全局优化：跨越基本块，在<strong>函数/过程内</strong>进行的优化，进行全局控制流和数据流分析</li>\n<li>循环优化：对<strong>循环语句</strong>所生成的中间代码序列上所进行的优化</li>\n<li>跨函数优化：整个程序，<strong>跨函数</strong>别名分析，逃逸分析</li>\n</ul>\n<h3 id=\"划分基本快\">划分基本快</h3>\n<ol>\n<li>整个语句第一条语句属于入口语句</li>\n<li>任何 条件/无条件 跳转语句转移到的提一条是入口</li>\n<li>紧跟在跳转语句后 第一条是入口</li>\n</ol>\n<h2 id=\"DAG图-2\">DAG图</h2>\n<img src=\"image-20241214220958305.png\" alt=\"image-20241214220958305\" style=\"zoom:50%;\" /> \n<img src=\"image-20241214221015196.png\" alt=\"image-20241214221015196\" style=\"zoom:50%;\" /> \n<img src=\"image-20241214221033065.png\" alt=\"image-20241214221033065\" style=\"zoom:50%;\" /> \n<img src=\"image-20241214221051582.png\" alt=\"image-20241214221051582\" style=\"zoom:50%;\" /> \n<h3 id=\"中间代码构造DAG\">中间代码构造DAG</h3>\n<img src=\"image-20241214223201319.png\" alt=\"image-20241214223201319\" style=\"zoom: 67%;\" /> \n<img src=\"image-20241214223238300.png\" alt=\"image-20241214223238300\" style=\"zoom:67%;\" /> \n<p>**特殊注意：**如果出现 op A或 A op B；其中A、B为常数，需要合并常数</p>\n<p>**省流：**找左右操作数，找不到就新建，找到了就记录→找op，找不到就新建，找到了就记录节点号→找结果对应的变量，找不到就添加到op节点，找到了就把变量改到op节点</p>\n<h3 id=\"DAG转中间代码\">DAG转中间代码</h3>\n<img src=\"image-20241214223321143.png\" alt=\"image-20241214223321143\" style=\"zoom:67%;\" /> \n<p>**省流：**从左向右，把没有父节点且不是叶节点的节点扔进队列，最后逆序输出。</p>\n<h2 id=\"数据流分析\">数据流分析</h2>\n<h3 id=\"到达定义分析\">到达定义分析</h3>\n<p>分析的是数据流信息 d1、d2、…</p>\n<p>gen[S]：S本身<strong>产生</strong>的数据流信息</p>\n<p>kill[S]：S<strong>注销</strong>的数据流信息</p>\n<p>in[S]：<strong>进入</strong>S时的数据流信息</p>\n<p>in[B] = out[P1] ∪ out[P2] ∪ … （所有B的前驱块）</p>\n<p>out[S]：S末尾<strong>得到</strong>的数据流信息</p>\n<p>out = gen ∪ ( in - kill )</p>\n<p><strong>步骤</strong></p>\n<ol>\n<li>先写出gen和kill，能瞪眼看出来</li>\n<li><strong>从上往下</strong>，<u><strong>迭代</strong></u>执行计算每个基本块的in和out</li>\n</ol>\n<p><strong>例题</strong></p>\n<img src=\"image-20241214230235300.png\" alt=\"image-20241214230235300\" style=\"zoom:67%;\" /> \n<img src=\"image-20241214231149157.png\" alt=\"image-20241214231149157\" style=\"zoom: 67%;\" /> \n<h3 id=\"活跃变量分析\">活跃变量分析</h3>\n<p>分析的是<strong>变量</strong>x、y、i、…</p>\n<p>在use里出现的不可能在def出现，反之亦然</p>\n<p>def[B] :  在B中被<strong>定义</strong>先于任何<strong>使用</strong>的变量</p>\n<p>use[B] :  在B中被<strong>使用</strong>先于任何<strong>定义</strong>的变量</p>\n<p>in[B] :  use ∪ (out - def)</p>\n<p>out[B] :  in[P1] ∪ in[P2] ∪ … （所有B的后继块）</p>\n<p>**注意：**形如 x = x + 1的语句中，<strong>x先被使用</strong> 再被定义</p>\n<p><strong>步骤</strong>：</p>\n<ol>\n<li>瞪眼法瞪出来每个块的use和def</li>\n<li>把所有块的in初始化为空</li>\n<li><strong>从下往上</strong>，**<u>迭代</u>**执行：计算每个块的out和in</li>\n</ol>\n<p><strong>例题</strong></p>\n<img src=\"image-20241215131533120.png\" alt=\"image-20241215131533120\" style=\"zoom: 67%;\" /> \n<h2 id=\"冲突图-和-定义-使用链\">冲突图 和 定义-使用链</h2>\n<p>两个变量中一个变量在另一个变量定义处是活跃的，那么他们之间有边连接。</p>\n<h3 id=\"定义-使用链\">定义-使用链</h3>\n<img src=\"image-20241215133105332.png\" alt=\"image-20241215133105332\" style=\"zoom:50%;\" /> \n<img src=\"image-20241215133322831.png\" alt=\"image-20241215133322831\" style=\"zoom:67%;\" /> \n<img src=\"image-20241215134615561.png\" alt=\"image-20241215134615561\" style=\"zoom:67%;\" /> \n<h2 id=\"全局寄存器分配\">全局寄存器分配</h2>\n<ul>\n<li>寄存器分为<strong>全局寄存器</strong>和<strong>临时寄存器</strong></li>\n</ul>\n<h3 id=\"引用计数法\">引用计数法</h3>\n<p>访问次数越多越可能获得全局寄存器，循环内变量获得加权</p>\n<h3 id=\"图着色法\">图着色法</h3>\n<p>假设寄存器数目为K，假设K=3</p>\n<ol>\n<li>不断移去所有连接边小于K的点，直到不能移去</li>\n<li>选一个适当的点，记录为“不分配全局寄存器”，然后移走</li>\n<li>重复1、2，直到只剩一个点</li>\n<li>给最后一个点着色，按照节点移除顺序，把边和节点放回，并着色。“不分配全局寄存器”的节点不着色</li>\n</ol>\n<h2 id=\"循环优化？\">循环优化？</h2>\n<p><strong>归纳变量</strong></p>\n<p>比如for（i=1；i&lt;=10;i++）a[i] = b[i] + c[i]</p>\n<p>生成代码里</p>\n<p>t1=4*i （为了获取地址）</p>\n<p>t2 = b[t1]</p>\n<p>…</p>\n<p>i=i+1</p>\n<p>可把4*优化掉，直接i = i+4</p>\n<p>**代码外提：**不需要在循环中的放出去</p>\n<p>**循环展开：**原本for循环把a[10]全变成0，现在不用for，一条一条置0</p>\n<h2 id=\"基本块内优化类型\">基本块内优化类型</h2>\n<p>常数合并：2+3直接用5</p>\n<p>运算强度削弱：乘法改成左移、x/5改成x*0.5等</p>\n<p>复写传播优化：如x:=y语句，某些时候可以删去。</p>\n<p>删除死代码</p>\n<p>消除局部公共子表达式</p>\n<p>窥孔优化：<strong>化关注在目标指令的一个较短的序列</strong>，<strong>删除其中的冗余代码</strong></p>\n<h2 id=\"指令集架构\">指令集架构</h2>\n<p>C = A + B</p>\n<p><strong>栈式：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Push A</span><br><span class=\"line\">Push B</span><br><span class=\"line\">Add</span><br><span class=\"line\">Pop C</span><br></pre></td></tr></table></figure>\n<p><strong>累加器式：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOAD A</span><br><span class=\"line\">ADD B</span><br><span class=\"line\">STORE C</span><br></pre></td></tr></table></figure>\n<p><strong>寄存器-内存式：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOAD R1, A</span><br><span class=\"line\">ADD R2, R1, B</span><br><span class=\"line\">STORE R2,C</span><br></pre></td></tr></table></figure>\n<p><strong>寄存器-寄存器式：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LOAD R1, A</span><br><span class=\"line\">LOAD R2, B</span><br><span class=\"line\">ADD R3, R1, R2</span><br><span class=\"line\">STORE R3, C</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "大学",
                "总结",
                "编译原理"
            ]
        },
        {
            "id": "https://blog.unfinished.top/2024/11/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/",
            "url": "https://blog.unfinished.top/2024/11/28/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/",
            "title": "数字电路",
            "date_published": "2024-11-28T05:17:48.000Z",
            "content_html": "<img src=\"03acfa18d5b2cad1f38acbb80498b41.jpg\" alt=\"03acfa18d5b2cad1f38acbb80498b41\" style=\"zoom: 33%;\" /> \n<h1>半导体基础</h1>\n<p>N型半导体：多子是负电自由电子，本身带有正电</p>\n<p>P型半导体：多子是正电空穴，本身带有负电</p>\n<h3 id=\"二极管原理\">二极管原理</h3>\n<p>二极管导通电流方向：P→N</p>\n<p><strong>不通电时：</strong></p>\n<ul>\n<li>浓度差导致扩散运动\n<ul>\n<li>P区空穴向N区扩散</li>\n<li>N区自由电子向P区扩散</li>\n</ul>\n</li>\n<li>电场导致漂移运动\n<ul>\n<li>P区自由电子向N区漂移</li>\n<li>N区空穴向P区漂移</li>\n</ul>\n</li>\n<li>扩散导致内电场增大，漂移导致内电场减小，二者平衡</li>\n</ul>\n<p><strong>正向导通：</strong></p>\n<ul>\n<li>电流方向P→N，和内电场方向相反</li>\n<li>破坏内电场，促进扩散运动</li>\n<li>多子扩散电流大，导通</li>\n</ul>\n<p><strong>反向截止：</strong></p>\n<ul>\n<li>电流方向N→P，和内电场方向一致</li>\n<li>强化内电场，扩散运动减小，促进漂移</li>\n<li>少子漂移电流很小，约等于截断</li>\n</ul>\n<h3 id=\"二极管特性曲线\">二极管特性曲线</h3>\n<img src=\"1732611770910.png\" alt=\"1732611770910\" style=\"zoom:50%;\" /> \n<h1>CMOS</h1>\n<h3 id=\"MOS管结构和性质\">MOS管结构和性质</h3>\n<p>箭头由P指向N</p>\n<img src=\"1732609958194(1).png\" alt=\"1732609958194(1)\" style=\"zoom: 80%;\" /> \n<img src=\"1732609658783.png\" alt=\"1732609658783\" style=\"zoom:50%;\" /> \n<h3 id=\"反相器\">反相器</h3>\n<img src=\"1732609710189.png\" alt=\"1732609710189\" style=\"zoom:50%;\" /> \n<h3 id=\"与非门-或非门\">与非门&amp;或非门</h3>\n<img src=\"1732609758887.png\" alt=\"1732609758887\" style=\"zoom:67%;\" /> \n<h3 id=\"传输门-异或门\">传输门&amp;异或门</h3>\n<p><strong>传输门</strong>：</p>\n<img src=\"1732609813663.png\" alt=\"1732609813663\" style=\"zoom:50%;\" /> \n<p><strong>异或门：</strong></p>\n<img src=\"1732609861836.png\" alt=\"1732609861836\" style=\"zoom:50%;\" /> \n<h3 id=\"OD门\">OD门</h3>\n<img src=\"1732609901856.png\" alt=\"1732609901856\" style=\"zoom:50%;\" /> \n<h3 id=\"三态门\">三态门</h3>\n<img src=\"1732609929273.png\" alt=\"1732609929273\" style=\"zoom:50%;\" /> \n<h1>TTL</h1>\n<h3 id=\"三极管结构和性质\">三极管结构和性质</h3>\n<p>原理随便看看差不多得了</p>\n<img src=\"1732610162586.png\" alt=\"1732610162586\" style=\"zoom:50%;\" /> \n<p><img src=\"image-20241126170414126.png\" alt=\"image-20241126170414126\" style=\"zoom:50%;\" /> <img src=\"image-20241126170425218.png\" alt=\"image-20241126170425218\" style=\"zoom:50%;\" /></p>\n<ul>\n<li>截止：VBE＜ Uon（0.7V）此时IB=0  则IC=0</li>\n<li>放大：VBE＞ Uon（0.7V）VCE ＞  VBE，IC= βIB（<strong>TTL电路不考虑放大</strong>）</li>\n<li>饱和：VBE ＞  Uon（0.7V）   VBE ＞ VCE</li>\n</ul>\n<img src=\"1732610239083.png\" alt=\"1732610239083\" style=\"zoom:50%;\" /> \n<p>C（Collect）：集电区低掺杂，面积大</p>\n<p>E（Emit）：发射区高掺杂，面积小</p>\n<p>B（Base）：基区薄低掺杂</p>\n<h3 id=\"反相器-2\">反相器</h3>\n<img src=\"1732610385227.png\" alt=\"1732610385227\" style=\"zoom:50%;\" /> \n<h3 id=\"与非门\">与非门</h3>\n<p>只修改了输入级而已</p>\n<img src=\"1732610411632.png\" alt=\"1732610411632\" style=\"zoom: 67%;\" /> \n<h3 id=\"或非门\">或非门</h3>\n<p>输入级x2，倒向级并联（只要有一个输入1，就会把上面的电压拉低）</p>\n<img src=\"1732610481414.png\" alt=\"1732610481414\" style=\"zoom:67%;\" /> \n<h3 id=\"异或门\">异或门</h3>\n<p>输入集得到 AB、A、B；反相级1得到 (A+B)‘，反相级2得到((A+B)’ + AB)’ = (A’B’+AB)’</p>\n<img src=\"1732610668536.png\" alt=\"1732610668536\" style=\"zoom:50%;\" /> \n<h3 id=\"OC门\">OC门</h3>\n<img src=\"1732610918350.png\" alt=\"1732610918350\" style=\"zoom: 67%;\" /> \n<h3 id=\"三态输出门\">三态输出门</h3>\n<img src=\"1732610949979.png\" alt=\"1732610949979\" style=\"zoom:50%;\" /> \n<h1>组合逻辑</h1>\n<h3 id=\"卡诺图\">卡诺图</h3>\n<ul>\n<li>卡诺图行和列元素 表格里相邻的逻辑上也是相邻的（00和01相邻，00和11不相邻）</li>\n<li>覆盖图中所有的1</li>\n<li>圈成的矩形数最少</li>\n<li>每个圈成的矩形尽可能大</li>\n<li>无关项可以当作1用</li>\n</ul>\n<img src=\"1732606969351.png\" alt=\"1732606969351\" style=\"zoom:50%;\" /> \n<h3 id=\"编码器\">编码器</h3>\n<p>8线-3线优先编码器</p>\n<img src=\"1732607575660.png\" alt=\"1732607575660\" style=\"zoom:50%;\" /> \n<p>8线-3线优先编码器</p>\n<p>工作时S‘=1，EX’=0</p>\n<img src=\"1732607647842.png\" alt=\"1732607647842\" style=\"zoom:50%;\" /> \n<h3 id=\"译码器\">译码器</h3>\n<h5 id=\"3线-8线译码器\">3线-8线译码器</h5>\n<img src=\"1732607777988.png\" alt=\"1732607777988\" style=\"zoom:50%;\" /> \n<p>工作时S1=1，S2‘=0，S3’=0</p>\n<img src=\"1732607819595.png\" alt=\"1732607819595\" style=\"zoom: 60%;\" /> \n<h5 id=\"二-十进制译码器\">二-十进制译码器</h5>\n<p>四位输入（A3 A2 A1 A0），输入Y0-Y9</p>\n<p>如果输入不在0-9范围，则输出的为伪码</p>\n<h3 id=\"例题哈哈\">例题哈哈</h3>\n<img src=\"1732608345823.png\" alt=\"1732608345823\" style=\"zoom:50%;\" /> \n<h3 id=\"数据选择器\">数据选择器</h3>\n<img src=\"1732608450997.png\" alt=\"1732608450997\" style=\"zoom:50%;\" /> \n<h3 id=\"加法器\">加法器</h3>\n<p>俩输入变量相加，CO输出进位，Y0-Y3输出</p>\n<h1>时序逻辑</h1>\n<h3 id=\"触发器\">触发器</h3>\n<h4 id=\"SR触发器\">SR触发器</h4>\n<p>我觉得不常用</p>\n<p>S=1，R=1，置1</p>\n<p>S=1，R=1，置1</p>\n<p>S=0，R=1，置0</p>\n<p>S=0，R=0，保持</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>Q</mi><mo>∗</mo></msup><mo>=</mo><mi>S</mi><mo>+</mo><msup><mi>R</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mi>Q</mi><mspace linebreak=\"newline\"></mspace><mi>S</mi><mi>R</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding=\"application/x-tex\">Q^* = S+R&#x27;Q\\\\\nSR=0\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.933136em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.738696em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.996332em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">Q</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span></span></span></span></span></p>\n<img src=\"1732588969478.png\" alt=\"1732588969478\" style=\"zoom:50%;\" />\n<h4 id=\"JK触发器\">JK触发器</h4>\n<p>两个0：保持</p>\n<p>两个1：翻转</p>\n<p>J1 K0：1</p>\n<p>J0 K1：0</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>Q</mi><mo>∗</mo></msup><mo>=</mo><mi>J</mi><msup><mi>Q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>+</mo><msup><mi>K</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q^*=JQ&#x27;+K&#x27;Q\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.933136em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.738696em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.996332em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.09618em;\">J</span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.996332em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">Q</span></span></span></span></span></p>\n<img src=\"1732589072817(1).png\" alt=\"1732589072817(1)\" style=\"zoom: 50%;\" />\n<h4 id=\"T触发器\">T触发器</h4>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>Q</mi><mo>∗</mo></msup><mo>=</mo><mi>T</mi><msup><mi>Q</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mo>+</mo><msup><mi>T</mi><mo mathvariant=\"normal\" lspace=\"0em\" rspace=\"0em\">′</mo></msup><mi>Q</mi></mrow><annotation encoding=\"application/x-tex\">Q^*=TQ&#x27;+T&#x27;Q\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.933136em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.738696em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.996332em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.996332em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.801892em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">Q</span></span></span></span></span></p>\n<p>T=0，保持</p>\n<p>T=1，翻转</p>\n<h4 id=\"D触发器\">D触发器</h4>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><msup><mi>Q</mi><mo>∗</mo></msup><mo>=</mo><mi>D</mi></mrow><annotation encoding=\"application/x-tex\">Q^*=D\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.933136em;vertical-align:-0.19444em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">Q</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.738696em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span></span></span></span></span></p>\n<p>D是啥下一状态就是啥</p>\n<h3 id=\"触发器图标\">触发器图标</h3>\n<p><strong>在CLK=1的全部时间，都会触发</strong>：什么特殊符号都没有</p>\n<img src=\"1732589271960.png\" alt=\"1732589271960\" style=\"zoom:50%;\" /> \n<p><strong>下降沿触发</strong>：神秘符号<strong>㇕</strong></p>\n<img src=\"1732589323078.png\" alt=\"1732589323078\" style=\"zoom:50%;\" /> \n<p><strong>上升沿触发</strong>：奇怪小三角</p>\n<img src=\"1732589371659.png\" alt=\"1732589371659\" style=\"zoom:50%;\" /> \n<h3 id=\"触发器例题\">触发器例题</h3>\n<img src=\"1732589539054.png\" alt=\"1732589539054\" style=\"zoom:50%;\" /> \n<h3 id=\"奇怪小常识\">奇怪小常识</h3>\n<p><strong>TTL触发器，输入端悬空时等效“1”</strong></p>\n<h3 id=\"状态机\">状态机</h3>\n<h4 id=\"Moore型\">Moore型</h4>\n<p>没有输入，自己跑着玩</p>\n<img src=\"1732590462360.png\" alt=\"1732590462360\" style=\"zoom:50%;\" />  \n<img src=\"1732590610745.png\" alt=\"1732590610745\" style=\"zoom: 67%;\" />   \n<h4 id=\"Mealy型\">Mealy型</h4>\n<p>有输入，随时以改变输入和输出，但是换状态只在触发沿换</p>\n<img src=\"1732590508635.png\" alt=\"1732590508635\" style=\"zoom:50%;\" /> \n<img src=\"1732590632242.png\" alt=\"1732590632242\" style=\"zoom:50%;\" /> \n<h4 id=\"解题方法\">解题方法</h4>\n<p>（针对上面第二题举例）</p>\n<p>1.驱动方程</p>\n<img src=\"1732590759694.png\" alt=\"1732590759694\" style=\"zoom:33%;\" /> \n<p>2.状态方程</p>\n<img src=\"1732590791393(1).png\" alt=\"1732590791393(1)\" style=\"zoom:33%;\" /> \n<p>3.输出方程</p>\n<img src=\"1732590804137.png\" alt=\"1732590804137\" style=\"zoom:33%;\" /> \n<p>4.写出状态转换表</p>\n<img src=\"1732590825713.png\" alt=\"1732590825713\" style=\"zoom:33%;\" /> \n<p>有一说一我觉得把Q1Q2A作为行合理点</p>\n<p>5.画状态图</p>\n<h3 id=\"常用时序逻辑原件\">常用时序逻辑原件</h3>\n<h4 id=\"移位寄存器\">移位寄存器</h4>\n<p>神秘力量让串行变成并行</p>\n<img src=\"1732591714358.png\" alt=\"1732591714358\" style=\"zoom:50%;\" /> \n<p>超级大合集</p>\n<img src=\"1732591755556.png\" alt=\"1732591755556\" style=\"zoom:50%;\" /> \n<h4 id=\"计数器\">计数器</h4>\n<p>2进制</p>\n<img src=\"1732601524132.jpg\" alt=\"1732601524132\" style=\"zoom:50%;\" /> \n<p>减法计数器反着转圈圈</p>\n<img src=\"image-20241126141221693.png\" alt=\"image-20241126141221693\" style=\"zoom:50%;\" /> \n<h4 id=\"计数器例题\">计数器例题</h4>\n<img src=\"1732771048791.png\" alt=\"1732771048791\" style=\"zoom: 50%;\" />  ",
            "tags": [
                "大学",
                "总结",
                "数字电路"
            ]
        },
        {
            "id": "https://blog.unfinished.top/2024/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
            "url": "https://blog.unfinished.top/2024/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/",
            "title": "操作系统复习",
            "date_published": "2024-06-06T05:52:20.000Z",
            "content_html": "<h1>1引论</h1>\n<p>中断是异步异常，可能随时发生（IO、始终信号）</p>\n<p><strong>软件和硬件都可以产生中断。</strong></p>\n<p>同步异常是相同条件下可重现的一场（内存错误，调试，被零除）</p>\n<p><strong>系统调用也视作同步异常，或trap（陷阱）</strong></p>\n<p><img src=\"1717557059107.png\" alt=\"1717557059107\"></p>\n<h4 id=\"系统\">系统</h4>\n<p>把用户提交的作业成批送入计算机，由作业调度程序自动选择运行。</p>\n<p>缩短作业交接时间、减少处理机空闲等待</p>\n<p>联机批处理系统在作业输入输出时，CPU忙等</p>\n<p>多道程序系统：允许多个程序同时进入内存，在CPU交替运行</p>\n<p>多道批处理系统：多道+成批；系统吞吐量大，资源利用率高；<strong>平均周转时间长，不能提供交互能力</strong>。<strong>成批：作业一旦进入系统，用户就不能直接干预其作业的运行</strong></p>\n<p>分时系统：CPU处理时间分为时间片，多用户，可交互，用户间相互独立，可对用户输入及时响应</p>\n<p>分布式系统：一体化系统，由网络底层支持，多台机器统一管理形成的单一透明系统</p>\n<p>实时系统：及时响应，安全可靠，整体性强</p>\n<h1>2启动</h1>\n<h3 id=\"BootLoader\">BootLoader</h3>\n<p>开机第一个程序</p>\n<p>常用U-Boot</p>\n<p>分为两部分，</p>\n<p>stage1：依赖于cpu体系结构的代码，用汇编语言来实现</p>\n<p>stage2：更多复杂功能，可读性、可移植性好，用C语言实现</p>\n<h2 id=\"MIPS，启动！\">MIPS，启动！</h2>\n<p>地址空间4G</p>\n<p>kuseg：2G用户态可用地址，需要被MMU转化</p>\n<p>kseg0：512M，对于无MMU的系统，用于存程序和数据，对于有MMU的系统，用于存操作系统核心，几乎全部kseg0都需要通过cache存取</p>\n<p>kesg1：512M，唯一能在系统启动时工作的地址空间，不需要cache</p>\n<p>kesg2：1G，需要MMU转换，只能在核心态使用</p>\n<h3 id=\"启动1\">启动1</h3>\n<p><img src=\"1713233950551.png\" alt=\"1713233950551\"></p>\n<h3 id=\"启动2\">启动2</h3>\n<p>调用board.c初始化</p>\n<p>内存划分、堆栈初始化，把代码从flash搬到ram上</p>\n<h3 id=\"引导Linux系统\">引导Linux系统</h3>\n<p>linux 内核启动的第一个阶段从 /arch/mips/kernel/head.s文件开始的</p>\n<p>内核入口kernel_entry()，先初始化内核堆栈，把内核映像的未初始化数据清零，跳转到**start_kernel()**启动</p>\n<h2 id=\"X86，启动！\">X86，启动！</h2>\n<p>比MIPS麻烦很多</p>\n<p>▪ 第一步——加载BIOS：硬件自检，读取启动顺序，</p>\n<p>▪ 第二步——读取MBR：主引导记录，在磁盘0磁头0磁道第一个扇区，包含了已安装的操作系统的启动加载器(BootLoader)和驱动器的逻辑分区信息</p>\n<p>▪ 第三步——Boot Loader：操作系统内核运行之前运行的一段小程序，初始化硬件，建立内存空间映射图</p>\n<p>▪ 第四步——加载内核：根据grab设定的路径读取内存映像并存在内存，初始化硬件设备，为内核程序执行建立环境</p>\n<p>▪ 第五步——用户层init依据inittab文件来设定运行等级：0，关机；1，单用户；2，无网络多用户；3，有网络多用户；4，保留未使用；5，有网络有X-Window支持的多用户；6，重启</p>\n<p>▪ 第六步－－init进程执行rc.sysinit：设定PATH、网络配置、启动swap分区，设定/proc</p>\n<p>▪ 第七步－－启动内核模块</p>\n<p>▪ 第八步－－执行不同运行级别的脚本程序</p>\n<p>▪ 第九步－－执行/etc/rc.d/rc.local：Linux留给用户自己个性化设置和启动的地方</p>\n<p>▪ 第十步－－执行/bin/login程序，进入登录状态</p>\n<h1>3内存</h1>\n<p>Elf头</p>\n<p>e_ident Elf标志</p>\n<p>e_type 文件类型</p>\n<p>e_phoff:程序表头</p>\n<p>e_shoff节表头</p>\n<p><img src=\"1713334808476.png\" alt=\"1713334808476\"></p>\n<p>栈：存放、交换临时数据</p>\n<p>堆：存放进程运行中动态分配的内存段</p>\n<p>地址空间：逻辑地址的集合</p>\n<p>存储空间：物理地址的集合</p>\n<h2 id=\"内存分配\">内存分配</h2>\n<h3 id=\"u-顺序搜索-u\"><u>顺序搜索</u></h3>\n<h4 id=\"FitrstFit\">FitrstFit</h4>\n<p>空白区域按地址递增顺序连接，查找时选择第一块满足需求的块</p>\n<h4 id=\"NextFit\">NextFit</h4>\n<p>空白区域构成循环链，每次查找从上次查找结束的块开始，找到足够大的停</p>\n<h4 id=\"BestFit\">BestFit</h4>\n<p>选择大小满足要求且最接近于需求的存储</p>\n<h4 id=\"WorstFit\">WorstFit</h4>\n<p>寻找最大空白区</p>\n<h3 id=\"索引搜索\">索引搜索</h3>\n<h4 id=\"快速适应算法（分类搜索法）\">快速适应算法（分类搜索法）</h4>\n<p>把空闲区按照容量大小分类，经常用到长度的空闲区设立单独的空闲区链表</p>\n<h3 id=\"\"></h3>\n<h3 id=\"内部碎片\">内部碎片</h3>\n<p>分配给作业存储空间的没利用部分。入固定分区中的碎片。无法被整理，作业完成后释放</p>\n<p>出现原因：<strong>单一连续区存储管理、固定分区存储管理</strong></p>\n<h3 id=\"外部碎片\">外部碎片</h3>\n<p>无法利用的小的空闲分区。需要用紧凑技术整理</p>\n<h4 id=\"紧凑技术\">紧凑技术</h4>\n<p>需要使用动态重定位</p>\n<h3 id=\"覆盖\">覆盖</h3>\n<p>把程序划分一系列功能相对独立的程序，执行时不要求装入一块内存</p>\n<p>部分程序跑完再被下一部分覆盖</p>\n<h3 id=\"交换\">交换</h3>\n<p>把暂时不用的程序和数据从主存放到辅存，再把要用到移到主存</p>\n<h2 id=\"页式内存管理\">页式内存管理</h2>\n<p>页：把作业的地址空间分成大小相同的片</p>\n<p>页框Frame：与页面相同大小的片，是主存的存储空间</p>\n<p>逻辑地址32位</p>\n<p>物理地址22位</p>\n<p>一块4KB（12位块地址）</p>\n<h3 id=\"纯分页系统\">纯分页系统</h3>\n<p>必须把所有页一次撞到主存页框，如果页框不足，等待。</p>\n<h3 id=\"TLB\">TLB</h3>\n<p>CPU 产生逻辑地址的页号，首先在快表中寻找若命中就找出其对应的物理块；若未命中，再到页表中找其对应的物理块，并将之复制到快表。若快表中内容满，则按某种算法淘汰某些页</p>\n<p><strong>每个TLB条目中还保存地址空间标识码ASID</strong>用于辨识进程</p>\n<p>有效内存访问时间 = <em><em>（TLB查询时间+单次内存访问时间）</em> TLB命中率 + （TLB查询时间 + 2 * 单次内存访问时间）</em> （1 - TLB命中率）**</p>\n<h4 id=\"哈希页表\">哈希页表</h4>\n<p>虚拟页码作为哈希值，用虚拟页号与哈希链表每个元素第一个域比较，如果匹配则与相应帧号形成层物理地址</p>\n<h2 id=\"段式内存管理\">段式内存管理</h2>\n<p>一个作业的地址空间分段，每一段都连续，首地址为0</p>\n<p>段表寄存器内容：段表始值、段表长度</p>\n<ol>\n<li>\n<p>根据指令的性质来确定应该使用哪一个段寄存器（Segment Selector），例如转移指令中的地址在代码段，而取数据指令中的地址在数据段；</p>\n</li>\n<li>\n<p>根据段存器的内容，找到相应的“地址段描述结构“（Segment Descriptor），段描述结构都放在一个表（Descriptor Table）中（GDT或LDT等），而表的起始地址保存在GDTR、LDTR等寄存器中。</p>\n</li>\n<li>\n<p>从地址段描述结构中找到基地址（Base Address）；</p>\n</li>\n<li>\n<p>将指令发出的地址作为位移，与段描述结构中规定的段长度相比，看看是否越界；</p>\n</li>\n<li>\n<p>根据指令的性质和段描述符中的访问权限来确定是否越权；</p>\n</li>\n<li>\n<p>将指令中发出的地址作为位移，与基地址相加而得出线性地址（Linear Address）。</p>\n</li>\n</ol>\n<h2 id=\"虚拟存储\">虚拟存储</h2>\n<p>为每个进程提供了一个大的、一致的、连续可用的和私有的地址空间</p>\n<p>用户可执行文件、共享库的类型是file backed，磁盘上有记录</p>\n<p>堆栈的类型是anonymous，磁盘上没记录</p>\n<h4 id=\"FIFO\">FIFO</h4>\n<p>先进的先被替换</p>\n<h4 id=\"Second-Chance\">Second Chance</h4>\n<p>被访问过会被移到FIFO的队列头</p>\n<h4 id=\"Clock\">Clock</h4>\n<p>缺页时先检查指针指向的元素，若被访问过，删除访问标志，指针指向下一个；若未被访问过，换掉当前元素，设置访问标志，指针指向下一个</p>\n<p>若不缺页，访问的页面访问位置1，指针不动</p>\n<h4 id=\"LRU\">LRU</h4>\n<p>每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。栈底始终是最近最少使用页面的页面号</p>\n<p>若换出页面是file backed类型：</p>\n<p>1.且未被修改，则直接丢弃，因为磁盘上保存有相同的副本</p>\n<p>2.被修改，直接写回原有位置</p>\n<p>若换出页面是anonymous类型：</p>\n<p>1.第一次换出/被修改写入Swap区，</p>\n<p>2.若不是第一次且没被修改，丢弃</p>\n<h1>进程</h1>\n<p>进程时分配资源的基本单位</p>\n<p>由进程控制块（PCB）、程序、数据构成</p>\n<p>进程控制块包括：进程标识符、程序和数据地址、当前状态、现场保护区、同步与同步机制（信号量），优先级，资源清单，链接字</p>\n<h4 id=\"进程特征\">进程特征</h4>\n<p><strong>并发：体现在进程的执行是间断性的</strong></p>\n<p><strong>共享：体现在进程/线程之间的制约性</strong></p>\n<p><strong>不确定性：进程执行的结果与其执行的相对速度有关，是不确定的</strong></p>\n<h4 id=\"并发-并行\">并发/并行</h4>\n<p>并发是一起执行</p>\n<p>并行要求再不同处理器上一起执行</p>\n<h4 id=\"作业\">作业</h4>\n<p>是用户需要完成某项任务，要求计算机做的工作的集合</p>\n<p>一个作业可以多个进程</p>\n<p>由程序、数据、操作说明构成</p>\n<h4 id=\"原语\">原语</h4>\n<p>由若干条指令所组成的指令序列，来实现某个特定的操作功能</p>\n<h3 id=\"状态\">状态</h3>\n<p><img src=\"1713432511952.png\" alt=\"1713432511952\"></p>\n<h4 id=\"进程上下文切换\">进程上下文切换</h4>\n<p>通常由调度器执行，保存进程执行断点，切换内存映射</p>\n<h4 id=\"陷入-退出内核\">陷入/退出内核</h4>\n<p>CPU改变状态，由中断、异常、Trap引起，需要保存执行现场</p>\n<h2 id=\"线程\">线程</h2>\n<p><strong>进程包含了两个概念：资源拥有者和可执行单元</strong></p>\n<p><strong>现代操作系统将资源拥有者称为进程</strong></p>\n<p><strong>可执行单元称为线程</strong></p>\n<p><strong>线程是进程中的一个实体</strong>，是一个CPU调度和分派的单位，只有少量资源，与其他进程共享资源</p>\n<p>一个进程可以拥有多个线程，而一个线程同时只能被一个进程所拥有</p>\n<p><strong>进程是资源分配的基本单位，</strong></p>\n<p><strong>线程是处理机调度的基本单位，所有的线程共享其所属进程的所有资源与代码</strong></p>\n<h4 id=\"用户级线程\">用户级线程</h4>\n<p>线程在用户空间，内核不可感知，线程切换与内核无关，线程调度由应用决定，可运行在任何操作系统</p>\n<p><img src=\"1716533696086.png\" alt=\"1716533696086\"></p>\n<h4 id=\"内核级线程\">内核级线程</h4>\n<p>内核可感知，可以在多个树立起上调度一个进程的多个线程，阻塞发生在线程级别，效率较低</p>\n<p><img src=\"1716534608778.png\" alt=\"1716534608778\"></p>\n<h4 id=\"混合线程\">混合线程</h4>\n<p><img src=\"1716534628762.png\" alt=\"1716534628762\"></p>\n<h2 id=\"管道\">管道</h2>\n<p>对于管道两端的进程，管道就是一个文件</p>\n<p><strong>只存在在内存</strong></p>\n<h3 id=\"无名管道\">无名管道</h3>\n<p>半双工，数据单向流动，<strong>只能用于父子进程或者兄弟进程</strong></p>\n<p>单独构成一种独立文件系统，只存在在内存中</p>\n<h3 id=\"有名管道\">有名管道</h3>\n<p>有名字，没亲缘关系的进程也能用</p>\n<h3 id=\"FIFO-2\">FIFO</h3>\n<p>不同于管道之处在于它提供一个路径名与之关联以FIFO的文件形式存在于文件系统中，调用路径就能用</p>\n<p>先进先出</p>\n<h3 id=\"消息传递\">消息传递</h3>\n<p>seed(destination,&amp;msg) receive(source,&amp;msg)</p>\n<h1>调度</h1>\n<p>进程切换：</p>\n<ol>\n<li>保存处理器上下文</li>\n<li>用新状态和其他相关信息更新正在运行进程的PCB</li>\n<li>把进程移到合适的队列-就绪、阻塞</li>\n<li>选择另一个要执行的进程</li>\n<li>更新选中进程的PCB</li>\n<li>从选中进程重装入CPU上下文</li>\n</ol>\n<p>高级调度：从用户工作流的角度，对作业的调度，时间上通常是分钟</p>\n<p>中级调度：内外存交换，从存储器资源的角度，将当前需要的部分换到内存</p>\n<p>低级调度：从CPU资源的角度，执行的单位，时间上通常是毫秒</p>\n<h3 id=\"关键术语\">关键术语</h3>\n<p><strong>周转时间</strong>：作业从提交到完成所经历的时间</p>\n<p><strong>响应时间</strong>：用户输入请求到系统首次响应的时间</p>\n<p><strong>吞吐量</strong>：单位时间内所完成的作业数</p>\n<p><strong>批处理进程</strong>：无需与用户交互，无需很快的响应</p>\n<p>**交互式进程：**与用户交互频繁，响应时间短</p>\n<p><strong>实时进程</strong>：有实施要求，不能被低优先级进程阻塞，响应时间短且稳定</p>\n<h3 id=\"吞吐量、平均等待时间和平均周转时间\">吞吐量、平均等待时间和平均周转时间</h3>\n<p>吞吐量 =  作业数 / 总执行时间，（单位时间CPU完成作业数）</p>\n<p>周转时间 = 完成时刻 - 提交时刻</p>\n<p>带权周转时间 = 周转时间 / 服务时间（执行时间）</p>\n<p>平均周转时间= 总周转时间 / 作业数量</p>\n<p>平均带权周转时间 = 总带权周转时间 / 作业数量</p>\n<h2 id=\"批处理系统的调度算法\">批处理系统的调度算法</h2>\n<h3 id=\"先来先服务FCFS\">先来先服务FCFS</h3>\n<p>顾名思义，利于长作业，不利于短作业；利于CPU繁忙的作业，不利于I/O繁忙的作业</p>\n<h3 id=\"短作业优先SJF\">短作业优先SJF</h3>\n<p>先把短的优先处理，后来的短作业不抢占正在执行的。<strong>提高系统的吞吐量，但对长作业非常不利</strong></p>\n<h3 id=\"最短剩余时间优先FRTF\">最短剩余时间优先FRTF</h3>\n<p>抢占式，一个新旧徐的进程如果比当前进程完成时间更短，直接抢占。<strong>可能使长任务长时间得不到运行</strong></p>\n<h3 id=\"最高响应比优先HRRF\">最高响应比优先HRRF</h3>\n<p>每次选择作业投入运行时，先计算后备作业队列每个作业的响应比RP，选择最大的执行。</p>\n<p>RP = ( 已等待时间+要求运行时间 ) / 要求运行时间</p>\n<h2 id=\"交互式系统的调度算法\">交互式系统的调度算法</h2>\n<h3 id=\"时间片轮转RR\">时间片轮转RR</h3>\n<p>所有的就绪进程按照FCFS原则，排成1个队列；从受进程开始执行1个时间片，1个时间片结束时钟中断，将其送到就绪队列末尾</p>\n<p>T(响应时间) = N(进程数目) * q(时间片)</p>\n<h3 id=\"多级队列MQ\">多级队列MQ</h3>\n<p>根据作业或进程的性质或类型的不同，将就绪队列再分为若干个子队列。不同队列优先级、时间片长度、调度策略等都可不同</p>\n<h3 id=\"多级反馈队列MFQ\">多级反馈队列MFQ</h3>\n<p>设置多个就绪队列，分别赋予不同的优先级（逐级降低）</p>\n<p>新进程进入内存后，先投入队列1的末尾，按FCFS算法调度</p>\n<p>若按队列1一个时间片未能执行完，则降低投入到队列2的末尾</p>\n<p>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行</p>\n<p><strong>如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾</strong></p>\n<h3 id=\"优先级置顶\">优先级置顶</h3>\n<p>进入临界区的进程给予最高优先级</p>\n<h3 id=\"优先级继承\">优先级继承</h3>\n<p>高优先级A进入临界区发现资源被低优先级的C占用，可以将A阻塞，并把A的优先级先继承给C，直到C退出临界区</p>\n<h2 id=\"实时系统的调度算法\">实时系统的调度算法</h2>\n<h3 id=\"静态表调度\">静态表调度</h3>\n<p>通过对所有周期性任务分析，事先确定的固定调度方案。不灵活。</p>\n<h3 id=\"单调速率调度\">单调速率调度</h3>\n<p><strong>单处理器下的最优静态调度算法</strong></p>\n<p>任务的周期越小，其优先级越高。优先级最高的任务最先被调度，优先级一样随机选择</p>\n<h3 id=\"最早截止时间优先算法\">最早截止时间优先算法</h3>\n<p>任务的绝对截止时间越早，其优先级越高。</p>\n<h2 id=\"多处理机调度\">多处理机调度</h2>\n<p>非对称式多处理系统：主－从处理机系统，由主处理机管理一个公共就绪队列</p>\n<h3 id=\"对称式多处理系统\">对称式多处理系统</h3>\n<p>多处理器系统中，各个处理器的地位相同。</p>\n<p>静态分配：<strong>每个CPU设立一个就绪队列</strong></p>\n<p>动态分配：公共就绪队列</p>\n<p>自调度：<strong>各个CPU采用公共就绪队列，每个处理及选择最适合的进程执行</strong></p>\n<p>成组调度：<strong>将一个进程中的一组线程，每次分派时同时到一组处理机上执行</strong></p>\n<p>专用处理机调度：<strong>为进程中的每个线程都固定分配一个CPU，直到该线程执行完成</strong></p>\n<h1>死锁</h1>\n<h3 id=\"发生的四个条件\">发生的四个条件</h3>\n<ul>\n<li>**互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</li>\n<li>**请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li>\n<li>**不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>\n<li>**环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</li>\n</ul>\n<h3 id=\"活锁\">活锁</h3>\n<p>执行者没被阻塞，但忧郁某些条件没满足，一直重复尝试。有可能自行解开</p>\n<h3 id=\"饥饿\">饥饿</h3>\n<p>某些资源分配策略不公平导致部分进程长时间等待。</p>\n<h2 id=\"处理死锁\">处理死锁</h2>\n<h3 id=\"死锁预防（静态）\">死锁预防（静态）</h3>\n<p>打破互斥条件（无法实现）、打破占有申请条件（不太好）</p>\n<p>打破不可剥夺条件（降低性能），</p>\n<p>打破循环等待条件：事先编好号，进程占用了大号资源禁止申请小号资源，但可以申请更大号</p>\n<h3 id=\"死锁避免（动态）\">死锁避免（动态）</h3>\n<p>判断操作是否会死锁，如果会则加以避免</p>\n<h4 id=\"银行家算法\">银行家算法</h4>\n<p>n为进程数量，m为资源类型数量</p>\n<p>可用资源矩阵Available ：m维</p>\n<p>最大需求矩阵Max ：n x m维 最大需求</p>\n<p>分配矩阵Allocation ： n x m 已分配的资源数量</p>\n<p>需求矩阵Need ： n x m 进程尚需的资源数</p>\n<p>设Request式进程P[j] 的请求向量</p>\n<p>1.若Request[i] &gt;= Need[i] ，出错</p>\n<p>2.若Request[i] &gt;= Available[i] ，出错</p>\n<p>3.分配，Available -= Request; Allocation += Request; Need -= Request;</p>\n<p>4.执行安全性算法，检查是否安全，如果不安全则不分配，安全就分配</p>\n<h4 id=\"安全性算法\">安全性算法</h4>\n<p>1.设置向量Work = Available；设置向量Finish[i] = false，当有足够资源可以分配被该进程，Finish[i] = true;</p>\n<p>2.从进程集合中找到Finish[i] = false,Need[i]&lt;=Work[i],如果找到,执行3;找不到,执行4</p>\n<p>3.释放进程资源：Work+=Allocation；Finish[i] = true；重复2.</p>\n<p>4.如果所有Finish[i] = true,安全；否则不安全</p>\n<h2 id=\"死锁检测\">死锁检测</h2>\n<h4 id=\"资源分配图\">资源分配图</h4>\n<p>化简：把请求边改为分配边，删除已经能运行的节点的所有边</p>\n<p>死锁定理：如果t时刻资源分配图不可完全化简，则会死锁</p>\n<h4 id=\"解除死锁\">解除死锁</h4>\n<p>1.撤销进程：逐个撤销进程，知道有足够资源解锁死锁</p>\n<p>2.剥夺资源：挂起某些进程，剥夺其资源</p>\n<h1>IO管理</h1>\n<p>IO端口每个寄存器有唯一地址</p>\n<p>内存映射编址：控制器内存/寄存器作为物理内存空间的一部分</p>\n<p>IO独立编址：编址在内存地址外</p>\n<h2 id=\"IO控制技术\">IO控制技术</h2>\n<h3 id=\"程序控制IO\">程序控制IO</h3>\n<p>轮询、查询方式IO；<strong>CPU代表进程向I/O模块发出指令</strong>，<strong>然后进入轮询状态</strong>。<strong>直到操作完成之后进程才能够继续执行</strong></p>\n<h3 id=\"中断驱动\">中断驱动</h3>\n<p>IO操作结束后，由设备控制器<strong>主动通知CPU结束</strong>。</p>\n<h3 id=\"DMA（直接存储器访问）\">DMA（直接存储器访问）</h3>\n<p>由专门的控制器来完成数据从内存到设备或是从设备到内存的直接传输工作</p>\n<p>由程序设置DMA控制器中的若干寄存器值然后发起I/O操作;DMA控制器完成内存与外设的成批数据交换;在操作完成时由DMA控制器向CPU发出中断</p>\n<p>CR(命令/状态寄存器)：用于接受从CPU发送来的IO指令</p>\n<p>MAR（内存地址寄存器）：在输入时，它存放的数据从设备传送到内存的其实目标地址</p>\n<p>DR（数据寄存器）：用于暂存从设备到内存</p>\n<p>DC（数据计数器）：存放本次CPU要读或写的字节数</p>\n<h3 id=\"通道\">通道</h3>\n<p>通道是一个特殊功能的处理器，有自己的指令和程序专门负责数据传输</p>\n<p>CPU将传输控制的功能下放给通道后，只负责数据处理。</p>\n<p>DMA要由CPU控制数据的传送方向、存放数据的内存起始地址和数据块长度</p>\n<p>但是通道自己就能处理</p>\n<h3 id=\"设备分类\">设备分类</h3>\n<p>按照数据组织：</p>\n<p>块设备：数据块为单位，传输速率高，可寻址；</p>\n<p>字符设备：字符为单位传输速率低，不可寻址</p>\n<p>按照速度：低速（键鼠）、中速（打印机）、高速（磁盘）</p>\n<h3 id=\"IO管理目标和任务\">IO管理目标和任务</h3>\n<ol>\n<li>按照用户请求，控制设备操作，完成I/O设备与内存间的数据交换，最终完成用户的I/O请求</li>\n<li>建立方便、统一的独立于设备的接口</li>\n<li>充分利用各种技术提高CPU与设备、设备与设备之间的并行工作能力，充分利用资源</li>\n<li>保护</li>\n</ol>\n<h4 id=\"LUT\">LUT</h4>\n<p>逻辑设备表：逻辑设备名、物理设备名、设备驱动程序入口地址</p>\n<h4 id=\"设备驱动程序\">设备驱动程序</h4>\n<p>内核的一部分，为内核和文件提供接口</p>\n<h2 id=\"设备分配\">设备分配</h2>\n<p>DCT（设备控制表），每个设备一张，记录类型、标识符、状态、只想控制器的指针、重复执行次数、设备请求队列头指针</p>\n<p>控制器控制表（COCT）描述IO控制器配置和状态，通道控制表（CHCT）</p>\n<p>系统设备表（SDT），反应资源状态</p>\n<h3 id=\"SPOOLing技术\">SPOOLing技术</h3>\n<p>假脱机技术，专门利用一道程序完成IO操作。虚拟IO。</p>\n<p>SPOOLing程序预先从外设读取数据并加以缓冲，在以后需要的时候输入到应用程序；接受应用程序的输出数据并加以缓冲，在以后适当的时候输出到外设</p>\n<p>程序虚拟IO操作与实际IO操作分离，可共享原本独享设备</p>\n<h2 id=\"缓冲\">缓冲</h2>\n<p>输出：T ；传送：M ；处理：C</p>\n<h4 id=\"单缓冲\">单缓冲</h4>\n<p>T和C可以并行</p>\n<p>处理一块数据的时间约为Max（C，T）+M</p>\n<p><img src=\"1717313218710.png\" alt=\"1717313218710\"></p>\n<h4 id=\"双缓冲\">双缓冲</h4>\n<p>T和M、C可以并行</p>\n<p>有俩缓冲，处理一块数据的时间约为Max（C+M，T）</p>\n<p><img src=\"1717313230574.png\" alt=\"1717313230574\"></p>\n<h4 id=\"环形缓冲\">环形缓冲</h4>\n<p>多个<strong>缓冲区</strong>，缓冲区分为空缓冲区R，装满的缓冲区G，正在使用的工作缓冲区C</p>\n<p>多个<strong>指针</strong>，计算进程下一个可用缓冲区Nextg，输入进程下次可用缓冲区Nexti，计算进程正在使用缓冲区Current</p>\n<h4 id=\"缓冲池\">缓冲池</h4>\n<p>包含空缓冲区，装满输入缓冲区，装满输出缓冲区</p>\n<p>相同类型缓冲区连成<strong>链表</strong>，emq、inq、outq</p>\n<h2 id=\"IO性能\">IO性能</h2>\n<p><strong>使CPU利用率尽可能不被I/O降低</strong>；<strong>使CPU尽可能摆脱I/O</strong></p>\n<p><img src=\"1717314873536.png\" alt=\"1717314873536\"></p>\n<h1>磁盘管理</h1>\n<p><strong>磁盘是块设备</strong></p>\n<p>扇区，磁道，柱面</p>\n<p>磁盘扇区一部分存储硬盘固件，剩下的是工作区（硬盘标定容量的扇区）和保留区（剩下的）</p>\n<h4 id=\"MBR\">MBR</h4>\n<p><strong>硬盘的0柱面、0磁头、1扇区称为主引导扇区（MBR）</strong>，512字节</p>\n<p>前446字节为启动代码及数据</p>\n<p>之后则是分区表（DPT）：<strong>分区表由四个分区项组成，每个分区项数据为16字节录了启动时需要的分区参数</strong></p>\n<p>后面紧接着两个字节AA和55被称为幻数。BOIS读取MBR的时候总是检查最后是不是有这两个幻数,如果没有就被认为是一个没有被分区的硬盘</p>\n<p><strong>一个硬盘主分区至少有1个，最多4个，扩展分区可以没有，最多1个</strong></p>\n<p><strong>主分区只能有一个是激活的</strong></p>\n<p><img src=\"1716208805674.png\" alt=\"1716208805674\"></p>\n<h4 id=\"时间计算\">时间计算</h4>\n<p>寻道时间Ts = mn + s；m是常熟，n是移动了n条磁道，s是启动时间</p>\n<p>旋转延迟 Tr = 1 / 2r；r是转速</p>\n<p>传输时间 Tt = b/rN ；b是读写的字节数，r是转速，N是磁道上字节数</p>\n<p>访问时间 Ta = Ts + Tr + Tt</p>\n<h2 id=\"调度算法\">调度算法</h2>\n<p>FCFS：先来先服务：公平、简单，<strong>寻道距离大</strong></p>\n<p>SSTF：最短寻道时间优先；优先选择距离当前磁头最近的：<strong>可能饥饿</strong></p>\n<p>SCAN：扫描算法；按一个方向到头，然后调转继续（入50→0→67→199）<strong>不利于远离磁头一端的访问</strong></p>\n<p>CSCAN：循环扫描，按一个方向到头，立刻跳到0继续同方向扫</p>\n<p>CLOOK：类似CSCAN，但是到最外侧的请求后就立刻返回，而不是到最外侧柱面</p>\n<h2 id=\"磁盘空间管理\">磁盘空间管理</h2>\n<p><strong>位图</strong>：每个物理块对应一位，返回对应物理块号。0为分配的，1为空闲</p>\n<p>空闲表：所有空闲块记录在一个表。记录起始块号、空闲块数量</p>\n<p>成组链接法：空闲块链表</p>\n<h2 id=\"RAID\">RAID</h2>\n<p>NOR Flash比NAND Flash快，单连续大数据传输二者差别不大，但是NOR贵</p>\n<p>RAID：廉价冗余磁盘阵列</p>\n<h4 id=\"RAID0\">RAID0</h4>\n<p>条带化存储，N个磁盘组成的RAID0理论上读写速度是N倍</p>\n<h4 id=\"RAID1\">RAID1</h4>\n<p>镜像存储。<strong>通过磁盘数据镜像实现数据冗余</strong>。在原始数据繁忙时，可以从镜像中拷贝，可以提高性能。成本最高。安全性高。可以通过镜像恢复丢失的数据</p>\n<h4 id=\"RAID2\">RAID2</h4>\n<p>海明码校验条带存储</p>\n<p>将数据条块化地分布在不同硬盘，条块单位为位或字节，使用海明码提供错误检查和恢复</p>\n<p><strong>并行存取，各个驱动器同步工作</strong>，<strong>数据传输率高</strong></p>\n<p>需要多个磁盘来存放海明校验码信息多磁盘易出错环境中的有效选择，<strong>并未被广泛应用</strong></p>\n<h4 id=\"RAID3\">RAID3</h4>\n<p>奇偶校验条带存储，共享校验盘，数据条带存储单位为**<u>字节</u>**</p>\n<p><strong>类似RAAID2，但是使用奇偶校验。对于大量的连续数据可提供很好的传输率。但对于随机数据来说，奇偶盘会成为写操作的瓶颈</strong></p>\n<p><strong>读写要访问组中所有盘</strong></p>\n<p>先将分布在各个数据盘上的一组数据加起来，将和存放在冗余盘上。只要将冗余盘上的和减去所有正确盘上的数据，得到的差就是出错的盘上的数据</p>\n<p><strong>缺点：恢复时间较长</strong></p>\n<h4 id=\"RAID4\">RAID4</h4>\n<p>奇偶校验条带存储，共享校验盘，数据条带存储单位为**<u>块</u>**</p>\n<p><strong>冗余代价与RAID3相同</strong>，<strong>访问数据的方法与RAID3不同</strong></p>\n<h4 id=\"RAID5\">RAID5</h4>\n<p>奇偶校验条带存储，校验数据分布式存储，数据条带存储单位为**<u>块</u>**</p>\n<p>所有盘上交叉存取数据和奇偶校验信息。<strong>读/写指针可同时对阵列设备进行操作，提供了更高的数据流量</strong></p>\n<p>写损失：每次写都要产生四次读写操作：读取旧的数据和奇偶信息；写新的数据和奇偶信息</p>\n<p><strong>当两块盘坏掉的时候，整个RAID的数据失效</strong></p>\n<h4 id=\"RAID6\">RAID6</h4>\n<p>奇偶校验条带存储，<strong>两个分布式存储的校验数据</strong>，数据条带存储单位为**<u>块</u>**</p>\n<p>数据可靠性高，但是要更多冗余空间，更大的写损失</p>\n<p><img src=\"1717320020254.png\" alt=\"1717320020254\"></p>\n<ol>\n<li>\n<p>条带化：一个字节块可能存放在多个数据盘上</p>\n<ul>\n<li>\n<p>优点：并行存取，性能好，磁盘负载均衡</p>\n</li>\n<li>\n<p>缺点：可靠性、不同IO请求需要排队</p>\n</li>\n</ul>\n</li>\n<li>\n<p>镜像：数据完全拷贝一份</p>\n<ul>\n<li>\n<p>优点：可靠性</p>\n</li>\n<li>\n<p>缺点：存储开销</p>\n</li>\n</ul>\n</li>\n<li>\n<p>校验：数据通过某种运算（异或）得出，用以检验该组数字的正确性</p>\n<ul>\n<li>\n<p>优点：可靠性，快速恢复</p>\n</li>\n<li>\n<p>缺点：开销</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"提高IO速度\">提高IO速度</h3>\n<p>提前读取、延迟写</p>\n<p>虚拟盘（RAM）</p>\n<h3 id=\"磁盘管理实例\">磁盘管理实例</h3>\n<p><strong>WINDOWS 2000 把基于MS—DOS分区方式的盘称为基本盘</strong></p>\n<p><strong>动态盘支持创建新的多分区卷</strong></p>\n<p><strong>基本盘的多分区卷的配置信息保存在注册表中。动态盘的多分区卷的配置信息保存在磁盘中</strong></p>\n<p>系统卷是WINDOWS2000存放引导文件的地方，包括引导程序（NTLDR）和NTDETECT</p>\n<p>引 导 卷 是 WINDOWS2000 存 放 系 统 文 件 ， 如NTOSKRNL.EXE核心内核文件的地方</p>\n<h1>文件系统</h1>\n<p>操作系统中与文件管理有关的那部分软件和被管理的文件以及实施管理所需要的数据结构的总体</p>\n<p>为了对系统管理者和用户提供透明存取</p>\n<p>文件系统接口：命令行接口、程序接口</p>\n<p>对象操作管理的软件集合：对存储空间、目录的管理、逻辑地址物理地址转换、读写管理、共享保护功能</p>\n<p>管理对象：文件、目录、磁盘存储空间</p>\n<p>流式文件：构成文件基本单位为字符</p>\n<p>记录式文件：由若干记录组成，按照记录读写、查找</p>\n<p>目录内容：文件名、别名、文件类型、地址星系、访问控制信息、使用信息</p>\n<h2 id=\"文件系统实现\">文件系统实现</h2>\n<h3 id=\"文件\">文件</h3>\n<h4 id=\"文件控制块FCB内容\">文件控制块FCB内容</h4>\n<p>基本信息：文件名、物理位置、文件逻辑结构、文件物理结构</p>\n<p>访问控制信息：文件所有者（创建文件的用户）、访问权限</p>\n<p>使用信息：创建时间，上一次修改时间、当前使用信息</p>\n<h4 id=\"连续结构\">连续结构</h4>\n<p><img src=\"1717407058851.png\" alt=\"1717407058851\"></p>\n<p>优点：结构简单，不需要额外空间开销，支持顺序和随机存取，连续存取速度快</p>\n<p>缺点：文件长度一经笃定不易改变，不利于文件动态增加修改</p>\n<h4 id=\"串联结构\">串联结构</h4>\n<p><img src=\"1717407270584.png\" alt=\"1717407270584\"></p>\n<p>优点：空间利用率高，文件动态扩充容易，顺序存取效率高</p>\n<p>缺点：随机存取效率低。有可靠性问题，指针耗费空间</p>\n<h4 id=\"索引结构\">索引结构</h4>\n<p><img src=\"1717407550816.png\" alt=\"1717407550816\"></p>\n<p>优点：能顺序存取、随机存取、动态增长</p>\n<p>缺点：额外空间开销</p>\n<h3 id=\"目录\">目录</h3>\n<p>根据用户给出路径名，迅速定位到文件控制块</p>\n<p>目录项= 文件名+（FCB或FCB的地址）</p>\n<p>长文件名：固定目录项，长度可变的文件名放在目录文件末尾</p>\n<p><img src=\"1717420489566.png\" alt=\"1717420489566\"></p>\n<h3 id=\"硬链接软连接\">硬链接软连接</h3>\n<p>硬链接：俩都指向同一个Inode</p>\n<p>软连接：重定向到对应Inode</p>\n<h3 id=\"文件保护\">文件保护</h3>\n<p>建立副本：简单、开销大</p>\n<p>定时转储</p>\n<p>磁盘块一致性检查：检查记录在文件和空闲块中出现的次数，计数器</p>\n<p>文件一致性：检查记录在i节点和文件目录中引用的次数</p>\n<h3 id=\"提高性能\">提高性能</h3>\n<p>目录项（FCB）分解、当前目录、磁盘碎片整理、块高速缓存、磁盘调度、提前读取、合理分配磁盘空间、信息的优化分布、RAID技术等</p>\n<h3 id=\"基于日志的文件系统\">基于日志的文件系统</h3>\n<p>数据结构：inode、inode map、段（包含数据块、元数据、日志）、段摘要（每一个数据块的信息）、段使用情况表（段数据块中有效数据量）</p>\n<p><img src=\"1717422006392.png\" alt=\"1717422006392\"></p>\n<p>写操作会在内存段segment缓冲区加入新数据快，segment写满后把数据写到磁盘</p>\n<p>失效恢复：回滚恢复到最后一个检查点</p>\n<p>清理：整理碎片</p>\n<h2 id=\"文件系统实例\">文件系统实例</h2>\n<p><strong>FAT系统</strong></p>\n<p>簇：若干个扇区组成，从0编号</p>\n<p>文件系统数据记录在引导扇区中。文件分配表（FAT）用于描述簇的分配和下一簇号</p>\n<p>FAT表项2字节，目录项32字节</p>\n<p><strong>UFS系统</strong></p>\n<p>多级文件目录，有常规文件、目录文件、特殊文件</p>\n<p><strong>EXT2</strong></p>\n<p>磁盘划分成相同大小的块，组成若干块组，每个块组有一个inode</p>\n<p><strong>VFS</strong></p>\n<p>虚拟文件系统：设备、索引节点编号、模式、用户标识符、块大小、时间</p>\n<p>1.寻找对应的文件系统信息。VFS 通过 file_systems在 file_system_type 组成的链表中根据指定的文件系统名称搜索文件系统类型信息</p>\n<p>2.如果在上述链表中找到匹配的文件系统，则说明内核具有对该文件系统的内建支持。否则，说明该文件系统可能由可装载模块支持，VFS 会请求内核装入相应的文件系统模块，此时，该文件系统在 VFS 中注册并初始化。</p>\n<p>3.看不懂</p>\n",
            "tags": [
                "大学",
                "总结",
                "操作系统"
            ]
        },
        {
            "id": "https://blog.unfinished.top/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/",
            "url": "https://blog.unfinished.top/2024/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/",
            "title": "计算机组成",
            "date_published": "2024-01-08T10:16:31.000Z",
            "content_html": "<h1>-1 蛤？</h1>\n<p>1个字节（byte）= 8位（bit）</p>\n<p>32位系统中，1 字 = 4 字节；64位，1 字 = 8 字节</p>\n<p>在 MIPS 指令集中可以用来实现跳转到 4GB 空间内任意地址的指令是 <strong>jr</strong></p>\n<p>j：可跳转226+2=228个地址单元，即228+3bits = 256 MB</p>\n<p>beq：256 KB</p>\n<h1>0 绪论</h1>\n<h3 id=\"冯诺依曼架构\">冯诺依曼架构</h3>\n<p>计算机应由运算器、控制器、存储器、输入设备和输出设备五个基本部件组成。</p>\n<p>存储器不仅能存放数据，而且也能存放指令，形式上两者没有区别，但计算机应能区分数据还是指令；控制器应能自动取出指令来执行；运算器应能进行加/减/乘/除四种基本算术运算，并且也能进行一些逻辑运算和附加运算；操作人员可以通过输入设备、输出设备和主机进行通信。</p>\n<h3 id=\"抽象\">抽象</h3>\n<p>文件是对 I/0 设备的抽象</p>\n<p>虚拟内存是对程序存储器的抽象</p>\n<p>进程是对一个正在运行的程序的抽象：是在给定数据集上的一次程序执行</p>\n<p><img src=\"1703731953839.png\" alt=\"1703731953839\"></p>\n<h3 id=\"并发并行\">并发并行</h3>\n<p>并发:  逻辑上的并行，物理上交替执行（使系统能够同时处理多个任务）</p>\n<p>并行:  物理上的并行（使系统真正地运行更快）</p>\n<h1>1 数制与运算</h1>\n<h2 id=\"进制\">进制</h2>\n<h3 id=\"进制转换\">进制转换</h3>\n<p><img src=\"1703732717527.png\" alt=\"1703732717527\"></p>\n<p><img src=\"1703732759516.png\" alt=\"1703732759516\"></p>\n<h3 id=\"补码\">补码</h3>\n<p>补码取反加一 0011 → 1101  (3 → -3)     取反加一和减一取反效果一样</p>\n<p>反码只取反，原码只改符号位</p>\n<h3 id=\"补码运算\">补码运算</h3>\n<p>[X+Y]补= [X]补+ [Y]补，[X-Y]补=[X]补+[-Y]补</p>\n<p>3+4 = 7  0011+0100 = 0111</p>\n<p>3-4 = -1  0011+1100 = 1111</p>\n<h3 id=\"浮点数表示\">浮点数表示</h3>\n<p>阶码：01000    尾数：0.10110010001</p>\n<p>178.125 =  10110010.001 = 0.10110010001 * （2^01000）</p>\n<h3 id=\"浮点数规格化\">浮点数规格化</h3>\n<p><img src=\"1704519002020.png\" alt=\"1704519002020\"></p>\n<p>数符 S： 1位，0表示正数，1表示负数</p>\n<p>阶码 E：用移码表示，n 位阶码偏移量为 2n-1-1</p>\n<p>如8位阶码偏移量为 7FH（即127）， 11位阶码偏移量3FFH（即1023）</p>\n<p>尾数 M： 尾数必须规格化成小数点左侧一定为1，并且小数点前面这个1作为隐含位被省略。这样单精度浮点数尾数实际上为24位</p>\n<p><strong><u>计算： 1.m * 2^(E-127)  如果是双精度，是E-1023</u></strong></p>\n<p><strong><u>E一定要先减</u></strong></p>\n<p><img src=\"image-20240106140221740.png\" alt=\"image-20240106140221740\" style=\"zoom: 50%;\" /><img src=\"image-20240106140645838.png\" alt=\"image-20240106140645838\" style=\"zoom: 50%;\" /></p>\n<p>2的-126 ~ 127次方</p>\n<h3 id=\"大端小端\">大端小端</h3>\n<p><strong>大端存储模式</strong>：数据的低位保存在内存中的高地址中，数据的高位保存在内存中的低地址中；<br>\n<strong>小端存储模式</strong>：数据的低位保存在内存中的低地址中，数据的高位保存在内存中的高地址中；</p>\n<img src=\"https://img-blog.csdnimg.cn/20200525162747150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg4NjU5Mg==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" style=\"zoom:67%;\" />\n<h3 id=\"各种编码表示10进制\">各种编码表示10进制</h3>\n<p>8421：正常，0＝0000 1＝0001 2＝0010 3＝0011 4＝0100 … 9＝1001</p>\n<p>5421：… 3＝0011 4＝0100 5＝1000 … 9＝1100 ; 而0101是禁止码</p>\n<p>2421：… 4＝0100  5＝1011  6＝1100  7＝1101  8＝1110  9＝1111</p>\n<p>余3：每个字符编码比相应的8421码多3，0＝0011 1＝0100 2＝0101 3＝0110 … 9＝1100</p>\n<p>不是重点，但是挺逆天的</p>\n<h2 id=\"逻辑代数\">逻辑代数</h2>\n<p>按位或：“|”</p>\n<p>按位与：“&amp;”</p>\n<p>按位取反：“~”（单目运算）</p>\n<p>按位异或：“^”</p>\n<p>左移：高位移出，低位补0。可能溢出！</p>\n<p>右移：低位移出，高位补符，可能发生有效数据丢失。</p>\n<p>与：F = A·B ，F=AB   或者    F = A∧B</p>\n<p>或：F = A + B    或者  F = A ∨ B</p>\n<p>异或F=A 圆中间一个十字B</p>\n<p>同或F = A⊙ B</p>\n<p><img src=\"1704522811761.png\" alt=\"1704522811761\" style=\"zoom: 50%;\" /><img src=\"1704524870583.png\" alt=\"1704524870583\"></p>\n<p>对偶定理：将原函数F中的全部 “•” 换成 “+”，“+” 换成 “•”，“0”换成 “1”，“1” 换成 “0”，所得的新函数就是原函数的对偶式，记作F’或F*</p>\n<p>由n个变量组成的 “与” 项中，每个变量以原变量或反变量的形式出现且仅出现一次，则这个与项称为最小项</p>\n<p>n个变量有2^n个最小项</p>\n<p>全部由最小项构成的与或式，也称标准与或式</p>\n<img src=\"1704523166223.png\" alt=\"1704523166223\" style=\"zoom:50%;\" />\n<img src=\"1704523282308.png\" alt=\"1704523282308\" style=\"zoom:50%;\" />\n<img src=\"1704523306716.png\" alt=\"1704523306716\" style=\"zoom:45%;\" />\n<h3 id=\"简化公式\">简化公式</h3>\n<img src=\"1704523501199.png\" alt=\"1704523501199\" style=\"zoom:50%;\" />\n<p><img src=\"1704523947036.png\" alt=\"1704523947036\" style=\"zoom:50%;\" />吸收率1</p>\n<p><img src=\"1704523908797.png\" alt=\"1704523908797\" style=\"zoom:50%;\" />吸收率2</p>\n<h1>2 数字逻辑</h1>\n<h2 id=\"组合逻辑\">组合逻辑</h2>\n<p>从结构看，组合逻辑电路由门电路构成，不含   反馈电路       ，也不含   存储电路      ，信号从输入开始单向传输到输出。对于组合逻辑电路，任何时刻电路的输出仅由当时的  输入信号       决定</p>\n<h3 id=\"半加器\">半加器</h3>\n<p><img src=\"image-20240106150537827.png\" alt=\"image-20240106150537827\" style=\"zoom:50%;\" /><img src=\"image-20240106150548415.png\" alt=\"image-20240106150548415\" style=\"zoom:50%;\" /></p>\n<h3 id=\"全加器\">全加器</h3>\n<p><img src=\"image-20240106150930863.png\" alt=\"image-20240106150930863\" style=\"zoom: 50%;\" /><img src=\"image-20240106151004002.png\" alt=\"image-20240106151004002\" style=\"zoom: 50%;\" /></p>\n<img src=\"image-20240106150945894.png\" alt=\"image-20240106150945894\" style=\"zoom: 80%;\" />\n<h4 id=\"溢出\">溢出</h4>\n<p>“00”表示正，“11”表示负，如果运算结果符号位出现“01”（正溢）或“10” （负溢）都表示出现溢出</p>\n<p>6 = 0110   7 = 0111   6+7 = 01101，正溢出</p>\n<p>-6=1010     -7=1001  -6-7 = 10011，负溢出</p>\n<p>-3 = 1101    -3-3 = 11010  负数不溢出</p>\n<h3 id=\"数值比较器\">数值比较器</h3>\n<p><img src=\"image-20240106155205001.png\" alt=\"image-20240106155205001\" style=\"zoom:50%;\" /><img src=\"image-20240106155231376.png\" alt=\"image-20240106155231376\" style=\"zoom:50%;\" /></p>\n<h3 id=\"ALU\">ALU</h3>\n<p>操作数，选择数</p>\n<h3 id=\"编码器\">编码器</h3>\n<p>某一个输入端的信号变换成相应的一组二进制代码输出的过程叫做   编码</p>\n<img src=\"image-20240106160236976.png\" alt=\"image-20240106160236976\" style=\"zoom:50%;\" />\n<p><img src=\"1704528511028.png\" alt=\"1704528511028\" style=\"zoom: 50%;\" />74147优先编码器（谁优先输出谁）</p>\n<h3 id=\"译码器\">译码器</h3>\n<p>将二进制代码所表示的信息翻译成对应高低电平信号输出的过程称为译码</p>\n<p>3线-8线译码器（74138）</p>\n<p>3个输入：A2，A1，A0；000~111共8种输入组合。</p>\n<p>8个输出：Y7~Y0，<strong>低电平</strong>输出有效；任何时刻最多只有一个输出有效。当输入为000时，Y0输出有效；当输入为001时，Y1输出有效。</p>\n<p>3个使能控制：S0，S1，S2 为使能输入，仅当它们分别为1、0、0时，译码器才正常译码；否则禁止工作。</p>\n<h3 id=\"多路选择器\">多路选择器</h3>\n<img src=\"image-20240106162146201.png\" alt=\"image-20240106162146201\" style=\"zoom:50%;\" />\n<p>若D7-D0  = 10100101</p>\n<p>Y = m7+m5+m2+m0</p>\n<h3 id=\"竞争冒险\">竞争冒险</h3>\n<h4 id=\"竞争\">竞争</h4>\n<p>某个输入变量通过两条或两条以上的途径传到输出端，由于每条途径延迟时间不同，到达输出门的时间就有先有后</p>\n<h4 id=\"冒险\">冒险</h4>\n<p>门电路因输入端的竞争而导致输出端产生不正常的尖峰干扰脉冲信号（毛刺）的现象</p>\n<p>A+ !A 存在0冒险          A ·!A存在1冒险</p>\n<h4 id=\"卡诺图法判断\">卡诺图法判断</h4>\n<p>在逻辑函数的卡诺图中，函数的每个与项对应卡诺图上的一个卡诺圈，若两个卡诺圈相切，相切处将存在冒险。</p>\n<p><img src=\"1704530434352.png\" alt=\"1704530434352\" style=\"zoom:50%;\" /><img src=\"1704530834543.png\" alt=\"1704530834543\" style=\"zoom: 67%;\" /></p>\n<p>增加冗余项。</p>\n<p>L=AC+ ̅AB，当B=C=1时， L=A+ ̅A，存在冒险。增加冗余项 L=AC+  ̅AB+BC，逻辑函数功能不变，冒险消除。</p>\n<h2 id=\"时序逻辑\">时序逻辑</h2>\n<h3 id=\"锁存器和触发器\">锁存器和触发器</h3>\n<p>锁存器是电位（电平）触发的，只有在时钟CP有效电平（高电平CP=1或者低电平CP＝0）期间，触发器的状态才有可能发生变化。</p>\n<p>触发器的状态变化只发生在时钟CP的有效沿（上升沿或者下降沿）期间，CP＝1、CP=0时触发器的状态不会发生变化</p>\n<p>D锁存：CP=0保持；CP=1置为D的值</p>\n<h4 id=\"D触发器\">D触发器</h4>\n<p>D触发由2个D锁存组成；CP从0到1触发</p>\n<p>加使能EN：EN=1正常，EN=0一直保持</p>\n<h4 id=\"JK触发器\">JK触发器</h4>\n<p>J0K0，输出不变； J0K1，输出为0； J1K0，输出为1；J1K1，输出反转</p>\n<h3 id=\"状态机\">状态机</h3>\n<h4 id=\"Moore\">Moore</h4>\n<p><img src=\"1704532315803.png\" alt=\"1704532315803\" style=\"zoom:50%;\" /><img src=\"1704535620164.png\" alt=\"1704535620164\" style=\"zoom:50%;\" /></p>\n<p>输出信号仅与当前状态有关</p>\n<h4 id=\"Mealy\">Mealy</h4>\n<p><img src=\"image-20240106171247758.png\" alt=\"image-20240106171247758\" style=\"zoom:50%;\" /><img src=\"1704535645537.png\" alt=\"1704535645537\" style=\"zoom:50%;\" /></p>\n<p>输出信号与当前状态及输入信号有关</p>\n<p><img src=\"1704535954265.png\" alt=\"1704535954265\" style=\"zoom:33%;\" /><strong>状态转移表长这样</strong></p>\n<h3 id=\"移位寄存器\">移位寄存器</h3>\n<p><img src=\"1704537187152.png\" alt=\"1704537187152\" style=\"zoom:50%;\" /><img src=\"image-20240106183331197.png\" alt=\"image-20240106183331197\" style=\"zoom:67%;\" /></p>\n<p>脉冲一次移位一次</p>\n<h3 id=\"计数器\">计数器</h3>\n<h4 id=\"同步\">同步</h4>\n<p><img src=\"image-20240106184440187.png\" alt=\"image-20240106184440187\" style=\"zoom:50%;\" />同步计数器</p>\n<img src=\"image-20240106184621964.png\" alt=\"image-20240106184621964\" style=\"zoom:50%;\" />\n<h4 id=\"异步\">异步</h4>\n<img src=\"image-20240106184719666.png\" alt=\"image-20240106184719666\" style=\"zoom:50%;\" />\n<img src=\"image-20240106184645318.png\" alt=\"image-20240106184645318\" style=\"zoom:50%;\" />\n<h3 id=\"时钟同步？\">时钟同步？</h3>\n<p><img src=\"1704538203568.png\" alt=\"1704538203568\"></p>\n<p>Tccq：触发器时钟到Q的最小延迟</p>\n<img src=\"1704539135847.png\" alt=\"1704539135847\" style=\"zoom: 50%;\" />\n<p>Tcd：组合逻辑的延迟</p>\n<h1>3 汇编</h1>\n<h2 id=\"寻址\">寻址</h2>\n<p><strong>立即寻址</strong></p>\n<p>操作数直接在指令代码中给出。addi $s1, $s2, 100</p>\n<p><strong>寄存器直接寻址</strong></p>\n<p>操作数在寄存器中，指令地址字段给出寄存器的地址  add <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mn>1</mn><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">s1,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span></span>s2,$s3</p>\n<p><strong>寄存器间接寻址</strong></p>\n<p>操作数在存储器中，指令地址字段中给出的寄存器的内容是操作数在存储器中的地址 lw  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mn>1</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">(</mo></mrow><annotation encoding=\"application/x-tex\">s1, 0(</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mopen\">(</span></span></span></span>s2)</p>\n<p><strong>基址寻址</strong></p>\n<p>操作数在存储器中，指令地址字段给出一基址寄存器和一形式地址，基址寄存器的内容与形式地址之和是操作数的内存地址 lw  <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>s</mi><mn>1</mn><mo separator=\"true\">,</mo><mo>∗</mo><mo>∗</mo><mo>∗</mo><mn>100</mn><mo>∗</mo><mo>∗</mo><mo>∗</mo><mo stretchy=\"false\">(</mo></mrow><annotation encoding=\"application/x-tex\">s1,***100***(</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">∗</span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.46528em;vertical-align:0em;\"></span><span class=\"mord\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span></span></span></span>s2)</p>\n<p><strong>变址寻址</strong></p>\n<p>操作数在存储器中，指令地址字段给出一变址寄存器和一形式地址，变址寄存器的内容与形式地址之和是操作数的内存地址 lb <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mn>1</mn><mo separator=\"true\">,</mo><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy=\"false\">(</mo></mrow><annotation encoding=\"application/x-tex\">t1, string(</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span></span></span></span>t0)</p>\n<p><strong>相对寻址</strong></p>\n<p>基址寻址的特例，由程序计数器PC作为基址寄存器，指令中给出的形式地址作为位移量，二者之和是操作数的内存地址。beq  $s1, $s2,  100</p>\n<p><strong>堆栈寻址</strong></p>\n<p>压栈SP -= 4；出栈SP += 4；</p>\n<h2 id=\"指令\">指令</h2>\n<h3 id=\"指令类型-R-I-J\">指令类型 R/I/J</h3>\n<p>R：两个寄存器运算，结果存到第三个</p>\n<p>I：有1个符号立即数</p>\n<p>J：跳转，26位跳转地址</p>\n<img src=\"image-20240106192507043.png\" alt=\"image-20240106192507043\" style=\"zoom: 50%;\" />\n<h3 id=\"指令格式\">指令格式</h3>\n<h4 id=\"R-Type\">R-Type</h4>\n<p>OP永为000000</p>\n<p>add：</p>\n<img src=\"image-20240106192749894.png\" alt=\"image-20240106192749894\" style=\"zoom: 50%;\" />\n<p><strong>逻辑左移sll</strong> <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>t</mi><mn>1</mn><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">t1,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">t</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span></span></span></span>t2,10也是R型，10存在Shamt里；sllv $t1, $t2, $t3</p>\n<p>jr $t1  # PC = $t1</p>\n<img src=\"image-20240106193339782.png\" alt=\"image-20240106193339782\" style=\"zoom:50%;\" />\n<h4 id=\"I-Type\">I-Type</h4>\n<p>rt ← rs + immediate</p>\n<img src=\"image-20240106195235935.png\" alt=\"image-20240106195235935\" style=\"zoom:50%;\" />\n<p>rt ← memory[base + offest]</p>\n<img src=\"image-20240106195301150.png\" alt=\"image-20240106195301150\" style=\"zoom:50%;\" />\n<img src=\"image-20240106195442117.png\" alt=\"image-20240106195442117\" style=\"zoom:50%;\" />\n<p>if (rs = rt) then PC ← PC + sign_extend</p>\n<img src=\"image-20240106195502445.png\" alt=\"image-20240106195502445\" style=\"zoom:50%;\" />\n<h4 id=\"J-Type\">J-Type</h4>\n<p>j直接跳转</p>\n<img src=\"image-20240106195551348.png\" alt=\"image-20240106195551348\" style=\"zoom:50%;\" />\n<p>jal 指令的意思是跳转到对应标签的位置，并将当前执行的指令位置存储在 $ra 寄存器中。</p>\n<h3 id=\"各种指令\">各种指令</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">赋值 </span><br><span class=\"line\">li $t1, 100  ori $t1, 100</span><br><span class=\"line\"></span><br><span class=\"line\">传值</span><br><span class=\"line\">move $t1, $t2</span><br><span class=\"line\"></span><br><span class=\"line\">add $t1, $t2, $t3 加</span><br><span class=\"line\">mul $t1, $t2, $t3 乘</span><br><span class=\"line\">除法</span><br><span class=\"line\">div $t1, $t2 # 计算 5 / 2，其中商存放在 lo 寄存器，而余数存放在 hi 寄存器</span><br><span class=\"line\">mfhi $t3 # 将 hi 寄存器中的值取出放到 t3 寄存器（余数，值为 1）</span><br><span class=\"line\">mflo $t4 # 将 lo 寄存器中的值取出放到 t4 寄存器（商，值为 2）</span><br><span class=\"line\"></span><br><span class=\"line\">跳转</span><br><span class=\"line\">ble $t1, 5, label</span><br><span class=\"line\">j label</span><br><span class=\"line\"></span><br><span class=\"line\">跳转到函数</span><br><span class=\"line\">jal 指令的意思是跳转到对应标签的位置，并将当前执行的指令位置存储在 $ra 寄存器中。</span><br><span class=\"line\">jr $ra 函数结束后返回！很重要</span><br><span class=\"line\"></span><br><span class=\"line\">数组</span><br><span class=\"line\">.data</span><br><span class=\"line\">array: .space 400</span><br><span class=\"line\">la $t1, array</span><br><span class=\"line\">lw $t2, 0($t1)</span><br><span class=\"line\">sw $t2, array($t3)</span><br><span class=\"line\">字符串不用lw和sw</span><br><span class=\"line\">lb $a0, 0($t0)</span><br><span class=\"line\">sb $a0, 0($t0)</span><br></pre></td></tr></table></figure>\n<img src=\"image-20240106201044299.png\" alt=\"image-20240106201044299\" style=\"zoom: 45%;\" />\n<h1>4 MIPS处理器</h1>\n<h2 id=\"MIPS模型机\">MIPS模型机</h2>\n<p>寄存器，32位虚拟地址</p>\n<p>组合部件ALU（逻辑运算）、MUX（多路选择器）Signext（符号扩展）</p>\n<p>寄存器堆：两个32位数据输出端口，一个32位数据输入端口，三个5位寄存器地址输入端口</p>\n<p>边沿触发的时钟同步方法</p>\n<h2 id=\"单周期处理器\">单周期处理器</h2>\n<p>哈佛体系结构：使用指令存储区（IM）和数据存储区（DM）分别保存指令和数据</p>\n<p>取指令</p>\n<p>32位Instruction = IM[PC]，PC+4，</p>\n<img src=\"image-20240106210307704.png\" alt=\"image-20240106210307704\" style=\"zoom:50%;\" />\n<p>R型如add</p>\n<img src=\"image-20240106211146176.png\" alt=\"image-20240106211146176\" style=\"zoom:50%;\" />\n<p>lw</p>\n<p><img src=\"image-20240106211330560.png\" alt=\"image-20240106211330560\"></p>\n<p>sw</p>\n<p><img src=\"image-20240106211413808.png\" alt=\"image-20240106211413808\"></p>\n<p><img src=\"1704546944945.png\" alt=\"1704546944945\"></p>\n<p>寄存器堆写入端地址选择MUX，选择控制信号 RegDst</p>\n<p>ALU输入端B数据源选择MUX，选择控制信号 ALUSrc</p>\n<p>寄存器堆写入端数据源选择MUX，选择控制信号 MemtoReg</p>\n<p>beq</p>\n<img src=\"image-20240106212423830.png\" alt=\"image-20240106212423830\" style=\"zoom:50%;\" />\n<img src=\"1704547957248.png\" alt=\"1704547957248\" style=\"zoom:67%;\" />\n<p>PC输入端数据源选择MUX，选择控制信号 PCSrc</p>\n<h3 id=\"控制信号\">控制信号</h3>\n<p><img src=\"1704548014476.png\" alt=\"1704548014476\"></p>\n<p>Op：控制7个控制信号</p>\n<p>Func：仅用于R型，控制ALUop</p>\n<p><strong>RegDst</strong></p>\n<p>R型指令：RegDst=1，选择Rd</p>\n<p>Lw指令： RegDst=0，选择Rt</p>\n<p>其他指令：不关心</p>\n<p><strong>ALUScr</strong></p>\n<p>R型指令：ALUSrc=0，选择寄存器堆的 Read data2 输出</p>\n<p>Lw Sw指令： ALUSrc=1，选择Signext的输出</p>\n<p>Beq指令（减法运算）： ALUSrc=0，选择 Read data2 输出</p>\n<p><strong>MemtoReg</strong></p>\n<p>R型指令：MemtoReg=0，选择 ALU 输出</p>\n<p>Lw指令： MemtoReg=1，选择数据存储器DM输出</p>\n<p>其他指令： 不关心</p>\n<p><strong>Branch</strong></p>\n<p>Beq指令：Branch=1，此时若Zero=1，PC输入选择加法器Nadd输出（分支指令目的地址），否则选择加法器Add输出（PC+4）</p>\n<p>其他指令：Branch=0，PC输入选择加法器Add输出（PC+4）</p>\n<p><img src=\"image-20240106215650460.png\" alt=\"image-20240106215650460\"></p>\n<h4 id=\"ALU控制信号\">ALU控制信号</h4>\n<p>ALUOP：10,00,01,分3种情况，10再看FUNC字段，00做一个加法，01做一个减法</p>\n<p><img src=\"1704549610485.png\" alt=\"1704549610485\"></p>\n<h3 id=\"单周期过程\">单周期过程</h3>\n<p>R 取值-读寄存器-ALU运算-写寄存器</p>\n<p>lw 取值-读寄存器-ALU运算-读数据-写寄存器</p>\n<h2 id=\"多周期流水线\">多周期流水线</h2>\n<h3 id=\"五个阶段\">五个阶段</h3>\n<ol>\n<li>\n<p>取指-IF: 取指, PC自增</p>\n</li>\n<li>\n<p>译码和读寄存器-ID:译码, 读寄存器</p>\n</li>\n<li>\n<p>执行-EX: 执行(ALU)  Lw/Sw指令:  计算内存指针  其他指令:  执行其他算术和逻辑运算</p>\n</li>\n<li>\n<p>访存-Mem:   Lw:  从内存读数据到CPU寄存器  Sw:  把寄存器的值写到内存中</p>\n</li>\n<li>\n<p>回写-WB: 把数据写回到寄存器中</p>\n</li>\n</ol>\n<p>当时钟上升沿到来时，组合逻辑计算结果写入后级寄存器</p>\n<h3 id=\"线路\">线路</h3>\n<img src=\"image-20240106230648625.png\" alt=\"image-20240106230648625\" style=\"zoom:50%;\" />\n<p>增加新MUX</p>\n<p><img src=\"1704551192433.png\" alt=\"1704551192433\"></p>\n<h2 id=\"指令相关\">指令相关</h2>\n<p><strong>针对寄存器</strong></p>\n<p>读后写，写后读，写后写</p>\n<h3 id=\"指令冲突\">指令冲突</h3>\n<p>只有写后读会有指令冲突</p>\n<h2 id=\"流水线冒险\">流水线冒险</h2>\n<p>结构冒险：资源竞争，要使用的部件正在忙</p>\n<p>数据冒险：指令执行所需的数据暂时不可用而造成的指令执行的停顿</p>\n<p>控制冒险：也称为分支冒险，必须根据前一条指令的执行结果才能确定下一条真正要执行的指令地址</p>\n<h2 id=\"\"></h2>\n<h3 id=\"结构冒险\">结构冒险</h3>\n<p>内存：流水线的数据通路需要将指令和数据分别存储</p>\n<p>寄存器：将寄存器组的使用权限分为两部分，一个时钟周期内前半个时钟周期进行写操作，后半个时钟周期进行读操作</p>\n<p>在同一个时钟周期，可以同时进行读寄存器和写寄存器的操作</p>\n<h3 id=\"数据冒险\">数据冒险</h3>\n<h4 id=\"旁发\">旁发</h4>\n<img src=\"1704553400856.png\" alt=\"1704553400856\" style=\"zoom:50%;\" />\n<p><img src=\"image-20240106223518442.png\" alt=\"image-20240106223518442\"></p>\n<h4 id=\"阻塞\">阻塞</h4>\n<p><img src=\"image-20240106230913999.png\" alt=\"image-20240106230913999\" style=\"zoom:50%;\" />阻塞+旁发</p>\n<p>阻塞等同插入nop指令</p>\n<p>条件：IF/ID的前序是lw指令，并且lw的rt寄存器与IF/ID的rs或rt相同</p>\n<ul>\n<li>冻结IF/ID：sub继续被保存（用寄存器的使能）</li>\n<li>清除ID/EX：指令全为0，等价于插入NOP（用寄存器的CLR清除）</li>\n<li>冻结PC：防止PC继续计数，PC保持不变</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sub $t2,$t1,$t3</span><br><span class=\"line\">add $t3,$t1,$t2</span><br><span class=\"line\">从EX/MEM转发到ID/EX后面</span><br></pre></td></tr></table></figure>\n<p>如果有转发电路，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lw $t2, 4($t0)</span><br><span class=\"line\">add $t3, $t1, $t2</span><br></pre></td></tr></table></figure>\n<p>需要插入几个NOP指令？<strong><u>1个</u></strong></p>\n<h4 id=\"有转发的完整流水线\">有转发的完整流水线</h4>\n<img src=\"image-20240106235643532.png\" alt=\"image-20240106235643532\" style=\"zoom:50%;\" />\n<h3 id=\"控制冒险\">控制冒险</h3>\n<p>阻塞或者赌博不跳转</p>\n<p>还可以在ID前放置比较器</p>\n<h3 id=\"计算机性能\">计算机性能</h3>\n<p>响应时间：从提交作业到完成作业所花费的时间</p>\n<p>吞吐量：一定时间间隔内完成的作业数</p>\n<h1>5 主存</h1>\n<h2 id=\"工作原理\">工作原理</h2>\n<h3 id=\"RAM\">RAM</h3>\n<p><strong>随机存取存储器</strong>（RAM）</p>\n<p><img src=\"1704595506938.png\" alt=\"1704595506938\">（T是MOS管)</p>\n<p>读出：D 线先预充电到 Vpre=2.5V，然后字选线高电平，T导通</p>\n<p>若电路保存 信息1，Vcs=3.5V，电流方向从单元电路内部向外</p>\n<p>若电路保存信息 0，Vcs=0.0V，电流方向从外向单元电路内部</p>\n<p>写入操作：D 线加高电平（1，3.5V）或低电平（0，0V），字选择线置高电平，T导通；</p>\n<p>写1时，D线高电平，对Cs充电；</p>\n<p>写0时，D线低电平，Cs放电；</p>\n<h3 id=\"ROM\">ROM</h3>\n<p><strong>只读存储器</strong>（ROM）</p>\n<p>PROM</p>\n<p><img src=\"image-20240107105109481.png\" alt=\"image-20240107105109481\" style=\"zoom:25%;\" />出场时为1，当写入0烧毁熔丝，不可恢复</p>\n<p>紫外线擦除可编程的EPROM、电擦除可编程的EEPROM单元电路可以恢复</p>\n<h2 id=\"内部结构\">内部结构</h2>\n<p>芯片容量：2^n * m</p>\n<p>地址线：n位</p>\n<p>数据线：m位</p>\n<p><strong><u><em>这里就是n个字单元，每个字单元m位，很重要</em></u></strong></p>\n<p><img src=\"1704596437871.png\" alt=\"1704596437871\" style=\"zoom:50%;\" />1024×2</p>\n<p><strong>二维地址结构</strong>：</p>\n<p>4096 × 4，4096×4 = 2^14</p>\n<p>存储：2^7 * （2^5*2^2）；一行4个单元一组为一个字，一行32个字</p>\n<p><img src=\"1704596831316.png\" alt=\"1704596831316\" style=\"zoom: 67%;\" />妙哇</p>\n<h2 id=\"存储器扩展\">存储器扩展</h2>\n<h3 id=\"位扩展\">位扩展</h3>\n<p><strong>1K * 4 扩展为 1K * 8</strong>：</p>\n<img src=\"image-20240107111224018.png\" alt=\"image-20240107111224018\" style=\"zoom: 50%;\" />\n<h3 id=\"字扩展\">字扩展</h3>\n<p><strong>1K * 8 扩展为 4K * 8</strong>：</p>\n<img src=\"image-20240107111347911.png\" alt=\"image-20240107111347911\" style=\"zoom:50%;\" />\n<h3 id=\"混合扩展\">混合扩展</h3>\n<p><img src=\"image-20240107111642531.png\" alt=\"image-20240107111642531\" style=\"zoom:50%;\" />4Kx4扩展16Kx8</p>\n<h3 id=\"ROM、RAM扩展\">ROM、RAM扩展</h3>\n<img src=\"1704598394078.png\" alt=\"1704598394078\" style=\"zoom: 67%;\" />\n<p><strong>符号表示</strong></p>\n<p><img src=\"image-20240107113056551.png\" alt=\"image-20240107113056551\" style=\"zoom:33%;\" />符号表示</p>\n<p>读单元地址：Address；读控制信号：MemRead；读出数据：Readdata</p>\n<p>写单元地址：Address；写控制信号：MemWrite；写入数据：Writedata</p>\n<h3 id=\"DRAM刷新方式\">DRAM刷新方式</h3>\n<p><img src=\"1704598538571.png\" alt=\"1704598538571\" style=\"zoom:50%;\" />D线上加感应放大器</p>\n<p><img src=\"image-20240107113613672.png\" alt=\"image-20240107113613672\" style=\"zoom: 33%;\" />读1时D线电压</p>\n<p><img src=\"image-20240107113638223.png\" alt=\"image-20240107113638223\" style=\"zoom:33%;\" />读0时D线电压</p>\n<p>传感放大器会刷新Cs，让Cs保持原来状态而不是被破坏</p>\n<p><strong>分散刷新</strong></p>\n<img src=\"image-20240107114121678.png\" alt=\"image-20240107114121678\" style=\"zoom: 50%;\" />\n<p>一个存储周期分为两段: 前一段用于正常读写，后一段用于刷新操作</p>\n<p>分散刷新间隔 = 刷新行数×存储周期 = 刷新周期</p>\n<p><strong>集中刷新</strong></p>\n<img src=\"image-20240107114139422.png\" alt=\"image-20240107114139422\" style=\"zoom:50%;\" />\n<p>集中刷新间隔 = 刷新周期</p>\n<p><strong>异步刷新（最常用）</strong></p>\n<p>一个刷新周期内将存储芯片内的所有行刷新一遍，且只刷新一遍</p>\n<p>以128行为例，在2ms时间内必须轮流对每一行刷新一次，即每隔2ms/128=15.5μs刷新一行。这时假定读/写与刷新操作时间都为0.5μs，则可用前15μs进行正常读/写操作，最后0.5μs完成刷新操作</p>\n<img src=\"image-20240107114026887.png\" alt=\"image-20240107114026887\" style=\"zoom: 50%;\" />\n<p>异步刷新间隔 = 刷新周期</p>\n<h1>6 高速缓存</h1>\n<p>数据块（block）：Cache与主存的基本划分单位，也是主存与Cache一次交换数据的最小单位，由多个字节（字）组成，取决与主存一次读写操作所能完成的数据字节数。也表明主存于Cache之间局部总线的宽度。</p>\n<p>标记（tag）：Cache每一数据块有一个标记字段，用来保存该数据块对应的主存数据块的地址信息。</p>\n<p>有效位（valid bit）：Cache中每一Block有一个有效位，用于指示相应数据块中是否包含有效数据。</p>\n<p>行（line )：Cache中 一个block及其 tag、valid bit构成1行。</p>\n<p>组（set）：若干块(Block)构成一个组，地址比较一般能在组内各块间同时进行。</p>\n<p>路（way）：Cache相关联的等级，每一路具有独立的地址比较机构，各路地址比较能同时进行（一般与组结合），路数即指一组内的块数。</p>\n<p>命中率（hit rate）：目标数据在Cache中的存储访问的比例。</p>\n<p>缺失率（miss rate）：目标数据不在Cache中的存储访问的比例。</p>\n<hr>\n<p>分S组，每组E行(Block, 数据块)，每数据块包含B个字节</p>\n<p>Cache的容量：N *（ B * 8+tag位+1(valid)）bits</p>\n<h2 id=\"映射\">映射</h2>\n<h3 id=\"全相联\">全相联</h3>\n<p>主存中的某一Block可以映射到Cache中的任意一Blcok</p>\n<img src=\"image-20240107125035390.png\" alt=\"image-20240107125035390\" style=\"zoom:50%;\" />\n<p>主存地址格式：</p>\n<img src=\"image-20240107125050698.png\" alt=\"image-20240107125050698\" style=\"zoom:50%;\" />\n<p>CPU找Cache中地址时，与所有Tag进行比较</p>\n<p>灵活，成本高</p>\n<h3 id=\"直接映射\">直接映射</h3>\n<p>主存中的某一块 J 映射到Cache中的固定块 K， K ＝ J Mod C， 其中C是Cache包含的块数</p>\n<p>相当于<strong>一路组相连</strong></p>\n<img src=\"image-20240107125655315.png\" alt=\"image-20240107125655315\" style=\"zoom:50%;\" />\n<p>主存地址格式</p>\n<img src=\"image-20240107125720669.png\" alt=\"image-20240107125720669\" style=\"zoom:50%;\" />\n<p>区内索引数量 = Cache行数</p>\n<p>Cache如果有16行 = Index有4位</p>\n<p>区数量为主存行数/一个区内数量</p>\n<p><strong>例：主存容量1M字节，Cache容量4k字节，Block大小256 Bytes</strong></p>\n<p>Cache: 2^12 ÷ 2^8 = 2^4 Blocks，Index应该为4位</p>\n<p>主存: 2^12 Blocks，每个区2^4Blocks , 分成2^8个区</p>\n<p>主存地址：20位，其中高 8 位区地址，中间4位为区内块地址，低8位为块内地址。</p>\n<h3 id=\"组相联\">组相联</h3>\n<p>主存和Cache 都分成 K 组，其中Cache每组包含 L 块数据（Nc= K * L），主存每组包含M块数据；主存的块 J 以下列原则映射到 Cache 的组 I 中的任何一块（Nm= K * M） 。             I =  J  mod K  （0 ≤ I ≤ K）</p>\n<img src=\"image-20240107133841909.png\" alt=\"image-20240107133841909\" style=\"zoom:50%;\" />\n<p>主存地址格式</p>\n<img src=\"image-20240107133833645.png\" alt=\"image-20240107133833645\" style=\"zoom:50%;\" />\n<p>Cache：valid，Tag，Data</p>\n<p>在组相连中，如果只有一组，则变成了全相联了。</p>\n<p>如果组相联中每组只有一个数据块，则组相联就变成直接相联了。</p>\n<h2 id=\"替换策略\">替换策略</h2>\n<p><strong>缺失处理方式</strong></p>\n<img src=\"image-20240107140809736.png\" alt=\"image-20240107140809736\" style=\"zoom:50%;\" />\n<h3 id=\"替换方式\">替换方式</h3>\n<p>FIFO：最先装入数据的块被替换</p>\n<p>LRU：最近最少使用法</p>\n<p>访问命中时，所有块的计数值与命中块的计数值进行比较：如果某块计数值小于命中块的计数值， 则该块的计数值加 1；如果该块的计数值大于命中块的计数值，则数值不变。最后将命中块的计数器清为0。</p>\n<p>访问未命中，需要替换时，则选择计数值最大的块被替换（若最大值并列，随机选择一个）。被替换块的计数器清0，而其它的计数器则加1</p>\n<h2 id=\"性能分析\">性能分析</h2>\n<p>一般情况增加路数提高命中率，降低时间；</p>\n<p>随着块大小增加，缺失率先降低后增加；</p>\n<p>Cache所需总存储容量=（tag位+有效位+（可能的脏位）+1个数据块容量）* 块数</p>\n<p>命中率 * Cache访问时间+（1-命中率）* （装入Cache+Cache访问时间）</p>\n<p>写回（Write Back）：写操作只更新Cache中的数据，直到Block替换时才将整个Block写回主存，一般使用“脏位”（dirty bit）来表示Block在替换回主存之前是否被修改过；</p>\n<h2 id=\"要点？\">要点？</h2>\n<p>内存地址格式：  组内块地址(多少b) + 组地址(多少b) + 块内偏移地址(多少b)1</p>\n<h1>7 虚拟存储</h1>\n<p>把主存当做辅助存储器的高速缓存技术，称为虚拟存储技术，程序中可以使用较大的存储空间称为虚拟存储器</p>\n<p>固定长（简单）分区，浪费空间</p>\n<p>可变长分区，开始好，后面会产生空块</p>\n<h2 id=\"页式虚拟存储器\">页式虚拟存储器</h2>\n<p>内存分成定长小块（页），进程也分成定长小块。</p>\n<p>虚存页称为虚页，主存页称为实页</p>\n<p>一个进程用很多小块，可以不连续</p>\n<p>操作系统为进程生成页表</p>\n<p>通过页表实现逻辑地址向物理地址的转换。</p>\n<p>页表基址寄存器：保存页表在内存中的首地址</p>\n<h3 id=\"虚实地址的转换\">虚实地址的转换</h3>\n<ol>\n<li>\n<p>根据虚地址，访问主存中的页表</p>\n</li>\n<li>\n<p>根据实地址，访问主存中的物理页</p>\n</li>\n</ol>\n<img src=\"image-20240107151029798.png\" alt=\"image-20240107151029798\" style=\"zoom:50%;\" />\n<img src=\"image-20240107151913428.png\" alt=\"image-20240107151913428\" style=\"zoom:50%;\" />\n<h2 id=\"多级页表\">多级页表</h2>\n<p>二级页表页面大小为4KB的2GB虚拟存储器，每个页表项占4个字节：2^19 * 2^2=2MB</p>\n<p>一级页表2^9项（每项占4个字节），二级页表2^10项（每项占4个字节），整个一级页表常驻内存，常用的两个活跃二级页表装载到内存：  512 * 4+2 * 1K * 4 = 10KB （假定2个活跃页表换入内存时，实际占用的内存）</p>\n<img src=\"image-20240107151055751.png\" alt=\"image-20240107151055751\" style=\"zoom:50%;\" />\n<h2 id=\"例题\">例题</h2>\n<img src=\"1704611716703.png\" alt=\"1704611716703\" style=\"zoom: 67%;\" />\n<h2 id=\"快表TLB\">快表TLB</h2>\n<p>使用Cache存储部分活跃的页表项，称为TLB（快表），它包含了最近使用的那些页表项。</p>\n<p>TLB内容：标记（虚页号）、数据块（实页号）、有效位、修改位。</p>\n<p>TLB一般采用全相联或者组相联</p>\n<p><img src=\"image-20240107151819430.png\" alt=\"image-20240107151819430\"></p>\n<img src=\"image-20240107152739212.png\" alt=\"image-20240107152739212\" style=\"zoom:50%;\" />\n<p><img src=\"image-20240107153422198.png\" alt=\"image-20240107153422198\" style=\"zoom:50%;\" />TLB命中与否 与Cache是否命中 <strong>无关</strong></p>\n<img src=\"1704613616027.png\" alt=\"1704613616027\" style=\"zoom:50%;\" />\n<h1>8 链接</h1>\n<h2 id=\"目标文件的三种格式\">目标文件的三种格式</h2>\n<ul>\n<li><strong>可重定位目标文件（relocatable object file:  .o ）</strong></li>\n</ul>\n<p>包含二进制代码和数据</p>\n<p>其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件</p>\n<p>每一个 .c 源文件产生一个对应的 .o 文件</p>\n<ul>\n<li><strong>可执行目标文件（executable object file）</strong></li>\n</ul>\n<p>可以没有扩展名（Linux）或者 a.out ;    .exe(Windows)</p>\n<p>包含二进制代码和数据</p>\n<p>其形式可以被直接复制到内存并执行</p>\n<ul>\n<li><strong>共享目标文件（shared object file）</strong></li>\n</ul>\n<p>一种特殊类型的可重定位目标文件</p>\n<p>可以在加载或者运行时被动态地加载进内存并链接</p>\n<p>windows：.lib (静态链接库)  .dll （动态链接库）；Linux：.a(静态链接) .so(动态链接)</p>\n<h2 id=\"Elf格式\">Elf格式</h2>\n<p>.text: 已编译程序的机器代码（Code）</p>\n<p>.rodata: 只读数据</p>\n<p>.data: 已初始化的全局和静态 C 变量</p>\n<p>.bss:  Block Started by Symbol</p>\n<p>.symtab:   符号表</p>\n<p>.rel.text:  .text 节的重定位信息</p>\n<p>.rel.data（.rel.data.rel）:   .data节的重定位信息</p>\n<h2 id=\"链接器符号\">链接器符号</h2>\n<ul>\n<li><strong>全局符号</strong></li>\n</ul>\n<p>由模块 m 定义并能被其他模块引用的符号：非静态的 C 函数和全局变量</p>\n<ul>\n<li><strong>外部符号</strong></li>\n</ul>\n<p>由其他模块定义并被模块 m 引用的全局符号：在其他模块中定义的非静态 C 函数和全局变量</p>\n<ul>\n<li><strong>局部符号</strong></li>\n</ul>\n<p>只被模块 m 定义和引用的符号：带 static 属性的 C 函数和全局变量</p>\n<p>**局部链接器符号和局部变量不同 **连接器不知道局部变量</p>\n<p>局部非静态C变量：保存在栈上或寄存器中</p>\n<p>局部静态C变量：保存在 .data 或 .bss</p>\n<h2 id=\"符号解析\">符号解析</h2>\n<h3 id=\"局部符号\">局部符号</h3>\n<p>在相同模块中定义和引用</p>\n<p>编译器只允许每个模块中每个局部符号有一个定义</p>\n<p>其解析简单明了</p>\n<h3 id=\"全局符号\">全局符号</h3>\n<p>符号在当前模块中无定义：编译器会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理</p>\n<p>如果链接器在它的任何输入模块中都找不到这个被引用符号的定义：输出一条错误信息并终止</p>\n<p>还有一种情况：多个目标文件可能会定义相同名字的全局符号</p>\n<ul>\n<li><strong>全局符号分为强符号和弱符号</strong></li>\n</ul>\n<p>强符号：函数和已初始化的全局变量</p>\n<p>弱符号：未初始化的全局变量和外部符号</p>\n<ul>\n<li>\n<p>不允许有多个同名的强符号：每个强符号只能定义一次，否则链接错误</p>\n</li>\n<li>\n<p>如果有一个强符号和多个弱符号同名，那么选择强符号</p>\n</li>\n<li>\n<p>如果有多个弱符号同名，那么从这些弱符号中任意选择一个</p>\n</li>\n</ul>\n<h2 id=\"静态库\">静态库</h2>\n<p>ar rcs name.a name1.o name2.o ：创建静态库</p>\n<p>gcc -static -o test test.o ./name.a ：链接静态库</p>\n<img src=\"1704617901075.png\" alt=\"1704617901075\" style=\"zoom:50%;\" />\n<img src=\"1704617936261.png\" alt=\"1704617936261\" style=\"zoom:50%;\" />\n<h2 id=\"链接去年好像没考😅\">链接去年好像没考😅</h2>\n<h1>9 总线和IO</h1>\n<h2 id=\"总线仲裁\">总线仲裁</h2>\n<h3 id=\"链式查询方式\">链式查询方式</h3>\n<p>总线控制器（仲裁器）收到总线申请BR，BG（总线同意信号）逐个往下传；</p>\n<p>到某接口有总线申请（BR：总线申请信号），BG停止往下传；</p>\n<p>该接口获得总线使用权，并建立总线忙信号BS。</p>\n<h3 id=\"计数器定时查询方式\">计数器定时查询方式</h3>\n<p>总线控制器（仲裁器）收到总线申请BR，仲裁器上的计数器开始计数；</p>\n<p>当某个有总线申请的设备地址与计数器一致，便获得总线使用权，并建立总线忙信号BS</p>\n<h3 id=\"独立请求方式\">独立请求方式</h3>\n<p>每个设备有独立的请求信号和总线同意信号；</p>\n<p>总线控制器根据设备的优先级决定将总线的使用权交给哪个设备。</p>\n<h2 id=\"IO\">IO</h2>\n<p>I/O地址（I/O接口地址, I/O端口地址）：实际上是I/O接口电路中寄存器的地址（外设寄存器）</p>\n<p>？？</p>\n<h2 id=\"程序查询IO\">程序查询IO</h2>\n<p>编程式I/O</p>\n<p>控制命令：激活外设完成动作。如指示磁带机快进或快退，控制命令与设备类型相关；</p>\n<p>测试命令：测试与I/O接口及其外部设备的各种状态条件；</p>\n<p>读命令：使I/O接口从外设获得一个数据项，存入内部缓冲区；</p>\n<p>写命令：使I/O接口从数据总线获得一个数据项，然后传送到外设。</p>\n<ul>\n<li>I/O操作由CPU直接完成（通过执行I/O指令完成）</li>\n<li>外设速度慢，CPU速度快，在外设准备过程中，CPU处在不断的查询之中，CPU的效率浪费严重</li>\n<li>外设与CPU完全串行工作</li>\n</ul>\n<h2 id=\"中断IO\">中断IO</h2>\n<p>顾名思义</p>\n<h2 id=\"DMA\">DMA</h2>\n<p>DMA控制器接到DMA应答信号后，通过控制逻辑向系统总线发送存储器地址信号、存储器读写控制信号、I/O接口读写控制信号等，完成一次数据传送。</p>\n<p>若是单字传输，一般仅需要一个总线周期，所以这种方式称为周期窃取（cycle-stealing，或者叫周期挪用）方式。若是成组传输，需要多个总线周期来完成。所有数据传送结束后，通过中断方式告知CPU进行善后处理。</p>\n<p>CPU仅在开始DMA操作之前和完成DMA操作之后参与I/O处理，在DMA过程中，CPU可以运行原来的程序</p>\n<p><strong>停止CPU访问内存（成组传送方式）</strong></p>\n<p>一次DMA请求得到响应后，DMA控制器完全占用总线，进行块数据（多字）传送，直到所有数据传送完毕才释放总线，这段时间完全停止CPU访问内存。</p>\n<p>适应高速外设与存储器交换数据的情况。</p>\n<p><strong>周期窃取方式（单字传送方式，DMA和CPU交替使用总线）</strong></p>\n<p>每次DMA请求得到响应后，DMA控制器窃取一个总线周期完成一次数据传送，然后释放总线，CPU接着使用一个总线周期，然后DMA再窃取一个周期，这样持续循环下去，直到数据传输结束。</p>\n<p>一般情况下，CPU 不访问存储器时释放总线</p>\n<p>一般适应存储器速度远高于I/O设备速度的情况。</p>\n",
            "tags": [
                "大学",
                "总结",
                "计组"
            ]
        },
        {
            "id": "https://blog.unfinished.top/2024/01/05/JavaReview/",
            "url": "https://blog.unfinished.top/2024/01/05/JavaReview/",
            "title": "Java期末考试复习提纲",
            "date_published": "2024-01-05T06:53:13.000Z",
            "content_html": "<p><em>仅供参考,如有错误请联系作者指正</em></p>\n<ul>\n<li>方法头: 包括方法的修饰符、返回值类型、方法名、形式参数(最后两项是方法签名)</li>\n<li>方法体: 在Java语言中方法体一个方法中用大括号{}括起来的部分</li>\n<li>重载(Overload): 一个类中，定义的多个参数名相同但是参数列表不同的方法（签名不同）</li>\n<li>重写(Override): 子父类中，子类定义的和其从父类继承而来的方法中方法签名完全相同的方法。</li>\n</ul>\n<p>实例方法 = 普通方法</p>\n<p>类方法 = 静态方法</p>\n<p>上转型对象可以访问子类继承或隐藏的成员变量</p>\n<h3 id=\"匿名对象\">匿名对象</h3>\n<p>new Student();//这个也是一个对象，但是没有名字，称为匿名对象</p>\n<h3 id=\"局部和成员变量\">局部和成员变量</h3>\n<p>成员变量存储在堆内存的对象中</p>\n<p>局部变量存储在栈内存的方法中</p>\n<p>成员变量随着对象的出现而出现在堆中，随着对象的消失而从堆中消失</p>\n<p>局部变量随着方法的运行而出现在栈中，随着方法的弹栈而消失</p>\n<p>成员变量因为在堆内存中，所有成员变量具有默认的初始化值</p>\n<p>局部变量没有默认的初始化值，必须手动的给其赋值才可以使用。</p>\n<h3 id=\"先后顺序\">先后顺序</h3>\n<p>第一次：静态代码块-非静态代码块-默认构造方法-普通方法</p>\n<p>之后：非静态代码块-默认构造方法-普通方法</p>\n<h3 id=\"protected\">protected</h3>\n<p><img src=\"1703938349037.png\" alt=\"1703938349037\"></p>\n<p>不同包下，在子类中通过父类引用不可以访问其 protected 方法</p>\n<p>不同包下，在子类中通过该子类引用可以访问其 protected 方法还可以通过 super 关键字调用父类中的该方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//print是Parent中的protected方法，并且不在同一个包中</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Parent</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Child</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>();</span><br><span class=\"line\">        c1.print(); <span class=\"comment\">//可以</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>.print(); <span class=\"comment\">//可以</span></span><br><span class=\"line\">        <span class=\"type\">Parent</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>();</span><br><span class=\"line\">        <span class=\"type\">Parent</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>();</span><br><span class=\"line\">        c2.print(); <span class=\"comment\">//达咩</span></span><br><span class=\"line\">        c3.print(); <span class=\"comment\">//达咩</span></span><br><span class=\"line\">        <span class=\"type\">Child2</span> <span class=\"variable\">c4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child2</span>();</span><br><span class=\"line\">        c4.print();<span class=\"comment\">//no</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Child2</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Parent</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>不同包下，在子类中不能通过另一个子类引用访问共同基类的 protected 方法</p>\n<p>对于protected修饰的静态成员，无论是否同一个包，在子类中均可直接访问</p>\n<p>在不同包的非子类中则不可访问</p>\n<h2 id=\"继承\">继承</h2>\n<h3 id=\"构造方法\">构造方法</h3>\n<p>创建子类对象时，子类总是按层次结构从上到下的顺序调用所有超类的构造函数。如果继承和组合联用，要先构造基类的构造函数，然后调用组合对象的构造函数（组合按照声明的顺序调用）</p>\n<p>如果父类没有不带参数的构造方法，则在子类的构造方法中必须明确的告诉调用父类的某个带参数的构造方法，通过super关键字，这条语句还必须出现在构造方法的第一句</p>\n<h3 id=\"变量隐藏\">变量隐藏</h3>\n<p>变量隐藏：在子类对父类的继承中，如果子类的成员变量和父类的成员变量同名，此时称为子类隐藏（override）了父类的成员变量。</p>\n<p>子类若要引用父类的同名变量：super.变量名</p>\n<p>final可以被隐藏，static也能被隐藏，都能被隐藏。</p>\n<h3 id=\"方法覆盖隐藏\">方法覆盖隐藏</h3>\n<p>覆盖就是子类的方法跟父类的方法具有完全一样的签名和参数</p>\n<p><u><strong>私有方法、静态方法不能被覆盖，如果在子类出现了同签名的方法，就是方法隐藏</strong></u></p>\n<p><u><strong>用final声明的成员方法是最终方法，最终方法不能被子类覆盖</strong></u>（试图在子类写同名会直接报错）</p>\n<h3 id=\"继承的好处都有啥？\">继承的好处都有啥？</h3>\n<p>提高代码维护性，可重用性，可扩展性</p>\n<p>继承是类实现可重用性和可扩充性的关键持征</p>\n<p>减少模块间的接口和界面</p>\n<p><strong>但是继承破坏了封装性，导致耦合性变高</strong>，但是问题不大</p>\n<h2 id=\"多态\">多态</h2>\n<h3 id=\"静多态\">静多态</h3>\n<p>即在编译时决定调用哪个方法，也称为编译时多态</p>\n<p>一般是指方法重载，方法隐藏</p>\n<h4 id=\"方法重载\">方法重载</h4>\n<p>方法名相同，参数个数、参数类型及参数顺序至少有一个不同</p>\n<p>构造方法和静态成员方法都是可以重载，静态成员方法重载后的方法也可以是非静态成员方法。</p>\n<h4 id=\"方法隐藏\">方法隐藏</h4>\n<p>傻逼父类静态方法，不会被子类静态方法覆盖，只会被隐藏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Parent</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">()</span>&#123;System.out.print(<span class=\"string\">&quot;Parent&quot;</span>)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Child</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Parent</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">print</span><span class=\"params\">()</span>&#123;System.out.print(<span class=\"string\">&quot;Child&quot;</span>)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Test</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    \t<span class=\"type\">Parent</span> <span class=\"variable\">child1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>();</span><br><span class=\"line\">        <span class=\"type\">Child</span> <span class=\"variable\">child2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Child</span>();</span><br><span class=\"line\">        child1.print(); <span class=\"comment\">//Parent</span></span><br><span class=\"line\">        child2.print(); <span class=\"comment\">//Child</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;<span class=\"comment\">//傻逼方法隐藏</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"动多态\">动多态</h3>\n<p>运行时才能确定调用哪个方法，也称为运行时多态，也称为动态联编，也称为动绑定</p>\n<p>“覆盖方法、抽象方法和接口” 和动态联编关系紧密</p>\n<h4 id=\"方法覆盖\">方法覆盖</h4>\n<p>继承，方法覆盖，父类的引用指向派生类的实例且通过父类的引用调用被覆盖的方法</p>\n<p>final方法没法被覆盖</p>\n<p><em><strong>但是他妈的final变量又可以被子类的隐藏，傻逼 Java有病是不是</strong></em></p>\n<p>私有方法、静态方法不能被覆盖，如果在子类出现了同签名的方法，那是方法隐藏；</p>\n<p><strong><u>继承是子类使用父类的方法，而多态则是父类使用子类的方法</u></strong></p>\n<h2 id=\"抽象类\">抽象类</h2>\n<p>不能实例化，但可以创建它的引用</p>\n<p>抽象方法不能被private、final或static修饰</p>\n<p>当类实现了一个接口/继承抽象类，但并没有实现该接口/抽象类的所有方法时，该类必须声明为抽象类，否则出错</p>\n<p>抽象类里可以有变量</p>\n<p>可以有构造方法</p>\n<p>可以有非抽象方法</p>\n<p>抽象方法必须在抽象类里</p>\n<h2 id=\"接口\">接口</h2>\n<p>public interface 名字{…}</p>\n<p>interface extents interface</p>\n<p>class implements interface</p>\n<h4 id=\"定义\">定义</h4>\n<p>接口是一种特殊的抽象类，这种抽象类中只包含常量和方法的定义，而没有方法的实现。接口是抽象方法和常量值的定义的集合</p>\n<p>接口是用来实现类间（不相关类）多重继承功能的结构</p>\n<h4 id=\"接口要点\">接口要点</h4>\n<p>所有的变量都默认是<strong>public static final</strong>，并且没法改</p>\n<p>接口中所有的方法都默认是<strong>public abstract</strong>的</p>\n<p>没有构造方法</p>\n<p>一个类可以实现多个接口</p>\n<p>接口中的方法体可以由 java 语言书写，也可以由其他语言书写，用其他语言书写时，接口方法需要用 native关键字修饰（牛逼）</p>\n<p>类在实现抽象方法时必须显式的使用 <strong>public</strong> 修饰符</p>\n<h4 id=\"接口回调\">接口回调</h4>\n<p>把实现某一接口的类创建的对象引用赋给该接口声明的接口变量</p>\n<p>该接口变量就可以调用被类实现的接口中的方法。</p>\n<h4 id=\"接口的进化\">接口的进化</h4>\n<p>其实就是一个接口继承了多接口…</p>\n<h2 id=\"抽象类和接口的区别\">抽象类和接口的区别</h2>\n<ul>\n<li>\n<p>接口中的成员变量和方法只能是public类型的，而抽象类中的成员变量和方法可以处于各种访问级别。</p>\n</li>\n<li>\n<p>接口中的成员变量只能是public、static和final类型的，而在抽象类中可以定义各种类型的实例变量和静态变量。</p>\n</li>\n<li>\n<p>接口中没有构造方法，抽象类中有构造方法。接口中所有方法都是抽象方法，抽象类中可以有非抽象方法，可以没有抽象方法。抽象类比接口包含了更多的实现细节。</p>\n</li>\n</ul>\n<h2 id=\"转型\">转型</h2>\n<h4 id=\"向上转型\">向上转型</h4>\n<p>将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型或者向上映射。</p>\n<p>只能调用父类中定义的属性和方法。</p>\n<p>用的变量是父类的，方法是父类被子类覆盖的</p>\n<p>没法用子类独有的变量/方法</p>\n<p>安全</p>\n<h4 id=\"向下转型\">向下转型</h4>\n<p>一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型</p>\n<p>能用子类独有的变量/方法</p>\n<p><strong>若直接创建父类对象，无法向下转型！</strong></p>\n<p>不安全</p>\n<p><strong>不可转会有运行时异常ClassCastException，<u>不是编译时异常！</u></strong></p>\n<h4 id=\"instanceof\">instanceof</h4>\n<p><code>obj instanceof ClassName/InterfaceName</code></p>\n<p>判断是否是某类/接口的实例</p>\n<h2 id=\"设计原则\">设计原则</h2>\n<ul>\n<li>\n<p>开闭原则：一个软件实体应当对扩展开放，对修改关闭——降低维护风险</p>\n</li>\n<li>\n<p>单一职责原则: 一个类只负责一个功能领域中的相应职责——提高可读性</p>\n</li>\n<li>\n<p>里氏代换原则: 所有引用基类（父类）的地方必须能透明地使用其子类的对象——防止继承泛滥</p>\n</li>\n<li>\n<p>合成复用原则：尽量使用组合或者聚合关系实现代码复用，少使用继承。——降低耦合</p>\n</li>\n<li>\n<p>依赖倒转原则: 抽象不应该依赖于细节, 细节应当依赖于抽象。 换言之, 要针对接口编程, 而不是针对实现编程——利于升级拓展</p>\n</li>\n<li>\n<p>接口隔离原则: 使用多个专门的接口, 而不使用单一的总接口, 即客户端不应该依赖那些它不需要的接口——高聚合低耦合</p>\n</li>\n<li>\n<p>迪米特法则: 一个软件实体应当尽可能少地与其他实体发生相互作用——减少代码臃肿</p>\n</li>\n</ul>\n<h2 id=\"设计模式\">设计模式</h2>\n<h3 id=\"单例\">单例</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">饿汉 线程安全效率高，可能浪费空间</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//静态的,保留自身的引用,类加载时就初始化</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">    <span class=\"comment\">//必须是私有的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//公共的静态的方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">懒汉 线程不安全，不浪费空间</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Singleton</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//静态的。保留自身的引用。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Singleton</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"comment\">//必须是私有的构造函数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Singleton</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">//公共的静态的方法。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title function_\">getInstance</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(test == <span class=\"literal\">null</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            test = <span class=\"keyword\">new</span> <span class=\"title class_\">Singleton</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Object类\">Object类</h2>\n<p>public final Class&lt;?&gt; getClass（）{ }</p>\n<p>public int hashCode() { }对地址或者String进行Hash</p>\n<p>自己的类：equal和==基本一样</p>\n<p>一些系统的类：String、File、Integer、Double，</p>\n<p>Equal判断值是否一样，==判断是否是一个实例</p>\n<h2 id=\"Final方法-类\">Final方法/类</h2>\n<p>最终方法既不能被覆盖，也不能被重载</p>\n<p>final类中的方法都是隐式的final方法，private默认final</p>\n<p><strong>abstract和final不能同时使用</strong></p>\n<p>简单数据类型常量其值一旦确定，就不能被改变</p>\n<p><strong>复合数据类型常量指的是引用不能被改变，而其具体的值是可以改变的</strong></p>\n<p>final变量要么就直接赋值，要么就得在代码块或者构造函数中赋值</p>\n<h2 id=\"内部类\">内部类</h2>\n<p>在创建实例内部类的实例时，外部类的实例必须已经存在</p>\n<p>静态内部类的实例不会自动持有外部类的特定实例的引用，在创建内部类的实例时，不必创建外部类的实例</p>\n<h4 id=\"局部内部类\">局部内部类</h4>\n<p>只能在当前方法中使用</p>\n<p>可访问外部类的所有成员以及方法中用final修饰的内部成员</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">A</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">method</span><span class=\"params\">(<span class=\"keyword\">final</span> x)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">int</span> y=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">z</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">B</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//可访问a,x,y</span></span><br><span class=\"line\">            <span class=\"comment\">//不可访问z</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"匿名类\">匿名类</h4>\n<p>匿名类就是没有名字的类，是将类和类的方法定义在一个表达式范围里</p>\n<p>匿名类本身没有构造方法，但是会调用父类的构造方法</p>\n<p>作用：封装类型、直接访问外部类的成员、回调外部类的方法</p>\n<h4 id=\"回调\">回调</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Adjustable</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">adjust</span><span class=\"params\">(<span class=\"type\">int</span> temperature)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Base</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> speed;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">adjust</span><span class=\"params\">(<span class=\"type\">int</span> speed)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.speed=speed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Sub</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Base</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> temperature;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">adjustTemperature</span><span class=\"params\">(<span class=\"type\">int</span> temperature)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.temperature=temperature;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Closure</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Adjustable</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">adjust</span><span class=\"params\">(<span class=\"type\">int</span> temperature)</span>&#123;</span><br><span class=\"line\">            adjustTemperature(temperature);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Adjustable <span class=\"title function_\">getCallBackReference</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Closure</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">    <span class=\"type\">Sub</span> <span class=\"variable\">sub</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Sub</span>();</span><br><span class=\"line\">\t<span class=\"type\">Adjustable</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> sub.getCallBackReference();</span><br><span class=\"line\">\ta.adjust(<span class=\"number\">10</span>); <span class=\"comment\">//温度</span></span><br><span class=\"line\">\tsub.adjust(<span class=\"number\">114514</span>); <span class=\"comment\">//速度</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"异常\">异常</h2>\n<p>方法中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法声明处：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void method() throws xxx&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>自定义异常</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class 名字 extends Exception &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"集合\">集合</h2>\n<h3 id=\"Set\">Set</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeSet</span>&lt;&gt;(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(o1==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(o2==<span class=\"literal\">null</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1&gt;o2?-<span class=\"number\">1</span>:<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (Integer integer : set) &#123;</span><br><span class=\"line\">    System.out.println(integer);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Iterator&lt;Integer&gt; setIt = set.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(setIt.hasNext())&#123;</span><br><span class=\"line\">    System.out.println(setIt.next());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object[] setArray = set.toArray();</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i&lt;setArray.length;i++)&#123;</span><br><span class=\"line\">    System.out.println(setArray[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>SortedSet是一个按照升序排列元素的Set，狗都不用。</p>\n<h3 id=\"List\">List</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> List&lt;Food&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Food&gt;();</span><br><span class=\"line\"><span class=\"keyword\">static</span> List&lt;Food&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Food&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(Food f : list)&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"number\">2</span>+<span class=\"string\">&quot; &quot;</span>+f.type);</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;<span class=\"comment\">//can break</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">list.forEach(</span><br><span class=\"line\">    x-&gt;&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;1 &quot;</span>+x.type);</span><br><span class=\"line\">        <span class=\"comment\">//can&#x27;t break</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i&lt;list.size();i++)&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"number\">3</span>+<span class=\"string\">&quot; &quot;</span>+list.get(i).type);<span class=\"comment\">//can break</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Linked还能选择在头或者尾 加元素/获取元素/删除元素</span><br></pre></td></tr></table></figure>\n<h3 id=\"Map\">Map</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;Integer, String&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;&gt;(</span><br><span class=\"line\">    <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer obj1, Integer obj2)</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 降序排序</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> obj2.compareTo(obj1);</span><br><span class=\"line\">            <span class=\"comment\">//return obj1.compareTo(obj2);</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">map.keySet();<span class=\"comment\">//返回Set</span></span><br><span class=\"line\">map.values();<span class=\"comment\">//返回Collection</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(Entry entry: map.entrySet())&#123;</span><br><span class=\"line\">    System.out.println(entry.getKey()+<span class=\"string\">&quot; &quot;</span>+entry.getValue());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"集合对比\">集合对比</h3>\n<h4 id=\"Vector-ArrayList\">Vector &amp; ArrayList</h4>\n<p>Vector线程安全</p>\n<p>ArrayList重速度轻安全，线程非安全</p>\n<p>长度需增长时，Vector默认增长一倍，ArrayList增长50%</p>\n<h4 id=\"Hashtable-HashMap\">Hashtable &amp; HashMap</h4>\n<p>Hashtable线程安全，不允许null值，继承Dictionary类</p>\n<p>HashMap线程非安全，允许null值，实现Map接口</p>\n<h3 id=\"Iterator\">Iterator</h3>\n<p>只能用来遍历喵</p>\n<h3 id=\"Arrays-sort\">Arrays.sort</h3>\n<p>不会真有人用这玩意吧</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer[] a = &#123;<span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Arrays.sort(a,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer obj1, Integer obj2)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 降序排序</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> obj1.compareTo(obj2);</span><br><span class=\"line\">        <span class=\"comment\">//return obj1.compareTo(obj2);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"IO\">IO</h2>\n<p>Input/OutputStream：字节流</p>\n<p>Reader/Writer：字符流</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Scanner</span> <span class=\"variable\">scanner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>\n<h3 id=\"各种流\">各种流</h3>\n<p>过滤流类的主要功能是为输入/输出流提供一个通用的接口，提供将流连接在一起的能力，即将一个流连接到另一个流的尾部，这样可以得到满足应用程序要求的很长的输入和输出过滤器。</p>\n<p>带缓存的输入流和输出流对应的类是：BufferedInputStream，BufferedOutputStream：快得很呐</p>\n<p>回压流：类PushbackInputStream提供了几个unread()方法，把读过的一个或几个字节数据退回到输入流中，当然也可以回压别的字节数据到输入流中。</p>\n<p>unread(int b)   unread(byte[] b)</p>\n<p>打印流PrintStream是非常重要的输出流，在标准输出中经常用到的System.out就是指向PrintStream实例的一个引用</p>\n<p>对象流：读取文件中的对象或将对象写入文件中（看下面序列化）</p>\n<p>管道流：管道数据流主要用于线程间的通信</p>\n<h3 id=\"文件\">文件</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//反正我大作业这么写能跑</span></span><br><span class=\"line\"><span class=\"type\">File</span> <span class=\"variable\">chatFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;...&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">BufferedReader</span> <span class=\"variable\">Br</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(chatFile));</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((Message = Br.readLine())!=<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(Message);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这么写也行</span></span><br><span class=\"line\"><span class=\"type\">FileInputStream</span> <span class=\"variable\">fileInputStream</span> <span class=\"operator\">=</span> .......;</span><br><span class=\"line\"><span class=\"type\">BufferedReader</span> <span class=\"variable\">reader</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(fileInputStream));</span><br><span class=\"line\">String str;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((str = reader.readLine())!=<span class=\"literal\">null</span>)</span><br><span class=\"line\">    System.out.println(str);</span><br></pre></td></tr></table></figure>\n<h3 id=\"序列化\">序列化</h3>\n<p>简单</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">serializeBox</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;./box.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(f));</span><br><span class=\"line\">    oos.writeObject(box);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Box <span class=\"title function_\">deserializeBox</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">    <span class=\"type\">File</span> <span class=\"variable\">f</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;./box.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">ois</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(f));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Box)ois.readObject();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"多线程\">多线程</h2>\n<h3 id=\"进程？线程？\">进程？线程？</h3>\n<p>进程（process）是<strong>程序的一次执行过程</strong>，是系统运行程序的基本单位。程序是静态的，进程是动态的。系统运行一个程序即是一个进程从创建、运行到消亡的过程</p>\n<p>**线程：**比进程更小的执行单位，一个进程中可以包含多个线程</p>\n<p>线程优先级：范围 1~10 （10 级）。数值越大，级别越高 setPriority( )</p>\n<h3 id=\"线程方法\">线程方法</h3>\n<p>start()：启动一个线程。</p>\n<p>run()：线程体,由start()方法调用，run()方法返回时当前线程结束</p>\n<p>sleep(int n)：使线程睡眠n毫秒</p>\n<p>yield()：将CPU控制权主动移交到下一个可运行线程</p>\n<p>join()：方法join()将引起现行线程等待</p>\n<p>sleep&amp;yield：都是静态的实例方法</p>\n<p>sleep()使线程转入阻塞状态，而yield()使线程转入runnable状态</p>\n<p>yield()给相同优先级或更高的线程运行机会，如果当前没有存在相同优先级的线程，则yield()什么都不做</p>\n<p>sleep()会有中断异常抛出，而yiled()不抛出任何异常</p>\n<p>sleep()方法具有更好的可移植性</p>\n<p>wait&amp;sleep</p>\n<p>sleep()方法不会释放对象的锁，而wait()\\方法进入等待时，可以释放对象的锁</p>\n<p>wait,notify和notifyAll都是与同步相关联的方法,只有在synchronized方法中才可以用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Thread1</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;o.O&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TestThread</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Runnable</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>  <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//??</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">TestThread</span> <span class=\"variable\">testThread</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TestThread</span>();</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">thread1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(testThread, <span class=\"string\">&quot;Thread1&quot;</span>);</span><br><span class=\"line\">thread1.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"synchronized\">synchronized</h3>\n<p>用关synchronized为共享资源加锁，在任何时刻只有一个线程能用</p>\n<p>synchronized关键字可以使用在：</p>\n<p>①1.一个成员方法上</p>\n<p>②2.一个静态方法上</p>\n<p>③3.一个语句块上</p>\n<p>synchronized(obj)</p>\n<p>wait让本线程等待；别的线程notify可以让等待区一个线程准备开始（但是如果有线程用锁，该线程还是会处于BLOCKED状态）notifyAll唤醒所有</p>\n<p>wait(xx)可以传入时间，单位毫秒</p>\n<h3 id=\"守护进程\">守护进程</h3>\n<p>当一个应用程序的所有非守护线程终止运行时，即使仍然有守护线程在运行，应用程序也将终止</p>\n<p>只要有一个非守护线程在运行，应用程序就不会终止</p>\n<p>用setDaemon() 来将一个线程设为守护线程</p>\n<h3 id=\"Timer\">Timer</h3>\n<p>Timer类的schedule(TimerTask task, long delay, long period)方法用来设置定时器需要定时执行的任务</p>\n<p>定时器将在delay毫秒以后开始执行task任务（即执行TimerTask实例的run()方法），每隔period毫秒重复执行一次</p>\n<h2 id=\"网络\">网络</h2>\n<p>最常用的传输层的网络通信协议是TCP和UDP.</p>\n<p>端口号的范围为0~65535之间，0~1023之间的端口数是用于一些知名的网络服务和应用</p>\n<p>利用TCP协议进行通信的两个应用程序是有主从之分的，一个称为服务器程序，一个称为客户机程序，两者的功能和编写方法不大一样</p>\n<p>Socket(String host,int port);</p>\n<p>socket.getOutputStream();</p>\n<p>利用UDP通信的两个程序是平等的，没有主次之分，两个程序的代码可以完全一样</p>\n<p>Public DatagramSocket(int port);</p>\n<p>Send(DatagramPacket p)方法</p>\n<p>Receive(DatagramPacket p)</p>\n<p>Public DatagramPacket(byte[] buf,int length);</p>\n<p>tcp能提供数据可靠性</p>\n<p>udp不能保证数据库可靠性</p>\n<p>tcp传输效率比udp低</p>\n",
            "tags": [
                "大学",
                "总结",
                "Java"
            ]
        }
    ]
}